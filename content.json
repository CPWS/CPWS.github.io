{"meta":{"title":"Prossible's Blog","subtitle":null,"description":null,"author":"zhuli","url":"https://CPWS.github.io","root":"/CPWS.github.io/"},"pages":[],"posts":[{"title":"Java邮箱接口","slug":"Java邮箱接口","date":"2019-09-25T07:52:14.000Z","updated":"2019-09-25T08:12:16.918Z","comments":true,"path":"2019/09/25/Java邮箱接口/","link":"","permalink":"https://CPWS.github.io/2019/09/25/Java邮箱接口/","excerpt":"","text":"邮箱的相关标准 常见的邮件协议 SMTP（Simple Mail Transfer Protocol）：即简单邮箱传输协议，它是一组用于源地址到目的地址传送邮件的规则，由它来控制信息的中转方式。 POP3（Post Office Protocol - Version 3）: 即邮局协议版本 3，用于接收电子邮件的标准协议。","categories":[],"tags":[]},{"title":"Struts2.5","slug":"Struts2-5","date":"2019-09-17T08:17:50.000Z","updated":"2019-09-29T11:15:07.451Z","comments":true,"path":"2019/09/17/Struts2-5/","link":"","permalink":"https://CPWS.github.io/2019/09/17/Struts2-5/","excerpt":"","text":"Struts2的下载和安装 为Web应用增加的Struts支持 下载和安装Struts2的步骤如下: 登录https://struts.apache.org/download.cgi#struts2520站点，下载Struts2的最新包2.5.20。 进入Struts2的解压目录的lib目录下，将一些相关的jar包导入到Web用于的/web-inf/lib路径下。 编写Web应用的web.xml配置文件，配置Struts2的核心Filter。 12345678910111213141516171819202122&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://java.sun.com/xml/ns/javaee\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd\" version=\"3.0\"&gt; &lt;display-name&gt;Struts_studyByBook01&lt;/display-name&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;welcome-file&gt;default.html&lt;/welcome-file&gt; &lt;welcome-file&gt;default.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;default.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;!-- 定义Struts2的核心Filter --&gt; &lt;filter&gt; &lt;filter-name&gt;Struts2&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.struts2.dispatcher.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;!-- 让Strut2 的核心标签库Filter拦截所有的请求 --&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;Struts2&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt; 将Struts2解压目录下的apps目录下的struts2-rest-showcase.war压缩包的struts.xml配置文件复制到web应用的src目录下。并将该配置文件修改为如下格式： 1234567891011&lt;struts&gt; &lt;!-- Overwrite Convention --&gt; &lt;constant name=\"struts.enable.DynamicMethodInvocation\" value=\"false\"/&gt; &lt;constant name=\"struts.devMode\" value=\"true\"/&gt; &lt;!-- Uncomment the lines below to use Jackson XML bindings instead of the XStream library to handle XML serialisations --&gt; &lt;package name=\"crazyit\" namespace=\"/\" extends=\"struts-default\"&gt; &lt;action name=\"*\"&gt; &lt;result&gt;/WEB-INF/content/&#123;1&#125;.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; 在Eclipse使用Struts2 首先创建一个Dynamic Web Project,也就是创建一个动态web项目。 在项目的/webcontent/WEB-INF/lib导入一些响相应的jar包。类型参考上面第2点。 打开/webcontent/WEB-INF/web.xml，编译该文件，并在其中定义Struts2核心的Filter。 在项目的src目录下定义一个struts.xml配置文件，其内容参考上面第四点。 至此，该Web应用完全具备了Struts2框架的支持。 增加登录处理 创建一个Strut2Demo的动态web项目，并且按上面的步骤依次导入相关的jar包、配置web.xml、配置struts.xml。 在/webcontent/WEB-INF/content/下添加一个名为loginForm的JSP页面,该页面的代码如下： 1234567891011121314151617&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@taglib prefix=\"s\" uri=\"/struts-tags\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;&lt;s:text name=\"loginPage\"&gt;&lt;/s:text&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;s:form action=\"login\"&gt; &lt;s:textfield name=\"username\" key=\"user\"&gt;&lt;/s:textfield&gt; &lt;s:textfield name=\"password\" key=\"pass\"&gt;&lt;/s:textfield&gt; &lt;s:submit key=\"login\"&gt;&lt;/s:submit&gt; &lt;/s:form&gt;&lt;/body&gt;&lt;/html&gt; 除此之外，还要添加一个welcome.jsp和error.jsp作为登录成功，登录失败的提示页面，它们的代码如下： 12345678910111213141516&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@taglib prefix=\"s\" uri=\"/struts-tags\"%&gt;&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt; &lt;title&gt;&lt;s:text name=\"succPage\"/&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!--成功界面--&gt; &lt;s:text name=\"succTip\"&gt; &lt;s:param&gt;$&#123;sessionScope.user&#125;&lt;/s:param&gt; &lt;/s:text&gt;&lt;br/&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314&lt;%@page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@taglib prefix=\"s\" uri=\"/struts-tags\"%&gt;&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt; &lt;title&gt;&lt;s:text name=\"errorPage\"/&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!--失败界面--&gt; &lt;s:text name=\"failTip\"/&gt;&lt;/body&gt;&lt;/html&gt; 配置Struts.xml文件 1234567891011121314&lt;struts&gt; &lt;!-- Overwrite Convention --&gt; &lt;!-- 指定全局国际化资源文件 --&gt; &lt;constant name=\"struts.enable.DynamicMethodInvocation\" value=\"false\"/&gt; &lt;constant name=\"struts.custom.i18n.resources\" value=\"mess\"/&gt; &lt;constant name=\"struts.devMode\" value=\"true\"&gt;&lt;/constant&gt; &lt;!-- Uncomment the lines below to use Jackson XML bindings instead of the XStream library to handle XML serialisations --&gt; &lt;!-- 所有的Action定义都应方法package包下 --&gt; &lt;package name=\"loginForm\" namespace=\"/\" extends=\"struts-default\"&gt; &lt;action name=\"*\"&gt; &lt;result&gt;/WEB-INF/content/&#123;1&#125;.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; 由于上面已经指定了国际化资源，所以在src目录还应该提供一个名为mess_zh_CN.properties的文件，其内容为： loginPage=登录页面 errorPage=错误页面 succPage=成功页面 failTip=对不起，您不能登录！ succTip=欢迎，{0}，您已经登录！ user=用户名 pass=密码 login=登录 把项目部署到Tomcat服务器，并在浏览器的地址栏上输入 http://localhost:8080/Strust2Demo/LoginForm，将会看到登录界面。 在Eclipse工具创建一个Java类，该Java类的类名为LoginAction，代码如下 123456789101112131415161718192021222324252627282930313233343536package org.crazyit.app.action;import com.opensymphony.xwork2.ActionContext;import com.opensymphony.xwork2.ActionSupport;public class LoginAction extends ActionSupport &#123; private static final long serialVersionUID = 1L; //定义封装请求参数的username和password成员变量 private String username; private String password; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; //定义处理用户请求的execute方法 public String execute() &#123; System.out.println(getUsername() + \"--&gt;\" + getPassword()); //当username为crazyit.org,password为leegang时即登录成功 if(getUsername().equals(\"crazyit.org\") &amp;&amp; getPassword().equals(\"leegang\")) &#123; //采用解耦的方法获取session对象 ActionContext.getContext().getSession().put(\"user\",getUsername()); return SUCCESS; &#125; return ERROR; &#125; &#125; 在struts.xml中添加一个name=&quot;login&quot;&lt;action.../&gt;代码如下： 12345&lt;action name=\"login\" class=\"org.crazyit.app.action.LoginAction\"&gt; &lt;!-- 定义三个逻辑视图和物理资源之间进行映射 --&gt; &lt;result name=\"success\"&gt;/WEB-INF/content/welcome.jsp&lt;/result&gt; &lt;result name=\"error\"&gt;/WEB-INF/content/error.jsp&lt;/result&gt;&lt;/action&gt; 至此，整个Struts2的应用已经创建完成，再次重启服务器，然后先访问loginForm，并在该页面输入用户名和密码进行登录，如果为crazyit.org、leegang，则跳转到welcome.jsp页面，否则则跳转到error.jsp。 Struts2的流程 Struts2应用的开发步骤 在web.xml文件中定义核心的Filter来拦截用户请求。 如果需要以POST的方式提交请求，则定义包含表单数据的JSP页面。如果仅仅是以GET方法发送请求，则无需通过这一步。 定义处理用户请求的Action类。 配置Action 配置处理结果和物理视图资源之间的对应关系。 编写视图资源。如果Action需要将一些数据传给视图资源，则可以借助于OGNL表达式。 经过上面6个步骤，基本完成一个Struts2的处理流程的开发，也就是可以执行一次完整的请求--&gt;响应过程。 Struts2的运行流程 Struts2的常规配置 虽然Struts2提供了Convention插件来管理Action，结果映射，但对于大部分实际开发来说还会考虑使用XML配置文件来管理Struts2的配置信息。 Struts2的默认配置文件名为struts.xml，该文件放在web应用的类加载器路径下，通常就是方法WEB-INF/classes路径下。 struts.xml配置文件的最大作用就是配置Action与请求之间的对应关系，并配置逻辑视图名与物理视图资源的对应关系，除此之外，struts.xml文件还有一些额外的配置，例如Bean配置，配置常量以及导入其他配置文件等。 常量配置 Strut2还提供了struts.properties文件来管理常量 struts.properties是一个标准的properties文件，该文件包含了系列key-value，每个key对应一个Struts2常量，该key对应的value值就是一个Struts2常量值。 Struts2配置常量总共有三种方式： 通过struts.properties文件 通过struts.xml文件 通过web.xml文件 如下struts.xml配置片段在struts.xml文件中配置一个常量，该常量即可代替struts.properties文件中struts2配置属性。 1234567891011121314151617181920212223&lt;!DOCTYPE struts PUBLIC \"-//Apache Software Foundation//DTD Struts Configuration 2.5//EN\" \"http://struts.apache.org/dtds/struts-2.5.dtd\"&gt;&lt;struts&gt; &lt;!-- Overwrite Convention --&gt; &lt;!-- 指定全局国际化资源文件 --&gt; &lt;constant name=\"struts.enable.DynamicMethodInvocation\" value=\"false\"/&gt; &lt;constant name=\"struts.custom.i18n.resources\" value=\"mess\"/&gt; &lt;constant name=\"struts.devMode\" value=\"true\"&gt;&lt;/constant&gt; &lt;!-- Uncomment the lines below to use Jackson XML bindings instead of the XStream library to handle XML serialisations --&gt; &lt;!-- 所有的Action定义都应方法package包下 --&gt; &lt;package name=\"loginForm\" namespace=\"/\" extends=\"struts-default\"&gt; &lt;action name=\"*\"&gt; &lt;result&gt;/WEB-INF/content/&#123;1&#125;.jsp&lt;/result&gt; &lt;/action&gt; &lt;action name=\"login\" class=\"org.crazyit.app.action.LoginAction\"&gt; &lt;!-- 定义三个逻辑视图和物理资源之间进行映射 --&gt; &lt;result name=\"success\"&gt;/WEB-INF/content/welcome.jsp&lt;/result&gt; &lt;result name=\"error\"&gt;/WEB-INF/content/error.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; 在web.xml配置文件中配置常量 12345678910111213&lt;filter&gt; &lt;filter-name&gt;Struts2&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.struts2.dispatcher.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;struts.custom.i18n.resources&lt;/param-name&gt; &lt;param-value&gt;mess&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;!-- 让Strut2 的核心标签库Filter拦截所有的请求 --&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;Struts2&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 包含其他配置文件 下面的struts.xml文件就通过&lt;include ../&gt;手动导入一个配置文件。 1&lt;include file=\"struts-part1.xml\"&gt;&lt;/include&gt; 被包含的配置文件应该也包含dtd信息和struts根元素等信息，且该配置文件也应该放在WEB-INF/classes/路径下。 实现Action Action类默认处理用户请求的方法：execute方法。 Action接口和ActionSupport基类 下面是一个标准的Action接口代码 1234567891011package com.opensymphony.xwork2;public interface Action &#123; public static final String SUCCESS = \"success\"; public static final String NONE = \"none\"; public static final String ERROR = \"error\"; public static final String INPUT = \"input\"; public static final String LOGIN = \"login\"; public String execute() throws Exception;&#125; 下面是ActionSupport实现类的片段代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327/* * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */package com.opensymphony.xwork2;import com.opensymphony.xwork2.inject.Container;import com.opensymphony.xwork2.inject.Inject;import com.opensymphony.xwork2.interceptor.ValidationAware;import com.opensymphony.xwork2.util.ValueStack;import org.apache.logging.log4j.LogManager;import org.apache.logging.log4j.Logger;import org.apache.struts2.StrutsConstants;import java.io.Serializable;import java.util.*;/** * Provides a default implementation for the most common actions. * See the documentation for all the interfaces this class implements for more detailed information. */public class ActionSupport implements Action, Validateable, ValidationAware, TextProvider, LocaleProvider, Serializable &#123; private static final Logger LOG = LogManager.getLogger(ActionSupport.class); private final ValidationAwareSupport validationAware = new ValidationAwareSupport(); private transient TextProvider textProvider; private transient LocaleProvider localeProvider; protected Container container; public void setActionErrors(Collection&lt;String&gt; errorMessages) &#123; validationAware.setActionErrors(errorMessages); &#125; public Collection&lt;String&gt; getActionErrors() &#123; return validationAware.getActionErrors(); &#125; public void setActionMessages(Collection&lt;String&gt; messages) &#123; validationAware.setActionMessages(messages); &#125; public Collection&lt;String&gt; getActionMessages() &#123; return validationAware.getActionMessages(); &#125; public void setFieldErrors(Map&lt;String, List&lt;String&gt;&gt; errorMap) &#123; validationAware.setFieldErrors(errorMap); &#125; public Map&lt;String, List&lt;String&gt;&gt; getFieldErrors() &#123; return validationAware.getFieldErrors(); &#125; @Override public Locale getLocale() &#123; return getLocaleProvider().getLocale(); &#125; @Override public boolean isValidLocaleString(String localeStr) &#123; return getLocaleProvider().isValidLocaleString(localeStr); &#125; @Override public boolean isValidLocale(Locale locale) &#123; return getLocaleProvider().isValidLocale(locale); &#125; public boolean hasKey(String key) &#123; return getTextProvider().hasKey(key); &#125; public String getText(String aTextName) &#123; return getTextProvider().getText(aTextName); &#125; public String getText(String aTextName, String defaultValue) &#123; return getTextProvider().getText(aTextName, defaultValue); &#125; public String getText(String aTextName, String defaultValue, String obj) &#123; return getTextProvider().getText(aTextName, defaultValue, obj); &#125; public String getText(String aTextName, List&lt;?&gt; args) &#123; return getTextProvider().getText(aTextName, args); &#125; public String getText(String key, String[] args) &#123; return getTextProvider().getText(key, args); &#125; public String getText(String aTextName, String defaultValue, List&lt;?&gt; args) &#123; return getTextProvider().getText(aTextName, defaultValue, args); &#125; public String getText(String key, String defaultValue, String[] args) &#123; return getTextProvider().getText(key, defaultValue, args); &#125; public String getText(String key, String defaultValue, List&lt;?&gt; args, ValueStack stack) &#123; return getTextProvider().getText(key, defaultValue, args, stack); &#125; public String getText(String key, String defaultValue, String[] args, ValueStack stack) &#123; return getTextProvider().getText(key, defaultValue, args, stack); &#125; /** * Dedicated method to support I10N and conversion errors * * @param key message which contains formatting string * @param expr that should be formatted * @return formatted expr with format specified by key */ public String getFormatted(String key, String expr) &#123; Map&lt;String, Object&gt; conversionErrors = ActionContext.getContext().getConversionErrors(); if (conversionErrors.containsKey(expr)) &#123; String[] vals = (String[]) conversionErrors.get(expr); return vals[0]; &#125; else &#123; final ValueStack valueStack = ActionContext.getContext().getValueStack(); final Object val = valueStack.findValue(expr); return getText(key, Arrays.asList(val)); &#125; &#125; public ResourceBundle getTexts() &#123; return getTextProvider().getTexts(); &#125; public ResourceBundle getTexts(String aBundleName) &#123; return getTextProvider().getTexts(aBundleName); &#125; public void addActionError(String anErrorMessage) &#123; validationAware.addActionError(anErrorMessage); &#125; public void addActionMessage(String aMessage) &#123; validationAware.addActionMessage(aMessage); &#125; public void addFieldError(String fieldName, String errorMessage) &#123; validationAware.addFieldError(fieldName, errorMessage); &#125; public String input() throws Exception &#123; return INPUT; &#125; /** * A default implementation that does nothing an returns \"success\". * * &lt;p&gt; * Subclasses should override this method to provide their business logic. * &lt;/p&gt; * * &lt;p&gt; * See also &#123;@link com.opensymphony.xwork2.Action#execute()&#125;. * &lt;/p&gt; * * @return returns &#123;@link #SUCCESS&#125; * @throws Exception can be thrown by subclasses. */ public String execute() throws Exception &#123; return SUCCESS; &#125; public boolean hasActionErrors() &#123; return validationAware.hasActionErrors(); &#125; public boolean hasActionMessages() &#123; return validationAware.hasActionMessages(); &#125; public boolean hasErrors() &#123; return validationAware.hasErrors(); &#125; public boolean hasFieldErrors() &#123; return validationAware.hasFieldErrors(); &#125; /** * Clears field errors. Useful for Continuations and other situations * where you might want to clear parts of the state on the same action. */ public void clearFieldErrors() &#123; validationAware.clearFieldErrors(); &#125; /** * Clears action errors. Useful for Continuations and other situations * where you might want to clear parts of the state on the same action. */ public void clearActionErrors() &#123; validationAware.clearActionErrors(); &#125; /** * Clears messages. Useful for Continuations and other situations * where you might want to clear parts of the state on the same action. */ public void clearMessages() &#123; validationAware.clearMessages(); &#125; /** * Clears all errors. Useful for Continuations and other situations * where you might want to clear parts of the state on the same action. */ public void clearErrors() &#123; validationAware.clearErrors(); &#125; /** * Clears all errors and messages. Useful for Continuations and other situations * where you might want to clear parts of the state on the same action. */ public void clearErrorsAndMessages() &#123; validationAware.clearErrorsAndMessages(); &#125; /** * A default implementation that validates nothing. * Subclasses should override this method to provide validations. */ public void validate() &#123; &#125; @Override public Object clone() throws CloneNotSupportedException &#123; return super.clone(); &#125; /** * &lt;!-- START SNIPPET: pause-method --&gt; * Stops the action invocation immediately (by throwing a PauseException) and causes the action invocation to return * the specified result, such as &#123;@link #SUCCESS&#125;, &#123;@link #INPUT&#125;, etc. * * &lt;p&gt; * The next time this action is invoked (and using the same continuation ID), the method will resume immediately * after where this method was called, with the entire call stack in the execute method restored. * &lt;/p&gt; * * &lt;p&gt; * Note: this method can &lt;b&gt;only&lt;/b&gt; be called within the &#123;@link #execute()&#125; method. * &lt;/p&gt; * * &lt;!-- END SNIPPET: pause-method --&gt; * * @param result the result to return - the same type of return value in the &#123;@link #execute()&#125; method. */ public void pause(String result) &#123; &#125; /** * If called first time it will create &#123;@link com.opensymphony.xwork2.TextProviderFactory&#125;, * inject dependency (if &#123;@link com.opensymphony.xwork2.inject.Container&#125; is accesible) into in, * then will create new &#123;@link com.opensymphony.xwork2.TextProvider&#125; and store it in a field * for future references and at the returns reference to that field * * @return reference to field with TextProvider */ protected TextProvider getTextProvider() &#123; if (textProvider == null) &#123; Container container = getContainer(); TextProviderFactory tpf = container.getInstance(TextProviderFactory.class); textProvider = tpf.createInstance(getClass()); &#125; return textProvider; &#125; protected LocaleProvider getLocaleProvider() &#123; if (localeProvider == null) &#123; Container container = getContainer(); LocaleProviderFactory localeProviderFactory = container.getInstance(LocaleProviderFactory.class); localeProvider = localeProviderFactory.createLocaleProvider(); &#125; return localeProvider; &#125; /** * TODO: This a temporary solution, maybe we should consider stop injecting container into beans */ protected Container getContainer() &#123; if (container == null) &#123; container = ActionContext.getContext().getContainer(); if (container != null) &#123; boolean devMode = Boolean.parseBoolean(container.getInstance(String.class, StrutsConstants.STRUTS_DEVMODE)); if (devMode) &#123; LOG.warn(\"Container is null, action was created manually? Fallback to ActionContext\"); &#125; else &#123; LOG.debug(\"Container is null, action was created manually? Fallback to ActionContext\"); &#125; &#125; else &#123; LOG.warn(\"Container is null, action was created out of ActionContext scope?!?\"); &#125; &#125; return container; &#125; @Inject public void setContainer(Container container) &#123; this.container = container; &#125;&#125; Action访问ServletAPI Struts2还提供了一个ActionContext类，Struts2通过该类来访问ServletAPI。下面是ActionContext类中包含的几个常用方法： Object get(Object ley)：该方法类似于调用HtppServletRequest的getAttribute(String name) Map getApplication()：返回一个Map对象，该对象模拟了该应用的ServletContext实例. static ActionContext getContext()：静态方法，获取系统的ActionContext实例。 Map getParameters()：获取所有的请求参数。类似于调用HttpServletRequest对象的getParametermap（）方法。 Map getSession()：返回一个Map对象，该Map对象模拟了HttpSession的实例。 void setApplication(Map application)：直接传入一个Map实例，将该Map实例里的key-value转换成application的属性名和属性值。 void setSession(Map session)：直接传入一个Map实例，将该Map实例里的key-value转换成session的属性名和属性值。 通过案例示范在rquest、session、application范围设置属性值12345678910111213141516171819202122&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://java.sun.com/xml/ns/javaee\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd\" version=\"3.0\"&gt; &lt;display-name&gt;Struts_studyByBook01&lt;/display-name&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;welcome-file&gt;default.html&lt;/welcome-file&gt; &lt;welcome-file&gt;default.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;default.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;!-- 定义Struts2的核心Filter --&gt; &lt;filter&gt; &lt;filter-name&gt;Struts2&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.struts2.dispatcher.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;!-- 让Strut2 的核心标签库Filter拦截所有的请求 --&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;Struts2&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt; 1234567891011121314151617&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib prefix=\"s\" uri=\"/struts-tags\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;&lt;s:text name=\"loginPage\"&gt;&lt;/s:text&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;s:form action=\"login\"&gt; &lt;s:textfield name=\"username\" key=\"user\"&gt;&lt;/s:textfield&gt; &lt;s:textfield name=\"password\" key=\"pass\"&gt;&lt;/s:textfield&gt; &lt;s:submit key=\"login\"&gt;&lt;/s:submit&gt; &lt;/s:form&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@taglib prefix=\"s\" uri=\"/struts-tags\"%&gt;&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt; &lt;title&gt;&lt;s:text name=\"succPage\"/&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; 本站访问的次数：$&#123;applicationScope.counter&#125;&lt;br&gt; $&#123;sessionScope.user&#125;，您已登录成功！ $&#123;requestScope.tip&#125;&lt;/body&gt;&lt;/html&gt; 12345678910111213&lt;%@page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@taglib prefix=\"s\" uri=\"/struts-tags\"%&gt;&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt; &lt;title&gt;&lt;s:text name=\"errorPage\"/&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; $&#123;sessionScope.user&#125;,$&#123;requestScope.tip&#125;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package org.crazyit.app.action;import com.opensymphony.xwork2.Action;import com.opensymphony.xwork2.ActionContext;public class LoginAction implements Action&#123; private String username; private String password; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; @Override public String execute() throws Exception &#123; ActionContext ctx=ActionContext.getContext(); //通过ActionContext访问application范围内的属性 Integer counter=(Integer) ctx.getApplication().get(\"counter\"); if(counter == null) &#123; counter=1; &#125;else &#123; counter = counter+1; &#125; //通过ActionContext设置application范围的属性 ctx.getApplication().put(\"counter\",counter); //通过ActionContext设置Session范围内的属性 ctx.getSession().put(\"user\",getUsername()); if(getUsername().equals(\"crazyit\") &amp;&amp; getPassword().equals(\"leegang\")) &#123; //通过ActionContext设置request范围内的属性 ctx.put(\"tip\", \"服务器提示，你已经成功登录\"); return SUCCESS; &#125; //通过ActionContext设置request范围内的属性 ctx.put(\"tip\", \"服务器提示，登录失败\"); return ERROR; &#125; &#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!--/* * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */--&gt;&lt;!-- 下面指定struts2配置文件的dtd信息 --&gt;&lt;!DOCTYPE struts PUBLIC \"-//Apache Software Foundation//DTD Struts Configuration 2.5//EN\" \"http://struts.apache.org/dtds/struts-2.5.dtd\"&gt;&lt;struts&gt; &lt;!-- Overwrite Convention --&gt; &lt;!-- 指定全局国际化资源文件 --&gt; &lt;constant name=\"struts.enable.DynamicMethodInvocation\" value=\"false\"/&gt; &lt;constant name=\"struts.custom.i18n.resources\" value=\"mess\"/&gt; &lt;constant name=\"struts.devMode\" value=\"true\"&gt;&lt;/constant&gt; &lt;!-- Uncomment the lines below to use Jackson XML bindings instead of the XStream library to handle XML serialisations --&gt; &lt;!-- 所有的Action定义都应方法package包下 --&gt; &lt;!-- package元素是struts2配置文件的核心，该元素可以出现0次或者无限次 --&gt; &lt;package name=\"loginForm\" namespace=\"/\" extends=\"struts-default\" &gt; &lt;action name=\"*\"&gt; &lt;result&gt;/WEB-INF/content/&#123;1&#125;.jsp&lt;/result&gt; &lt;/action&gt; &lt;action name=\"login\" class=\"org.crazyit.app.action.LoginAction\"&gt; &lt;!-- 处理结果返回为error,则对应于 /WEB-INF/content/error.jsp视图资源 --&gt; &lt;result name=\"error\"&gt; /WEB-INF/content/error.jsp&lt;/result&gt; &lt;!-- 处理结果返回为success,则对应于 /WEB-INF/content/welcome.jsp视图资源 --&gt; &lt;result name=\"success\"&gt; /WEB-INF/content/welcome.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; mess_zh_CN.properties的文件，其内容为： loginPage=登录页面 errorPage=错误页面 succPage=成功页面 failTip=对不起，您不能登录！ succTip=欢迎，{0}，您已经登录！ user=用户名 pass=密码 login=登录 从以上案列可以看出，Struts2的Action设计非常优秀，它既可以与ServletAPI解耦，也可以脱离Web容器运行，也可以脱离Web容器测试，又可以用简单的方式来操作request、session、application范围内的属性。 Action直接访问ServletAPI 虽然struts2提供了ActionContext来访问ServletAPI，但是这种访问毕竟不是直接获得Servlet API实例。为了在Action中直接访问ServletAPI，Struts2还提供如下几个接口：ServletContextAware：实现该接口的Action可以直接访问Web应用的ServletContext实例。ServletRequestAware：实现该接口的Action可以直接访问Web应用的HttpServletRequest实例。ServletResponseAware：实现该接口的Action可以直接访问Web应用的HttpServletResponse实例。 案列：以ServletResponseAware为例,如何在Action中访问HttpServletResponse123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172package org.crazyit.app.action;import javax.servlet.http.Cookie;import javax.servlet.http.HttpServletResponse;import org.apache.struts2.ServletActionContext;import org.apache.struts2.interceptor.ServletResponseAware;import com.opensymphony.xwork2.Action;import com.opensymphony.xwork2.ActionContext;/*** * 解耦方式 * @author 1huangzewei * */public class LoginAction02 implements Action,ServletResponseAware&#123; private String username; private String password; private HttpServletResponse response; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; //重写ServletResponseAware接口必须实现的方法 @Override public void setServletResponse(HttpServletResponse response) &#123; // TODO Auto-generated method stub this.response=response; &#125; @Override public String execute() throws Exception &#123; System.out.println(\"---- LoginAction2---\"); // TODO Auto-generated method stub ActionContext ctx=ActionContext.getContext(); //通过ActionContext访问application范围内的属性 Integer counter=(Integer) ctx.getApplication().get(\"counter\"); if(counter == null) &#123; counter=1; &#125;else &#123; counter = counter+1; &#125; //通过ActionContext设置application范围的属性 ctx.getApplication().put(\"counter\", counter); // 通过ActionContext设置Session范围内的属性 ctx.getSession().put(\"user\", getUsername()); if (getUsername().equals(\"crazyit\") &amp;&amp; getPassword().equals(\"leegang\")) &#123; //通过Response添加cookie Cookie c=new Cookie(\"user\", getUsername()); c.setMaxAge(60*60); response.addCookie(c); //通过ActionContext设置request范围的属性 ctx.put(\"tip\", \"服务器提示，你已经成功登录\"); return SUCCESS; &#125; // 通过ActionContext设置request范围内的属性 ctx.put(\"tip\", \"服务器提示，登录失败\"); return ERROR; &#125; &#125; 123456789101112131415&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@taglib prefix=\"s\" uri=\"/struts-tags\"%&gt;&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt; &lt;title&gt;&lt;s:text name=\"succPage\"/&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; 本站访问的次数：$&#123;applicationScope.counter&#125;&lt;br&gt; &lt;!-- $&#123;sessionScope.user&#125; --&gt;$&#123;user&#125;，您已登录成功！ $&#123;requestScope.tip&#125;&lt;/body&gt;&lt;/html&gt; ServletActionContext访问ServletAPI 除此之外，为了能直接访问ServletAPI，Struts2还提供了一个ServletActionContext工具类。该类包含如下几个静态方法： static PageContext getPageContext()：取得web应用的pageContext对象。 static HttpServletRequest getRequest()：取得web应用的request对象。 static HttpServletResponse getResponse()：取得web应用的response对象。 static ServletContext getServletContext()：取得web应用的ServletContext对象。 案列，以static HttpServletResponse getResponse()为例，获取response实例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package org.crazyit.app.action;import javax.servlet.http.Cookie;import javax.servlet.http.HttpServletResponse;import org.apache.struts2.ServletActionContext;import org.apache.struts2.interceptor.ServletResponseAware;import com.opensymphony.xwork2.Action;import com.opensymphony.xwork2.ActionContext;/*** * 解耦方式 * @author 1huangzewei * */public class LoginAction03&#123; private String username; private String password; private HttpServletResponse response; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; @Override public String execute() throws Exception &#123; System.out.println(\"---- LoginAction2---\"); // TODO Auto-generated method stub ActionContext ctx=ActionContext.getContext(); //通过ActionContext访问application范围内的属性 Integer counter=(Integer) ctx.getApplication().get(\"counter\"); if(counter == null) &#123; counter=1; &#125;else &#123; counter = counter+1; &#125; //通过ActionContext设置application范围的属性 ctx.getApplication().put(\"counter\", counter); // 通过ActionContext设置Session范围内的属性 ctx.getSession().put(\"user\", getUsername()); if (getUsername().equals(\"crazyit\") &amp;&amp; getPassword().equals(\"leegang\")) &#123; //通过Response添加cookie Cookie c=new Cookie(\"user\", getUsername()); c.setMaxAge(60*60); ServletActionContext().getResponse().addCookie(c); //通过ActionContext设置request范围的属性 ctx.put(\"tip\", \"服务器提示，你已经成功登录\"); return SUCCESS; &#125; // 通过ActionContext设置request范围内的属性 ctx.put(\"tip\", \"服务器提示，登录失败\"); return ERROR; &#125; &#125; 配置Action 实现了Action处理类之后，就可以在struts.xml文件中配置该Action了。配置Action就是让Struts2知道哪个Action处理哪个请求，也就是完成用户请求和Action之间的对应关系。 包和命名空间 定义&lt;package ../&gt;元素时可以指定如下几个元素： name：必须元素，该属性指定该包的名字，该名字是该包被其他包引用的key； extends：可选属性，该属性指定该包继承其他包。继承其他包，可以继承其他包中的Action定义、拦截器定义等。 namespace：可选元素。该属性定义该包的命名空间。 abstract：可选元素。它指定该包是否为抽象包。抽象包不能包含Action定义。 Action的基本配置 定义&lt;action ../ &gt;元素时可以指定如下几个元素： name：必须元素，该属性定义该action的名字，也定义了处理该请求的url class：非必须元素。用于指定action的实现类，如果没有定义该属性，系统则默认使用ActionSupport作为处理类。 method：非必须元素。该属性用于指定处理类中的业务处理方法的方法名，如果没有定义该属性，系统则默认使用execute。 配置Action时应该配置逻辑视图名与物理视图名之间的对应关系，而配置他们之间的映射关系，是通过&lt;result ../&gt;元素来完成。 使用Action的动态方法调用 动态方法调用采用如下方式:ActionName!method.action，其中actionName指定的是要提交到哪个Action，method指定的是交给哪个方法调用。 案列实现： 登录注册界面 123456789101112131415161718192021222324&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib prefix=\"s\" uri=\"/struts-tags\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;&lt;s:text name=\"loginPage\"&gt;&lt;/s:text&gt;&lt;/title&gt;&lt;script&gt; function regist()&#123; //获得第1个表单页面 targetForm=document.forms[0]; targetForm.action=\"login02!regist\" &#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=\"login02\"&gt; 用户名：&lt;input name=\"username\"/&gt;&lt;br/&gt; 密 码：&lt;input name=\"password\"/&gt;&lt;br/&gt; &lt;input type=\"submit\" value=\"登录\"/&gt;&lt;input type=\"submit\" value=\"注册\" onclick=\"regist();\"/&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 业务处理类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package org.crazyit.app.action;import com.opensymphony.xwork2.Action;import com.opensymphony.xwork2.ActionContext;import com.opensymphony.xwork2.ActionSupport;public class LoginRegisterAction extends ActionSupport&#123; //封装用户请求参数的两个成员变量 private String username; private String password; //封装处理结果的tip成员变量 private String tip; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public String getTip() &#123; return tip; &#125; public void setTip(String tip) &#123; this.tip = tip; &#125; //Action包含的注册控制逻辑 public String regist() &#123; System.out.println(\"------regist------\"); ActionContext.getContext().getSession().put(\"user\", getUsername()); setTip(\"恭喜您,\"+getUsername()+\"，您已经注册成功\"); return Action.SUCCESS; &#125; //Action包含的登录业务逻辑 public String execute() &#123; System.out.println(\"------login------\"); if(getUsername().equals(\"crazyit.org\") &amp;&amp; getPassword().equals(\"leegang\")) &#123; ActionContext.getContext().getSession().put(\"user\", getUsername()); setTip(\"欢迎,\"+getUsername()+\"，您已经登录成功\"); return Action.SUCCESS; &#125; return Action.ERROR; &#125;&#125; 配置文件 1234567891011121314151617181920212223&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!-- 下面指定struts2配置文件的dtd信息 --&gt;&lt;!DOCTYPE struts PUBLIC \"-//Apache Software Foundation//DTD Struts Configuration 2.5//EN\" \"http://struts.apache.org/dtds/struts-2.5.dtd\"&gt;&lt;struts&gt; &lt;!-- 指定全局国际化资源文件 --&gt; &lt;constant name=\"struts.enable.DynamicMethodInvocation\" value=\"true\"/&gt; &lt;constant name=\"struts.custom.i18n.resources\" value=\"mess\"/&gt; &lt;constant name=\"struts.devMode\" value=\"true\"&gt;&lt;/constant&gt; &lt;package name=\"loginForm\" namespace=\"/\" extends=\"struts-default\" &gt; &lt;action name=\"*\"&gt; &lt;result&gt;/WEB-INF/content/&#123;1&#125;.jsp&lt;/result&gt; &lt;/action&gt; &lt;action name=\"login02\" class=\"org.crazyit.app.action.LoginRegisterAction\"&gt; &lt;!-- 处理结果返回为error,则对应于 /WEB-INF/content/error.jsp视图资源 --&gt; &lt;result name=\"error\"&gt; /WEB-INF/content/error.jsp&lt;/result&gt; &lt;!-- 处理结果返回为success,则对应于 /WEB-INF/content/welcome.jsp视图资源 --&gt; &lt;result name=\"success\"&gt; /WEB-INF/content/welcome.jsp&lt;/result&gt; &lt;allowed-methods&gt;regist&lt;/allowed-methods&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; 成功页面 12345678910111213141516&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@taglib prefix=\"s\" uri=\"/struts-tags\"%&gt;&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt; &lt;title&gt;&lt;s:text name=\"succPage\"/&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 本站访问的次数：$&#123;applicationScope.counter&#125;&lt;br&gt; --&gt; &lt;!-- $&#123;sessionScope.user&#125; --&gt;$&#123;user&#125;，您已登录成功！ $&#123;sessionScope.tip&#125;&lt;/body&gt;&lt;/html&gt; 结果 指定Method属性及其通配符 在配置&lt;action ../&gt;元素时，允许在指定name使用模式字符串，接下来在method，class，以及&lt;result../&gt;子元素中使用{N}的形式来表示前面第N个所匹配的字符串。 在Action的name属性中使用模式通配符后，可以用一个&lt;action../&gt;代替多个逻辑Action。 注意：因为除非请求的URL与action与name属性绝对相同，否则将按先后顺序来决定由哪个action来处理用户请求。因此应该讲name=&quot;*&quot;的Action配置放在最后，否则，Struts2将使用该Action来处理所有希望使用模式字符串匹配的请求。 配置默认的Action与配置默认的处理类 默认Action：&lt;default-action-ref name=&quot;ActionName&quot; /&gt; 默认处理类：&lt;default-class-ref name=&quot;className&quot; /&gt; 配置处理结果 理解处理结果 Action处理完用户的请求后，并未把请求直接转发给任何具体的视图资源，而是返回一个逻辑视图（逻辑视图就是一个简单的字符串），Struts2框架收到这个逻辑视图，，把请求转发到具体的物理视图资源，然后把处理结果展示给用户看。 配置结果 Struts2框架在struts.xml文件中使用&lt;result../&gt;元素来配置结果。 配置&lt;result ../&gt;元素时需要指定如下两个属性: name：该属性指定所配置的逻辑视图名。 type：该属性指定结果类型。 Struts2支持的结果类型 plainText结果类型：将实际的视图资源的源代码显示到客户端浏览器上。 案例: Action实现类 1234567891011121314151617package org.crazyit.app.action;import com.opensymphony.xwork2.ActionSupport;public class LoginAction extends ActionSupport&#123; private static final long serialVersionUID = 1L; //用于封装请求的username private String username; //username属性的getter和setter public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; &#125; struts.xml配置文件 123456789101112131415161718192021&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE struts PUBLIC \"-//Apache Software Foundation//DTD Struts Configuration 2.5//EN\" \"http://struts.apache.org/dtds/struts-2.5.dtd\"&gt;&lt;struts&gt; &lt;constant name=\"struts.devMode\" value=\"true\"&gt;&lt;/constant&gt; &lt;package name=\"loginForm\" namespace=\"/\" extends=\"struts-default\"&gt; &lt;action name=\"*\"&gt; &lt;result&gt;/WEB-INF/content/&#123;1&#125;.jsp&lt;/result&gt; &lt;/action&gt; &lt;action name=\"login\" class=\"org.crazyit.app.action.LoginAction\"&gt; &lt;!-- 指定Result的类型为PlainText --&gt; &lt;result type=\"plainText\"&gt; &lt;!-- 指定实际的视图资源 --&gt; &lt;param name=\"location\"&gt;/WEB-INF/content/welcome.jsp&lt;/param&gt; &lt;!-- 指定使用指定字符串来处理页面代码 --&gt; &lt;param name=\"charSet\"&gt;UTF-8&lt;/param&gt; &lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; 结果页面 12345678910111213&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib prefix=\"s\" uri=\"/struts-tags\" %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;欢迎页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;s:property value=\"username\"/&gt;&lt;/body&gt;&lt;/html&gt; 效果图： 使用plainText结果类型可以指定如下两个参数 location：指定实际的视图资源。 charSet：指定输出页面是所使用的的字符集。 redirect结果类型: 使用该属性之后，会丢失所有的请求参数，请求属性，当然也丢失了action的处理结果。 案例：将上面的配置文件修改一下 1234567891011121314&lt;struts&gt; &lt;constant name=\"struts.devMode\" value=\"true\"&gt;&lt;/constant&gt; &lt;package name=\"loginForm\" namespace=\"/\" extends=\"struts-default\"&gt; &lt;action name=\"*\"&gt; &lt;result&gt;/WEB-INF/content/&#123;1&#125;.jsp&lt;/result&gt; &lt;/action&gt; &lt;action name=\"login\" class=\"org.crazyit.app.action.LoginAction\"&gt; &lt;!-- 指定Result的类型为PlainText --&gt; &lt;result type=\"redirect\"&gt; /welcome.jsp &lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; 配置一个redirect结果类型时，可以为其指定如下两个参数 location：该Action指定Action处理完用户请求后跳转的地址。 parse：该参数指定是否允许location参数值中使用表达式,默认值为 true; redirectAction结果类型 redirectAction实现在一个Action处理结束时，直接将请求重定向到里一个Action。 配置redirectAction结果类型时，可以指定如下两个参数: actionName：该参数指定重定向的Action名。 namespache：该参数指定需要重定向的Action所在的命名空间。 redirect与redirectAction，这两种结果都会产生新的请求，区别在于前者重定向的是实际视频的资源，后者重向定的是另一个Action，两种结果类型都会丢失前一个Action的请求参数，请求属性以及处理的结果。 动态结果 动态结果的含义是指在指定实际视图资源使用了表达式语法。Action属性值决定物理视图资源 配置&lt;result ../&gt;元素时，不仅可以使用${N}表达式来指定实际视图资源，还可以使用${属性名}方法来指定物理视图资源。 案例 业务处理类：MyAction.java 1234567891011121314151617181920package org.crazyit.app.action;import com.opensymphony.xwork2.ActionSupport;public class MyAction extends ActionSupport&#123; private static final long serialVersionUID = 1L; private String target; public String getTarget() &#123; return target; &#125; public void setTarget(String target) &#123; this.target = target; &#125; public String execute() &#123; addActionMessage(\"恭喜您，您已经成功转向!\"); return SUCCESS; &#125;&#125; 配置文件 struts.xml 123456789101112131415161718&lt;struts&gt; &lt;constant name=\"struts.devMode\" value=\"true\"&gt;&lt;/constant&gt; &lt;constant name=\"struts.enable.DynamicMethodInvocation\" value=\"true\"/&gt; &lt;constant name=\"struts.custom.i18n.resources\" value=\"mess\"/&gt; &lt;package name=\"shop\" namespace=\"/\" extends=\"struts-default\" &gt; &lt;action name=\"*\"&gt; &lt;result&gt;/WEB-INF/content/&#123;1&#125;.jsp&lt;/result&gt; &lt;/action&gt; &lt;action name=\"myAction\" class=\"org.crazyit.app.action.MyAction\"&gt; &lt;!-- 配置结果集时，采用OGNL表达式来指定实际视图资源 --&gt; &lt;result&gt;/WEB-INF/content/$&#123;target&#125;.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; JSP页面 ok.jsp 12345678910111213141516&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt; &lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;转向页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=\"myAction\" method=\"post\"&gt; 转入的目标页面：&lt;input type=\"text\" name=\"target\"/&gt;&lt;br/&gt; &lt;input type=\"submit\" value=\"转入\"/&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 成功页面:welcome.jsp 12345678910111213&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib prefix=\"s\" uri=\"/struts-tags\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;成功页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;s:actionmessage/&gt;&lt;/body&gt;&lt;/html&gt; 全局结果 配置全局结果可以采用&lt;global-result ../&gt;标签完成。全局结果集多所有的Action有效。使用PreResultListener PreResultListener是一个监听器接口，它可以在Action完成处理控制后，系统转入实际的物理视图之间被回调。 添加PreResultListener监听器通过Invocation的addPreResultListener()方法完成。 案例，在之前的项目中添加如下代码即可：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package org.crazyit.app.action;import com.opensymphony.xwork2.Action;import com.opensymphony.xwork2.ActionContext;import com.opensymphony.xwork2.ActionInvocation;import com.opensymphony.xwork2.ActionSupport;import com.opensymphony.xwork2.interceptor.PreResultListener;public class LoginRegisterAction extends ActionSupport&#123; private static final long serialVersionUID = 1L; //封装用户请求参数的两个成员变量 private String username; private String password; //封装处理结果的tip成员变量 private String tip; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public String getTip() &#123; return tip; &#125; public void setTip(String tip) &#123; this.tip = tip; &#125; //Action包含的注册控制逻辑 public String regist() &#123; System.out.println(\"------regist------\"); ActionContext.getContext().getSession().put(\"user\", getUsername()); setTip(\"恭喜您,\"+getUsername()+\"，您已经注册成功\"); return Action.SUCCESS; &#125; //Action包含的登录业务逻辑 public String execute() &#123; System.out.println(\"------login------\"); //添加PreResultListener接口监听器 ActionInvocation invocation=ActionContext.getContext().getActionInvocation(); invocation.addPreResultListener(new PreResultListener() &#123; @Override public void beforeResult(ActionInvocation invocation, String resultCode) &#123; // TODO Auto-generated method stub System.out.println(\"返回的逻辑视图名字为：\"+resultCode); //在返回Result之前加入一个额外的数据 invocation.getInvocationContext().put(\"extra\", new java.util.Date()+\"由\"+resultCode+\"逻辑视图名转入\"); &#125; &#125;); if(getUsername().equals(\"crazyit.org\") &amp;&amp; getPassword().equals(\"leegang\")) &#123; ActionContext.getContext().getSession().put(\"user\", getUsername()); setTip(\"欢迎,\"+getUsername()+\"，您已经登录成功\"); return Action.SUCCESS; &#125; return Action.ERROR; &#125;&#125; 配置Struts2的异常处理Struts2的异常处理机制 为了使用Struts2的异常处理机制，必须打开Struts2的异常映射功能,开启异常映射功能需要一个拦截器。下面是struts-default.xml文件中开启异常映射功能的配置文件。12345678&lt;interceptors&gt; &lt;interceptor name=\"exception\" class=\"com.opensymphony.xwork2.interceptor.ExceptionMappingInterceptor\"&gt;&lt;/interceptor&gt; &lt;!--Struts2默认的拦截器栈--&gt; &lt;interceprot-stack name=\"defaultStack\"&gt; &lt;interceptor-ref name=\"exception\" /&gt; &lt;/interceptor-stack&gt;&lt;/interceptors&gt; 声明式异常捕获 Struts2的异常处理机制是通过在struts.xml文件中配置&lt;exception-mapping ../&gt;元素完成的。配置该文件时，需要指定如下两个属性： exception：此属性指定该异常映射所映射所设置的异常类型。 result：此属性指定Action出现异常时，系统返回result属性值对应的逻辑视图名。 根据&lt;exception-mapping&gt;出现位置的不同，异常映射又可以分为如下两种： 局部异常映射：将&lt;exception-mapping&gt;作为Action的子元素配置。 全局异常映射：将&lt;exception-mapping&gt;作为&lt;global-exception-mappings&gt;的子元素配置。 案例123456789101112131415package org.crazyit.app.exception;public class MyException extends Exception&#123; /** * */ private static final long serialVersionUID = 1L; public MyException() &#123; super(); &#125; public MyException(String msg) &#123; super(msg); &#125;&#125; 123456789101112131415161718192021222324252627package org.crazyit.app.exception;import com.opensymphony.xwork2.ActionSupport;public class LoginAction extends ActionSupport&#123; private static final long serialVersionUID = 1L; //封装请求参数的username和password private String username; private String password; private String tip; ... public String execute() throws Exception&#123; System.out.println(\"exception\"); if(getUsername().equalsIgnoreCase(\"user\")) &#123; throw new MyException(\"自定义异常\"); &#125; if(getUsername().equalsIgnoreCase(\"sql\")) &#123; throw new java.sql.SQLException(\"用户名不能为sql\"); &#125; if(getUsername().equals(\"crazyit.org\") &amp;&amp; getPassword().equals(\"leegang\")) &#123; return SUCCESS; &#125; return ERROR; &#125;&#125; 1234567891011121314151617181920212223242526272829 &lt;!-- 配置全局结果集 --&gt;&lt;global-results&gt; &lt;result name=\"sql\"&gt;/WEB-INF/content/exception.jsp&lt;/result&gt; &lt;result name=\"root\"&gt;/WEB-INF/content/exception.jsp&lt;/result&gt;&lt;/global-results&gt; &lt;!-- 配置全局异常映射 --&gt;&lt;global-exception-mappings&gt; &lt;exception-mapping result=\"sql\" exception=\"java.sql.SQLException\"&gt;&lt;/exception-mapping&gt; &lt;exception-mapping result=\"root\" exception=\"java.lang.Exception\"&gt;&lt;/exception-mapping&gt;&lt;/global-exception-mappings&gt;&lt;action name=\"*\"&gt; &lt;result&gt;/WEB-INF/content/&#123;1&#125;.jsp&lt;/result&gt;&lt;/action&gt;&lt;action name=\"login\" class=\"org.crazyit.app.action.LoginAction02\"&gt;&lt;!-- 处理结果返回为error,则对应于 /WEB-INF/content/error.jsp视图资源 --&gt; &lt;result name=\"error\"&gt; /WEB-INF/content/error.jsp&lt;/result&gt; &lt;!-- 处理结果返回为success,则对应于 /WEB-INF/content/welcome.jsp视图资源 --&gt; &lt;result name=\"success\"&gt; /WEB-INF/content/welcome.jsp&lt;/result&gt;&lt;/action&gt;&lt;action name=\"login02\" class=\"org.crazyit.app.exception.LoginAction\"&gt; &lt;!-- 定义局部异常映射 --&gt; &lt;exception-mapping result=\"my\" exception=\"org.crazyit.app.exception.MyException\"&gt;&lt;/exception-mapping&gt; &lt;result name=\"my\"&gt;/my.jsp&lt;/result&gt; &lt;!-- 处理结果返回为error,则对应于 /WEB-INF/content/error.jsp视图资源 --&gt; &lt;result name=\"error\"&gt; /WEB-INF/content/error.jsp&lt;/result&gt; &lt;!-- 处理结果返回为success,则对应于 /WEB-INF/content/welcome.jsp视图资源 --&gt; &lt;result name=\"success\"&gt; /WEB-INF/content/welcome.jsp&lt;/result&gt; &lt;allowed-methods&gt;regist&lt;/allowed-methods&gt; &lt;/action&gt; 输出异常信息 为了在异常页面中显示异常信息，可以使用Struts2的如下标签来输出异常信息 &lt;s:property value=&quot;exception&quot;/&gt;：输出异常对象本身。 &lt;s:property value=&quot;exceptionStack&quot;/&gt;：输出异常堆本身。 还可以使用&lt;s:property value=&quot;exception.message&quot;/&gt;来输出异常message信息。 Convention插件与约定支持Action的搜索和映射约定 convention会把如下两种Java类当成Action类。 所有实现了com.opensymphony.xwork2.Action的Java类 所有类名以Action结尾的Java类。 按约定映射ResultAction链的约定自动重加载映射 Convention完全支持自动重载映射，只要为Struts2配置如下两个常量即可 配置Struts2处于开发者模式：&lt;constant name=&quot;struts.devMode&quot; value=&quot;true&quot;&gt;&lt;/constant&gt; 配置Convention插件自动重加载映射：&lt;constant name=&quot;struts.convention.classes.reloaad&quot; value=&quot;true&quot;&gt;&lt;/constant&gt; Convention插件的相关常量Convention插件的相关注解 使用Struts2的国际化 Struts2的国际化可以按照如下步骤进行： 让系统加载国际化资源文件。加载国家化资源文件有两种方式: 自动加载：Action范围的国际化资源文件，包范围的国家化资源文件由系统自动加载。 手动加载：JSP范围的国际化资源文件、全局范围的国际化资源文件，分别使用标签、配置常量的方式来手动加载。 输出国际化。Struts2输出国家化的消息同样有两种方式： 在视图页面上输出国家化消息，需要使用Struts2的标签库。 在Action类中输出国际化消息，需要使用ActionSupport的getText()方法来完成。 视图页面的国际化 在Jsp页面中指定国际化资源需要借助Struts2的另外一个标签：&lt;s:i18n&gt; 案例实现: 定义两个国际化资源文件，其路径分别为：/JSPResources/src/viewResources/loginForm_en_US与/JSPResources/src/viewResources/loginForm_zh_CN.properties 两个包的内容分别为： 12345# loginForm_en_US.propertiesloginPage=JSP Message:Login Pageuser=JSP Message:User Namepass=JSP Message:User Passlogin=JSP Message:Login 12345# loginForm_zh_CN.propertiesloginPage=JSP Message:Login Pageuser=JSP Message:User Namepass=JSP Message:User Passlogin=JSP Message:Login 定义一个JSP页面，并在其中使用国际化资源文件，其路径为：/JSPResources/WebContent/WEB-INF/content/success.jsp 12345678910111213141516171819202122&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib prefix=\"s\" uri=\"/struts-tags\"%&gt;&lt;!DOCTYPE html&gt;&lt;!-- 加载baseName为viewResource包下的baseName为loginForm的国际化资源文件 --&gt;&lt;s:i18n name=\"viewResources.loginForm\"&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;!-- 使用text标签来输出国际化信息 --&gt; &lt;title&gt;&lt;s:text name=\"loginPage\"&gt;&lt;/s:text&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;s:form action=\"login\"&gt; &lt;!-- 在表单页面中，使用key属性来输出国际化信息 --&gt; &lt;s:textfield name=\"username\" key=\"user\" /&gt; &lt;s:textfield name=\"password\" key=\"pass\" /&gt; &lt;s:submit key=\"login\"/&gt; &lt;/s:form&gt; &lt;/body&gt;&lt;/html&gt;&lt;/s:i18n&gt; 定义配置文件struts.xml来访问页面 12345678910111213141516171819&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE struts PUBLIC \"-//Apache Software Foundation//DTD Struts Configuration 2.5//EN\" \"http://struts.apache.org/dtds/struts-2.5.dtd\"&gt;&lt;struts&gt; &lt;constant name=\"struts.devMode\" value=\"true\"&gt;&lt;/constant&gt; &lt;constant name=\"struts.enable.DynamicMethodInvocation\" value=\"true\"/&gt; &lt;package name=\"shop\" namespace=\"/\" extends=\"struts-default\" &gt; &lt;action name=\"*\"&gt; &lt;result&gt;/WEB-INF/content/&#123;1&#125;.jsp&lt;/result&gt; &lt;/action&gt; &lt;action name=\"login\"&gt; &lt;result&gt;/WEB-INF/content/success.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; 启动服务器，在页面查看效果. Action的国际化 为Action单独指定国际化资源文件的方法是：在Action类文件所在的路径下建立多个文件名为ActionName_language_country.properties. Struts2的国际资源文件是由系统自动加载。 使用包范围的国际化资源 包范围的国际化资源可以被该包下的所有Action使用。 包范围的国际化资源文件的文件名：package_&lt;language&gt;_&lt;country&gt;.properties使用全局国际化资源 不管是在struts.xml文件中配置常量，还是在struts.properties文件中配置常量，只需要配置struts.custom.i18n.resources常量即可加载全局国际化资源文件。输出带占位符的国际化消息 国际化消息可能包含占位符，这些占位符必须使用参数来填充。加载资源文件的顺序 使用Struts2的标签库Struts2标签库概述 Struts2的标签都定义在URI为/struts-tags的空间下。 从大范围上看，可以将Struts2标签分成如下两类： UI(User Interface，用户界面)标签：主要用于生成HTML元素的标签。 非UI标签：主要用于数据访问、逻辑控制等的标签。 对于UI标签，可以分为如下两类： 标签标签：主要用于生成HTML页面的form元素，以及普通表单元素的标签。 非表单标签：主要用于生成页面上的树、Tab页等标签。 对于非UI标签，也可以分为如下两类： 流程控制标签：主要包含用于生成分支、循环等流程控制的标签。 数据访问标签：主要包含用于输出ValueStack中的值，完成国际化等功能的标签。 使用Struts2标签 Struts2的标签库定义文件存放在struts2-core.2.5.20.jar包下的struts-tags.tld文件 在JSP页面中使用Struts2标签的步骤 在JSP页面中导入Struts2的标签库，例如：&lt;%@ taglib prefix=&quot;s&quot; uri=&quot;/struts-tags&quot; %&gt;；其中prefix指定标签的前缀，uri指定使用哪个核心标签库。 在JSP页面中使用相关标签：例如：&lt;s:text name=&quot;hello&quot;/&gt; 。 Struts2的OGNL表达式语言 OGNL(Object-Graph Navigation Language：图像导航语言) OGNL,如果需要访问的对象属于根对象，则可以直接访问该属性，如果不是则需要使用一个前缀# 开发中，可以在页面中添加&lt;s:debug/&gt;标签，来查看属性是为value stack还是stack contextOGNL中的集合操作 很多时候，可能需要一个集合对象（例如List对象，或者Map对象），使用OGNL表达式可以直接创建集合对象。 直接创建List集合的语法：{e1,e2,e3} 直接创建Map集合的语法：#{key1:value1,key2:value2} 对于集合，OGNL提供了两个运算符：in和not in 除此之外，OGNL还允许通过某个规则取得集合的子集。取得集合的子集时有如下三个操作： ?: 取出所有符合选择逻辑的元素。 ^: 取出符合选择逻辑的第一个元素。 $: 取出符合选择逻辑的最后一个元素。 访问静态成员1&lt;constant name=\"struts.ognl.allowStaticMethodAccess\" value=\"true\"&gt;&lt;/constant&gt; 1234访问静态方法：&lt;s:property value=\"@org.crazyit.struts2.action.DemoAction@s()\"/&gt;&lt;br&gt;访问静态属性：&lt;s:property value=\"@org.crazyit.struts2.action.DemoAction@str\"/&gt;&lt;br&gt;生成一个伪随机数:&lt;s:property value=\"@java.lang.Math@random()\"/&gt;&lt;br&gt;圆周率的值:&lt;s:property value=\"@java.lang.Math@PI\"/&gt; Lambda表达式 Lambda表达式支持:&lt;s:property value=&quot;#fib =: [#this == 0?0:#this==1?1:#fib(#this-2)+#fib(#this-1)],#fib(11)&quot;/&gt;控制标签 控制标签有9个 if：用于控制选择输出的标签。 elseIf/elseif：与if标签结合使用，用于控制选择输出的标签。 else：与if标签结合使用，用于控制选择输出的标签。 append：用于将多个集合拼接成一个新的集合。 generator：它是一个字符串解析器，用于讲一个字符串解析成一个集合。 iterator：这是一个迭代器，用于将集合迭代输出。 merge：用于将多个集合合拼成一个新的集合。但与append的拼接方法有所不同。 sort：这个标签用于对集合进行排序。 subset：这个标签用于截取集合的部分元素，形成新的子集合。 if/elseif/else标签 三个标签结合的语法格式如下： 12345678910&lt;s:if test=\"表达式\"&gt; 标签体&lt;/s:if&gt;&lt;s:elseif test=\"表达式\"&gt; 标签体&lt;/s:elseif&gt;...&lt;s:else&gt; 标签体&lt;/s:else&gt; 案列实现: 1234567891011121314151617181920212223242526272829&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib prefix=\"s\" uri=\"/struts-tags\" %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;分支控制&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 向Stack Context中定义一个属性age,并取值为 29 --&gt; &lt;s:set var=\"age\" value=\"29\"&gt;&lt;/s:set&gt; &lt;!-- 如果Stack Context中的age属性大于60 --&gt; &lt;s:if test=\"#age&gt;60\"&gt; 老年人 &lt;/s:if&gt; &lt;!-- 如果Stack Context中的age属性大于35 --&gt; &lt;s:elseif test=\"#age&gt;35\"&gt; 中年人 &lt;/s:elseif&gt; &lt;!-- 如果Stack Context中的age属性大于15 --&gt; &lt;s:elseif test=\"#age&gt;15\"&gt; 青年人 &lt;/s:elseif&gt; &lt;s:else&gt; 少年人 &lt;/s:else&gt;&lt;/body&gt;&lt;/html&gt; iterator标签 主要用于对集合进行迭代。 案例实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib prefix=\"s\" uri=\"/struts-tags\" %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;iterator标签&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;table border=\"1\" width=\"300\"&gt; &lt;s:iterator value=\"&#123;'疯狂java讲义','轻量级Java EE企业应用实战','疯狂IOS讲义'&#125;\" var=\"name\"&gt; &lt;tr&gt; &lt;th&gt;&lt;s:property value=\"#st.count\"/&gt;&lt;s:property value=\"name\"/&gt;&lt;/th&gt; &lt;/tr&gt; &lt;/s:iterator&gt; &lt;/table&gt; &lt;!-- 迭代输出list集合 --&gt; &lt;table border=\"1\" width=\"300\"&gt; &lt;s:iterator value=\"&#123;'疯狂java讲义','轻量级Java EE企业应用实战','疯狂IOS讲义'&#125;\" var=\"name\" status=\"st\"&gt; &lt;tr &lt;s:if test=\"#st.odd\"&gt;style=\"background-color:#bbbbbb\" &lt;/s:if&gt;&gt; &lt;td&gt; &lt;s:property value=\"name\"/&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/s:iterator&gt; &lt;/table&gt; &lt;!-- 对Map集合进行迭代 --&gt; &lt;table border=\"1\" width=\"300\"&gt; &lt;tr&gt; &lt;th&gt;书名&lt;/th&gt; &lt;th&gt;作者&lt;/th&gt; &lt;/tr&gt; &lt;s:iterator value=\"#&#123;'疯狂java讲义':'李刚','轻量级Java EE企业应用实战':'李刚','疯狂IOS讲义':'李刚'&#125;\" var=\"name\" status=\"st\"&gt; &lt;!--根据当前迭代的元素的索引是否为奇数来决定是否使用背景颜色 --&gt; &lt;tr &lt;s:if test=\"#st.odd\"&gt;style=\"background-color:#bbbbbb\" &lt;/s:if&gt;&gt; &lt;td&gt; &lt;!-- 数据Map对象里Entry的key --&gt; &lt;s:property value=\"key\"/&gt; &lt;/td&gt; &lt;td&gt; &lt;!-- 数据Map对象里Entry的value --&gt; &lt;s:property value=\"value\"/&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/s:iterator&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt; append标签 append：用于将多个集合拼接成一个新的集合。 案例实现 1234567891011121314151617181920212223242526272829303132333435363738&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib prefix=\"s\" uri=\"/struts-tags\" %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;append标签&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 使用append标签将两个集合拼接成新的集合，新集合的名字是newList，新集合放入到Stack Context --&gt; &lt;s:append var=\"newList\"&gt; &lt;s:param value=\"&#123;'疯狂java讲义','轻量级Java EE企业应用实战','疯狂IOS讲义'&#125;\"&gt;&lt;/s:param&gt; &lt;s:param value=\"&#123;'http://www.baidu.com','cpws.github.io','qqqqyy.github.io'&#125;\"&gt;&lt;/s:param&gt; &lt;/s:append&gt; &lt;table border=\"1\" width=\"400\"&gt; &lt;s:iterator value=\"#newList\" var=\"name\" status=\"index\"&gt; &lt;tr &lt;s:if test=\"#index.even\"&gt;style=\"background-color:#4dffff\"&lt;/s:if&gt;&gt; &lt;td&gt;&lt;s:property value=\"name\"/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/s:iterator&gt; &lt;/table&gt; &lt;!-- 使用append标签将List集合和Map结合拼接成新的集合，新集合的名字是newList，新集合放入到Stack Context --&gt; &lt;s:append var=\"dd\"&gt; &lt;s:param value=\"#&#123;'疯狂java讲义':'李刚','轻量级Java EE企业应用实战':'李刚','疯狂IOS讲义':'李刚'&#125;\"&gt;&lt;/s:param&gt; &lt;s:param value=\"#&#123;'http://www.baidu.com','cpws.github.io','qqqqyy.github.io'&#125;\"&gt;&lt;/s:param&gt; &lt;/s:append&gt; &lt;!-- 使用迭代器进行迭代 --&gt; &lt;table border=\"1\" width=\"400\"&gt; &lt;s:iterator value=\"#dd\" var=\"name\" status=\"st\"&gt; &lt;tr &lt;s:if test=\"#st.even\"&gt;style=\"background-color:#4dffff\"&lt;/s:if&gt;&gt; &lt;td&gt;&lt;s:property value=\"key\"/&gt;&lt;/td&gt; &lt;td&gt;&lt;s:property value=\"value\"/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/s:iterator&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt; generator标签 generator：它是一个字符串解析器，用于讲一个字符串解析成一个集合. 案例实现： 1234567891011121314151617181920212223242526272829303132333435363738&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib prefix=\"s\" uri=\"/struts-tags\" %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;generator标签&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;table border=\"1\" width=\"300\"&gt; &lt;!-- 使用generator标签将指定字符串解析成iterator集合 --&gt; &lt;!-- 在generator标签内，得到的List集合位于valuestack顶端 --&gt; &lt;s:generator separator=\",\" val=\" '疯狂Java讲义,疯狂Java EE企业应用实战,疯狂IOS讲义' \"&gt; &lt;!-- 没有指定迭代哪个集合，直接迭代栈顶的集合 --&gt; &lt;s:iterator status=\"st\"&gt; &lt;tr &lt;s:if test=\"#st.odd\"&gt;style=\"background-color:#bbbbbb\" &lt;/s:if&gt;&gt; &lt;td&gt;&lt;s:property/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/s:iterator&gt; &lt;/s:generator&gt; &lt;/table&gt; &lt;table border=\"1\" width=\"300\"&gt; &lt;!-- 使用generator标签将指定字符串解析成iterator集合 指定了count和var --&gt; &lt;!-- 在generator标签内，得到的List集合位于valuestack顶端 --&gt; &lt;s:generator separator=\",\" val=\" '疯狂Java讲义,疯狂Java EE企业应用实战,疯狂IOS讲义' \" count=\"2\" var=\"books\"&gt; &lt;!-- 没有指定迭代哪个集合，直接迭代栈顶的集合 --&gt; &lt;!-- 并且把值存入到 stack context中的books集合 --&gt; &lt;s:iterator status=\"st\"&gt; &lt;tr &lt;s:if test=\"#st.odd\"&gt;style=\"background-color:#bbbbbb\" &lt;/s:if&gt;&gt; &lt;td&gt;&lt;s:property/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/s:iterator&gt; &lt;/s:generator&gt; &lt;/table&gt; $&#123;requestScope.books&#125;&lt;/body&gt;&lt;/html&gt; 注意：如果在标签定义了var属性，则该集合将会被存入到Stack Context中，在该标签外部可以访问该标签，否则，该集合会创建一个临时文件存放在Value Stack，可以直接被访问，但是只能在标签中被使用。 merge标签 merge：用于将多个集合合拼成一个新的集合。但与append的拼接方法有所不同。 案例实现: 123456789101112131415161718192021222324&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib prefix=\"s\" uri=\"/struts-tags\" %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;merge标签&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;s:merge var=\"newList\"&gt; &lt;s:param value=\"&#123;'疯狂Java讲义','轻量级Java EE企业应用实战','疯狂IOS讲义'&#125;\"&gt;&lt;/s:param&gt; &lt;s:param value=\"&#123;'hhtp://www.baidu.com','cpws.github.io'&#125;\"&gt;&lt;/s:param&gt; &lt;/s:merge&gt; &lt;table border=\"1\" width=\"400\"&gt; &lt;s:iterator value=\"newList\" status=\"st\"&gt; &lt;tr &lt;s:if test=\"#st.odd\"&gt;style=\"background-color:#bbbbbb\"&lt;/s:if&gt;&gt; &lt;td&gt;&lt;s:property/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/s:iterator&gt; &lt;/table&gt; &lt;/body&gt;&lt;/html&gt; merge标签的效果与append标签一样，只是拼接成新的集合后，两者新集合中的元素顺序不一样而已。 subset标签：这个标签用于截取集合的部分元素，形成新的子集合。 案例实现 12345678910111213141516171819package org.crazyit.app.util;import org.apache.struts2.util.SubsetIteratorFilter;/*** * 用户自定义Decider类，实现了SubsetIteratorFilter.Decider接口 * @author 1huangzewei * */public class MyDecider implements SubsetIteratorFilter.Decider&#123; //实现Decider接口必须实现decide()方法 //该方法决定集合中的元素是否被选入自己 @Override public boolean decide(Object element) throws Exception &#123; String str=(String) element; //如果集合元素中包含JavaEE子串，即可被选入子集 return str.indexOf(\"Java EE\") &gt; 0; &#125;&#125; 12345678910111213141516171819202122232425262728&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib prefix=\"s\" uri=\"/struts-tags\" %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;subset标签&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 定义一个Decider Bean --&gt; &lt;s:bean name=\"org.crazyit.app.util.MyDecider\" var=\"mydecider\"&gt;&lt;/s:bean&gt; &lt;!-- 使用自定义的decider实例来截取目标集合，生成子集 --&gt; &lt;!-- 指定var属性，将生成的集合放入到page范围中 --&gt; &lt;s:subset source=\"&#123;'疯狂Java讲义','轻量级Java EE企业应用实战','经典Java EE企业应用实战','疯狂前端开发讲义','疯狂IOS讲义'&#125;\" decider=\"#mydecider\" var=\"newList\"/&gt; &lt;!--直接输出 page范围的newList属性 --&gt; 直接输出 page范围的newList属性:&lt;br&gt;$&#123;pageScope.newList&#125; &lt;table border=\"1\" width=\"400\"&gt; &lt;!-- 使用迭代器来迭代目标集合，因为没有指定value属性值，所有迭代ValueStack栈顶的值 --&gt; &lt;s:iterator value=\"#attr.newList\" status=\"st\"&gt; &lt;tr &lt;s:if test=\"#st.odd\"&gt;style=\"background-color:#bbbbbb\"&lt;/s:if&gt;&gt; &lt;td&gt;&lt;s:property/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/s:iterator&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt; sort标签 用于对指定集合元素进行排序 案例实现 12345678910111213141516package org.crazyit.app.util;import java.util.Comparator;public class MyComparator implements Comparator&#123; /*** * 决定两个元素大小的方法 */ @Override public int compare(Object o1, Object o2) &#123; //根据元素字符串长度来决定大小 return o1.toString().length() - o2.toString().length(); &#125;&#125; 123456789101112131415161718192021222324252627&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib prefix=\"s\" uri=\"/struts-tags\" %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;sort标签&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 定义一个Comparator实例 --&gt; &lt;s:bean name=\"org.crazyit.app.util.MyComparator\" var=\"myComparator\"/&gt; &lt;!-- 使用自定义的排序规则进行排序 --&gt; &lt;s:sort comparator=\"#myComparator\" source=\"&#123;'疯狂Java讲义','轻量级Java EE企业应用实战','经典Java EE企业应用实战','疯狂前端开发讲义','疯狂IOS讲义'&#125;\" var=\"sortedList\"/&gt; 输出page范围的sortedList属性：&lt;br&gt;$&#123;pageScope.sortedList&#125; &lt;table border=\"1\" width=\"400\"&gt; &lt;!-- 使用迭代器来迭代目标集合，因为没有指定value属性值，所有迭代ValueStack栈顶的值 --&gt; &lt;s:iterator value=\"#attr.sortedList\" status=\"st\"&gt; &lt;tr &lt;s:if test=\"#st.odd\"&gt;style=\"background-color:#bbbbbb\"&lt;/s:if&gt;&gt; &lt;td&gt;&lt;s:property/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/s:iterator&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 数据标签 数据标签主要用于提供各种数据访问的功能，包含显示一个Action里的属性，以及生成国际化输出等功能。数据标签主要包含如下几个： action：该标签用于在JSP页面直接调用一个action，通过指定executeResult参数，还可将该action的处理结果包含到本页面中来。 bean：该标签用于创建一个JavaBean实例。如果指定了var属性，则可以将创建的实例放入到Stack Context中. date：用于格式化输出一个日期。 debug：用于在页面上生成一个调试链接，当点击该链接时，可以看到Stack Context和ValueStack中的内容。 i18n：用于指定国际化资源文件的baseName。 include：用于在JSP页面中包含其他的JSP或Servlet资源。 param：用于设置一个参数，通常是用作bean标签、URL标签的字标签。 push：用于将某个值放入到ValueStack的栈顶。 set：用于设置一个新变量，并可以将新变量放入到指定的范围内。 text：用于输出国际化信息。 url：用于生成一个URL地址。 property：用于输出某个值，包括输出valueStack,Stack Context和Action Context中的值。 action标签：该标签用于在JSP页面直接调用一个action 案例实现 123456789101112131415161718192021&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib prefix=\"s\" uri=\"/struts-tags\" %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;action标签&lt;/title&gt;&lt;/head&gt;&lt;body&gt; 下面调用第一个Action，并将结果包含到本页面&lt;br&gt; &lt;s:action name=\"tag1\" executeResult=\"true\"/&gt;&lt;hr&gt; 下面调用第二个Action，并将结果包含到本页面&lt;br&gt; 但阻止本页面请求参数传入Action。&lt;br&gt; &lt;s:action name=\"tag2\" executeResult=\"true\" ignoreContextParams=\"true\"/&gt;&lt;hr&gt; 下面调用第三个Action，并不将结果包含到本页面&lt;br&gt; &lt;s:action name=\"tag2\" executeResult=\"true\" ignoreContextParams=\"false\"/&gt; 本页面是否可访问：&lt;s:property value=\"author\"/&gt; &lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920212223242526package org.crazyit.app.action;import com.opensymphony.xwork2.ActionContext;import com.opensymphony.xwork2.ActionSupport;public class TagAction extends ActionSupport &#123; private static final long serialVersionUID = 1L; //封装用户请求参数的author成员变量 private String author; public String getAuthor() &#123; return author; &#125; public void setAuthor(String author) &#123; this.author = author; &#125; //定义第一个处理逻辑 public String execute() throws Exception&#123; return \"done\"; &#125; //定义第二个处理逻辑 public String login() throws Exception&#123; ActionContext.getContext().put(\"author\", getAuthor()); return \"done\"; &#125;&#125; 12345678910111213141516171819202122&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE struts PUBLIC \"-//Apache Software Foundation//DTD Struts Configuration 2.5//EN\" \"http://struts.apache.org/dtds/struts-2.5.dtd\"&gt;&lt;struts&gt; &lt;constant name=\"struts.devMode\" value=\"true\"&gt;&lt;/constant&gt; &lt;constant name=\"struts.enable.DynamicMethodInvocation\" value=\"true\"/&gt; &lt;package name=\"default\" namespace=\"/\" extends=\"struts-default\" &gt; &lt;!-- 定义第一个Action，使用TagAction的execute方法作为控制处理逻辑 --&gt; &lt;action name=\"tag1\" class=\"org.crazyit.app.action.TagAction\"&gt; &lt;result name=\"done\"&gt;/WEB-INF/content/succ.jsp&lt;/result&gt; &lt;/action&gt; &lt;!-- 定义第二个Action，使用TagAction的login方法作为控制处理逻辑 --&gt; &lt;action name=\"tag2\" class=\"org.crazyit.app.action.TagAction\" method=\"login\"&gt; &lt;result name=\"done\"&gt;/WEB-INF/content/loginSucc.jsp&lt;/result&gt; &lt;/action&gt; &lt;action name=\"*\"&gt; &lt;result&gt;/WEB-INF/content/&#123;1&#125;.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; bean：该标签用于创建一个JavaBean实例 案例实现 1234567891011121314151617181920212223242526272829303132333435&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib prefix=\"s\" uri=\"/struts-tags\" %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;bean标签&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 使用bean标签创建一个Person实例 --&gt; &lt;s:bean name=\"org.crazyit.app.dto.Person\" &gt; &lt;!-- 使用param标签为Person类的实例传入参数 --&gt; &lt;s:param name=\"name\" value=\"'yeeku'\"/&gt; &lt;s:param name=\"age\" value=\"23\"/&gt; &lt;s:param name=\"aaa\" value=\"10\"/&gt; &lt;!-- 因为在bean标签体内，Person实例位于ValueStack栈顶，故可以直接访问Person实例 --&gt; &lt;!-- Person实例的name为：&lt;s:property value=\"name\"/&gt;&lt;br/&gt; Person实例的age为：&lt;s:property value=\"age\"/&gt;&lt;br/&gt; Person实例的aaa为：&lt;s:property value=\"aaa\"/&gt;&lt;br/&gt; --&gt; &lt;/s:bean&gt; &lt;s:bean name=\"org.crazyit.app.dto.Person\" var=\"p\"&gt; &lt;s:param name=\"name\" value=\"'yeeku'\"/&gt; &lt;s:param name=\"age\" value=\"23\"/&gt; &lt;s:param name=\"aaa\" value=\"10\"/&gt; &lt;/s:bean&gt; &lt;!-- 根据JavaBean实例的var属性来获取JavaBean实例 --&gt; Person实例的name为：&lt;s:property value=\"#p.name\"/&gt;&lt;br/&gt; Person实例的age为：&lt;s:property value=\"#p.age\"/&gt;&lt;br/&gt; Person实例的aaa为：&lt;s:property value=\"#p.aaa\"/&gt;&lt;br/&gt; $&#123;requestScope.p&#125;&lt;/body&gt;&lt;/html&gt; 123456789101112131415package org.crazyit.app.dto;public class Person &#123; private String name; private int age; private int aaa; public Person() &#123;&#125; public Person(String name, int age, int aaa) &#123; super(); this.name = name; this.age = age; this.aaa = aaa; &#125; //省略getter和setter方法&#125; date：用于格式化输出一个日期 案例实现： 123456789101112131415161718192021222324&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib prefix=\"s\" uri=\"/struts-tags\" %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;s:bean var=\"now\" name=\"java.util.Date\"/&gt; nice=false，且指定format=\"dd/MM/YYYY\"&lt;br/&gt; &lt;s:date name=\"#now\" format=\"dd/MM/YYYY\" nice=\"false\"/&gt;&lt;hr/&gt; nice=true，且指定format=\"dd/MM/YYYY\"&lt;br/&gt; &lt;s:date name=\"#now\" format=\"dd/MM/YYYY\" nice=\"true\"/&gt;&lt;hr/&gt; 指定nice=\"true\"&lt;br/&gt; &lt;s:date name=\"#now\" nice=\"true\"/&gt;&lt;hr/&gt; 指定nice=\"false\"，且没有指定formate属性&lt;br/&gt; &lt;s:date name=\"#now\" nice=\"false\"/&gt;&lt;hr/&gt; 指定nice=\"false\"，且没有指定formate属性，但指定var属性&lt;br/&gt; &lt;s:date name=\"#now\" nice=\"false\" var=\"abc\"/&gt;&lt;hr/&gt; $&#123;requestScope.abc&#125; &lt;s:property value=\"#abc\"/&gt;&lt;/body&gt;&lt;/html&gt; debug：用于在页面上生成一个调试链接. 案例实现： 1&lt;s:debug/&gt; include：用于在JSP页面中包含其他的JSP或Servlet资源。 案例实现： 1234567891011121314151617181920&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib prefix=\"s\" uri=\"/struts-tags\" %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;include标签&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;使用s:include标签来包含目标页面&lt;/h2&gt;&lt;!-- 使用include标签来包含其他页面 --&gt;&lt;s:include value=\"include-file.jsp\"/&gt;&lt;!-- 使用include标签来包含其他页面，并且传入参数 --&gt;&lt;s:include value=\"include-file.jsp\"&gt; &lt;s:param name=\"author\" value=\"'yeeku'\"/&gt;&lt;/s:include&gt; &lt;/body&gt;&lt;/html&gt; 12345678910111213&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h3&gt;被包含的页面&lt;/h3&gt; author的参数值：$&#123;param.author&#125;&lt;/body&gt;&lt;/html&gt; param标签：主要用于为其他标签提供参数。 push标签：push标签用于将某个值放到ValueStack的栈顶。 案例实现: 12345678910111213141516171819202122232425&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib prefix=\"s\" uri=\"/struts-tags\" %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;使用s:push标签将某个值放入到Value Stack&lt;/h2&gt; &lt;!-- 使用bean标签来创建一个JavaBean实例，指定var属性，并且将其值放到var属性中 --&gt; &lt;s:bean name=\"org.crazyit.app.dto.Person\" var=\"p\"&gt; &lt;s:param name=\"name\" value=\"'ok'\"&gt;&lt;/s:param&gt; &lt;s:param name=\"age\" value=\"18\"&gt;&lt;/s:param&gt; &lt;s:param name=\"aaa\" value=\"12\"&gt;&lt;/s:param&gt; &lt;/s:bean&gt; &lt;!-- 将Stack Context中的p对象放入到ValueStack --&gt; &lt;s:push value=\"#p\"&gt; ValueStack栈顶对象的name属性：&lt;s:property value=\"name\"/&gt;&lt;br/&gt; ValueStack栈顶对象的age属性：&lt;s:property value=\"age\"/&gt;&lt;br/&gt; ValueStack栈顶对象的aaa属性：&lt;s:property value=\"aaa\"/&gt;&lt;br/&gt; &lt;/s:push&gt;&lt;/body&gt;&lt;/html&gt; set标签：用于将某个值放入到指定的范围中。 案例实现 12345678910111213141516171819202122232425262728293031323334353637&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib prefix=\"s\" uri=\"/struts-tags\" %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;set标签&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;使用s:set设置一个新变量&lt;/h2&gt; &lt;!-- 使用s:bean标签定义一个JavaBean实例 --&gt; &lt;s:bean name=\"org.crazyit.app.dto.Person\" var=\"p\"&gt; &lt;s:param name=\"name\" value=\"'ok'\"&gt;&lt;/s:param&gt; &lt;s:param name=\"age\" value=\"18\"&gt;&lt;/s:param&gt; &lt;s:param name=\"aaa\" value=\"12\"&gt;&lt;/s:param&gt; &lt;/s:bean&gt; 将Stack Context中的p值放入到默认范围（action）内。&lt;br/&gt; &lt;s:set value=\"#p\" var=\"xxx\" /&gt; Stack Context内xxx对象的name属性：&lt;s:property value=\"#xxx.name\"/&gt;&lt;br/&gt; Stack Context内xxx对象的age属性：&lt;s:property value=\"#xxx.age\"/&gt;&lt;br/&gt; Stack Context内xxx对象的aaa属性：&lt;s:property value=\"#xxx.aaa\"/&gt;&lt;br/&gt; request范围的xxx对象的name属性：$&#123;requestScope.xxx.name&#125;&lt;br/&gt; request范围的xxx对象的age属性：$&#123;requestScope.xxx.age&#125;&lt;br/&gt; request范围的xxx对象的aaa属性：$&#123;requestScope.xxx.aaa&#125;&lt;hr/&gt; 将Stack Context中的p值放入application范围内。&lt;br/&gt; &lt;s:set value=\"#p\" var=\"yyy\" scope=\"application\"/&gt; application范围的yyy对象的name属性：$&#123;applicationScope.yyy.name&#125;&lt;br/&gt; application范围的yyy对象的age属性：$&#123;applicationScope.yyy.age&#125;&lt;br/&gt; application范围的yyy对象的aaa属性：$&#123;applicationScope.yyy.aaa&#125;&lt;hr/&gt; 将Stack Context中的p值放入session范围内。&lt;br/&gt; &lt;s:set value=\"#p\" var=\"zzz\" scope=\"session\"/&gt; session范围的zzz对象的name属性：$&#123;sessionScope.zzz.name&#125;&lt;br/&gt; session范围的zzz对象的age属性：$&#123;sessionScope.zzz.age&#125;&lt;br/&gt; session范围的zzz对象的aaa属性：$&#123;sessionScope.zzz.aaa&#125;&lt;hr/&gt;&lt;/body&gt;&lt;/html&gt; url标签：用于生成一个url地址。\\ 案例实现： 12345678910111213141516171819&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib prefix=\"s\" uri=\"/struts-tags\" %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;url标签&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;s：url来生成一个URL地址&lt;/h2&gt; 只指定value属性的形式&lt;br/&gt; &lt;s:url value=\"editGadget.action\"/&gt;&lt;hr/&gt; 指定action属性，且使用param传入参数的形式&lt;br/&gt; &lt;s:url action=\"showBooks\"&gt; &lt;s:param name=\"author\" value=\"'yeeku'\"/&gt; &lt;/s:url&gt;&lt;hr/&gt;&lt;/body&gt;&lt;/html&gt; property标签：输出指定值。 主题和模板自定义主题表单标签 所有表单标签处理类都继承了UIBean类，UIBean包含了一些通用属性，这些通用属性分成三种： 模板相关属性。 JavaScript相关属性。 通用属性。 表单标签的name和value属性。 checkboxlist标签:可以一次创建多个复选框。 案例实现： 1234567891011121314151617181920212223242526272829&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib prefix=\"s\" uri=\"/struts-tags\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;checkboxlist标签&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;s:form&gt; &lt;!-- 使用简单的集合来生成多个复选框 --&gt; &lt;s:checkboxlist name=\"a\" label=\"请选择您喜欢的图书\" labelposition=\"top\" list=\"&#123;'疯狂java讲义','轻量级Java EE企业应用实战','疯狂IOS讲义'&#125;\"&gt;&lt;/s:checkboxlist&gt; &lt;!-- 使用简单Map来生成多个复选框 使用Map的key值作为复选框的value 使用Map的value值作为复选框的标签 --&gt; &lt;s:checkboxlist name=\"b\" label=\"请选择您想出版的日期：\" labelposition=\"top\" list=\"#&#123;'疯狂java讲义':'2008年9月','轻量级Java EE企业应用实战':'2008年12月','疯狂IOS讲义':'2014年1月'&#125;\" listKey=\"key\" listValueKey=\"value\"&gt;&lt;/s:checkboxlist&gt; &lt;!-- 创建一个JavaBean对象，并将其放入Stack Context中--&gt; &lt;s:bean name=\"org.crazyit.app.service.BookService\" var=\"bs\"&gt;&lt;/s:bean&gt; &lt;!-- 使用集合里放多个JavaBean实例来生成多个复选框 集合name作为标签，集合author作为复选框value --&gt; &lt;s:checkboxlist name=\"c\" label=\"请选择您喜欢的图书：\" labelposition=\"top\" list=\"#bs.books\" listKey=\"author\" listValue=\"name\"&gt;&lt;/s:checkboxlist&gt; &lt;/s:form&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314package org.crazyit.app.service;import org.crazyit.app.dto.Book;public class BookService &#123; public Book[] getBooks() &#123; return new Book[] &#123; new Book(\"疯狂Java讲义\",\"李刚\"), new Book(\"疯狂Java EE企业应用实战\",\"李刚\"), new Book(\"疯狂ios讲义\",\"李刚\"), new Book(\"疯狂前端开发讲义\",\"李刚\") &#125;; &#125;&#125; 123456789101112131415161718192021222324252627package org.crazyit.app.dto;public class Book &#123; private String name; private String author; public Book() &#123; // TODO Auto-generated constructor stub &#125; public Book(String name, String author) &#123; super(); this.name = name; this.author = author; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getAuthor() &#123; return author; &#125; public void setAuthor(String author) &#123; this.author = author; &#125; &#125; radio标签：与checkboxlist的用法和属性完全一样，只是该标签生成的是单选按钮。 案例实现 1234567891011121314151617181920212223242526272829&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib prefix=\"s\" uri=\"/struts-tags\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;radio标签&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;s:form&gt; &lt;!-- 使用简单的集合来生成单选按钮--&gt; &lt;s:radio name=\"a\" label=\"请选择您喜欢的图书\" labelposition=\"top\" list=\"&#123;'疯狂java讲义','轻量级Java EE企业应用实战','疯狂IOS讲义'&#125;\"&gt;&lt;/s:radio&gt; &lt;!-- 使用简单Map来生成多个单选按钮 使用Map的key值作为单选按钮的value 使用Map的value值作为单选按钮的标签 --&gt; &lt;s:radio name=\"b\" label=\"请选择您想出版的日期：\" labelposition=\"top\" list=\"#&#123;'疯狂java讲义':'2008年9月','轻量级Java EE企业应用实战':'2008年12月','疯狂IOS讲义':'2014年1月'&#125;\" listKey=\"key\" listValueKey=\"value\"&gt;&lt;/s:radio&gt; &lt;!-- 创建一个JavaBean对象，并将其放入Stack Context中--&gt; &lt;s:bean name=\"org.crazyit.app.service.BookService\" var=\"bs\"&gt;&lt;/s:bean&gt; &lt;!-- 使用集合里放多个JavaBean实例来生成多个单选按钮 集合name作为标签，集合author作为单选按钮value --&gt; &lt;s:radio name=\"c\" label=\"请选择您喜欢的图书：\" labelposition=\"top\" list=\"#bs.books\" listKey=\"author\" listValue=\"name\"&gt;&lt;/s:radio&gt; &lt;/s:form&gt;&lt;/body&gt;&lt;/html&gt; select标签：用于生成一个下拉列表框。 案例实现 123456789101112131415161718192021222324252627&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib prefix=\"s\" uri=\"/struts-tags\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;select标签&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;s:form&gt; &lt;!-- 使用简单的集合来生成下拉选择框 --&gt; &lt;s:select name=\"a\" label=\"请选择您喜欢的图书\" labelposition=\"top\" multiple=\"true\" list=\"&#123;'疯狂java讲义','轻量级Java EE企业应用实战','JavaScript:The Definitive Guide'&#125;\"&gt;&lt;/s:select&gt; &lt;!-- 使用简单Map来生成下拉选择框 --&gt; &lt;s:select name=\"b\" label=\"请选择您想出版的日期：\" labelposition=\"top\" list=\"#&#123;'疯狂java讲义':'2008年9月','轻量级Java EE企业应用实战':'2008年12月','疯狂IOS讲义':'2014年1月'&#125;\" listKey=\"key\" listValueKey=\"value\"&gt;&lt;/s:select&gt; &lt;!-- 创建一个JavaBean对象，并将其放入Stack Context中--&gt; &lt;s:bean name=\"org.crazyit.app.service.BookService\" var=\"bs\"&gt;&lt;/s:bean&gt; &lt;!-- 使用集合里放多个JavaBean实例来生成下拉选择框 --&gt; &lt;s:select name=\"c\" label=\"请选择您喜欢的图书：\" labelposition=\"top\" multiple=\"true\" list=\"#bs.books\" listKey=\"author\" listValue=\"name\"&gt;&lt;/s:select&gt; &lt;/s:form&gt;&lt;/body&gt;&lt;/html&gt; optgroup标签：用于生成一个下拉列表框的选项组，因此该标签需要在&lt;s:select&gt;中使用。 案例实现 12345678910111213141516171819202122&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib prefix=\"s\" uri=\"/struts-tags\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;optgroup标签&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;s:form&gt; &lt;!-- 使用简单Map为列表框生成选项 --&gt; &lt;s:select name=\"b\" label=\"请选择你喜欢的书：\" size=\"7\" labelposition=\"top\" list=\"#&#123;'疯狂java讲义':'李刚','轻量级Java EE企业应用实战':'李刚','疯狂IOS讲义':'李刚'&#125;\" listKey=\"key\" listValueKey=\"value\"&gt; &lt;!-- 使用Map对象生成选项组 --&gt; &lt;s:optgroup label=\"Rod Johnson\" list=\"#&#123;'Expert One-on-one J2EE Design and Development':'Johnson'&#125;\"&gt;&lt;/s:optgroup&gt; &lt;s:optgroup label=\"David Flanagan\" list=\"#&#123;'JavaScript :The Definitive Guide':'David'&#125;\"&gt;&lt;/s:optgroup&gt; &lt;/s:select&gt; &lt;/s:form&gt;&lt;/body&gt;&lt;/html&gt; head标签：该标签主要用于生成HTML的&lt;head ../&gt;部分。 updownselect标签：该标签的用法非常相思雨select标签的使用，区别在于该标签生成的列表框可以上下移动。 案例实现 12345678910111213141516171819202122232425&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib prefix=\"s\" uri=\"/struts-tags\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;updownselect标签&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;s:form&gt; &lt;!-- 使用简单集合来生成上下移动选项的下拉列表框 --&gt; &lt;s:updownselect name=\"a\" label=\"请选择您喜欢的书：\" labelposition=\"top\" list=\"&#123;'疯狂java讲义','轻量级Java EE企业应用实战','疯狂IOS讲义'&#125;\" moveUpLabel=\"向上移动\"&gt;&lt;/s:updownselect&gt; &lt;!-- 使用简单Map为列表框生成选项 emptyOption=\"true\"增加空白选项--&gt; &lt;s:updownselect name=\"b\" label=\"请选择您想出版的日期：\" labelposition=\"top\" moveDownLabel=\"向下移动\" list=\"#&#123;'疯狂java讲义':'2008年9月','轻量级Java EE企业应用实战':'2008年12月','疯狂IOS讲义':'2014年1月'&#125;\" listKey=\"key\" listValueKey=\"value\" emptyOption=\"true\"&gt;&lt;/s:updownselect&gt; &lt;s:bean name=\"org.crazyit.app.service.BookService\" var=\"bs\"&gt;&lt;/s:bean&gt; &lt;s:updownselect name=\"c\" label=\"请选择您喜欢的图书：\" labelposition=\"top\" selectAllLabel=\"全选\" multiple=\"true\" list=\"#bs.books\" listKey=\"author\" listValue=\"name\"&gt;&lt;/s:updownselect&gt; &lt;/s:form&gt;&lt;/body&gt;&lt;/html&gt; doubleselect标签：会生成一个级联列表框。 案例实现1: 1234567891011121314151617&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib prefix=\"s\" uri=\"/struts-tags\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;doubleselect标签&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;s:form action=\"x\"&gt; &lt;s:doubleselect label=\"请选择您喜欢的书\" labelposition=\"top\" name=\"author\" list=\"&#123;'李刚','David'&#125;\" doubleList=\"top=='李刚'?&#123;'轻量级Java EE企业级应用实战','疯狂IOS讲义','疯狂Java讲义'&#125;:&#123;'JavaScript:the definitive guide'&#125;\" doubleName=\"book\"/&gt; &lt;/s:form&gt;&lt;/body&gt;&lt;/html&gt; 案例实现2: 1234567&lt;h3&gt;使用s:doubleselect生成级联列表框&lt;/h3&gt;&lt;s:set var=\"bs\" value=\"#&#123;'李刚':&#123;'疯狂java讲义','轻量级Java EE企业应用实战','疯狂IOS讲义'&#125;,'Johnson':&#123;'Expert One-on-one J2EE Design and Development'&#125;,'David':&#123;'JavaScript :The Definitive Guide'&#125;&#125;\"/&gt;&lt;s:form action=\"x\"&gt; &lt;s:doubleselect label=\"请选择您喜欢的书\" name=\"author\" list=\"#bs.keySet()\" size=\"3\" doubleList=\"#bs[top]\" doubleSize=\"3\" doubleName=\"book\"/&gt;&lt;/s:form&gt; optiontransferselect标签：会生成两个列表选择框，并生成系列按钮控制各选框之间的移动、升降等。 12345678910111213141516171819202122232425262728293031323334353637&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib prefix=\"s\" uri=\"/struts-tags\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;s:form&gt; &lt;!-- 使用简单的集合对象生成可移动的下拉框 --&gt; &lt;s:optiontransferselect label=\"请选择你喜欢的书\" name=\"cnbook\" leftTitle=\"中文图书\" rightTitle=\"外文图书\" list=\"&#123;'疯狂java讲义','轻量级Java EE企业应用实战','疯狂IOS讲义'&#125;\" multiple=\"true\" addToLeftLabel=\"向左移动\" addToRightLabel=\"向右移动\" selectAllLabel=\"全部选择\" addAllToRightLabel=\"全部右移\" addAllToLeftLabel=\"全部左移\" headerKey=\"cnKey\" headerValue=\"--- 选择中文图书 ---\" emptyOption=\"true\" doubleList=\"&#123;'Expert One-on-one J2EE Design and Development','JavaScript :The Definitive Guide'&#125;\" doubleName=\"enBook\" doubleHeaderKey=\"enKey\" doubleHeaderValue=\"--- 选择外文图书 ---\" doubleEmptyOption=\"true\" doubleMultiple=\"true\" /&gt; &lt;/s:form&gt;&lt;/body&gt;&lt;/html&gt; token标签：防止重复提交表单的标签。 案例实现： 1234567891011121314151617181920&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib prefix=\"s\" uri=\"/struts-tags\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;token标签&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h3&gt;使用s:token防止重复提交&lt;/h3&gt; &lt;s:form action=\"pro\"&gt; &lt;!-- 普通表单域 --&gt; &lt;s:textfield name=\"book\" label=\"书名\" /&gt; &lt;!-- 用于防刷新的token标签 --&gt; &lt;s:token/&gt; &lt;s:submit value=\"提交\"&gt;&lt;/s:submit&gt; &lt;/s:form&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920212223package org.crazyit.app.action;import com.opensymphony.xwork2.ActionSupport;public class ProAction extends ActionSupport&#123; private static final long serialVersionUID = 1L; private String book; public String getBook() &#123; return book; &#125; public void setBook(String book) &#123; this.book = book; &#125; //处理用户的业务逻辑 public String execute() &#123; System.out.println(getBook()); return NONE; &#125; &#125; 12345678910111213141516171819202122&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE struts PUBLIC \"-//Apache Software Foundation//DTD Struts Configuration 2.5//EN\" \"http://struts.apache.org/dtds/struts-2.5.dtd\"&gt;&lt;struts&gt; &lt;constant name=\"struts.devMode\" value=\"true\"&gt;&lt;/constant&gt; &lt;constant name=\"struts.enable.DynamicMethodInvocation\" value=\"true\"/&gt; &lt;package name=\"default\" namespace=\"/\" extends=\"struts-default\" &gt; &lt;action name=\"pro\" class=\"org.crazyit.app.action.ProAction\"&gt; &lt;!-- 使用系统默认的拦截器 --&gt; &lt;interceptor-ref name=\"basicStack\"&gt;&lt;/interceptor-ref&gt; &lt;!-- 使用防止刷新的拦截器 --&gt; &lt;interceptor-ref name=\"token\"/&gt; &lt;!-- 定义重复提交的转向视图，该逻辑视图名必须是：invalid.token --&gt; &lt;result name=\"invalid.token\"&gt;/WEB-INF/content/refresh.jsp&lt;/result&gt; &lt;/action&gt; &lt;action name=\"*\"&gt; &lt;result&gt;/WEB-INF/content/&#123;1&#125;.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; 使用token标签需要注意两点: 在页面中添加&lt;s:token/&gt;标签。 在配置文件中添加拦截器并且配置invalid.token结果集 非表单标签 非表单标签主要用于显示action里封装的信息。非表单标签主要有如下几个: actionerror：如果Action实例的getActionErrors()方法不返回null，则该标签负责输出该方法返回的系列错误。 actionmessage：如果Action实例的getActionMessages()方法不返回null，则该标签负责输出该方法返回的系列错误。 component：使用此标签可以生成一个自定义组件。 fielderror：如果Action实例存在表单域的类型转换错误、校验错误，则该标签负责输出错误信息。 actionerror和actionmessage标签 component标签：用于创建自定义组件 案例实现： 123456789101112131415161718192021222324&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib prefix=\"s\" uri=\"/struts-tags\" %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;使用s:component标签&lt;/h2&gt; 使用默认主题(xHTML)，默认主题目录(template)&lt;br&gt; 使用mytemplate作为视图组件 &lt;s:component template=\"mytemplate.jsp\"&gt; &lt;s:param name=\"list\" value=\"&#123;'疯狂Java讲义','疯狂IOS讲义','轻量级 Java EE企业应用实战'&#125;\"&gt;&lt;/s:param&gt; &lt;/s:component&gt;&lt;hr&gt; 使用自定义主题，自定义主题目录&lt;br&gt; 使用myAnotherTemplate.jsp作为视图组件 &lt;s:component template=\"myAnotherTemplate.jsp\" templateDir=\"myTemplateDir\" theme=\"myTheme\"&gt; &lt;s:param name=\"list\" value=\"&#123;'疯狂Java讲义','疯狂IOS讲义','轻量级 Java EE企业应用实战'&#125;\"&gt;&lt;/s:param&gt; &lt;/s:component&gt; &lt;/body&gt;&lt;/html&gt;","categories":[],"tags":[]},{"title":"Struts2","slug":"Struts2","date":"2019-09-10T03:05:26.000Z","updated":"2019-09-17T08:13:41.259Z","comments":true,"path":"2019/09/10/Struts2/","link":"","permalink":"https://CPWS.github.io/2019/09/10/Struts2/","excerpt":"","text":"Struts2框架学习第一讲：回顾 Web开发的进程有两种模式，model1开发模式和model2开发模式。 Model1模式 优点：执行效率高，开发效率高，适合中小型项目。 缺点：逻辑比较混乱，页面混乱，维护困难，扩展不容易。 Model2 优点：解耦，将试图层和业务层分离。结构清晰，分工明确，维护方便，适合中大型项目。 缺点：执行效率相对Model1低,代码量大，重复代码比较多。 Model2又称为MVC设计模式。 M:model模型 V:view试图 C：controller控制 使用Servlet的MVC存在一些问题，有重复的代码—通过MVC框架来解决。 Servlet解决了什么问题 将url映射到一个java类的处理方法上。 接收请求的数据。 如何将处理结果显示到页面。 如何进行页面的跳转。第二讲：框架 Java学习路线 基础语法—-&gt;方法（目的：减少代码，代码重复利用）—-&gt;类（目的：代码复用，OOP：面向对象）—-&gt; jar包（多个类封装为jar包。目的：代码复用）—-&gt; 框架（一个或多个jar包。目的：代码重用） 从中体现最多的思想是：封装 什么是框架？ framework 框架是模板，模型，模子。 专业语言描述：框架是一个可重用的半成品。 为什么要学框架？ 提高开发效率，降低学习难度。 如何学习框架？ 框架是别人提供的，那么使用框架时，要遵守框架提供的规。 学习框架就是学习框架的规则。 框架有两个部分组成：可变的部分和不可变的部分。 常见的框架有哪些 struts2,strut1,spring,hibernate,Mybatis,Shiro,nutz等待。第三讲：Struts入门 什么是struts？ Apache Struts is a free, open-source, MVC framework for creating elegant, modern Java web applications. It favors convention over configuration, is extensible using a plugin architecture, and ships with plugins to support REST, AJAX and JSON. Struts2是一个开源、免费、轻量级的mvc框架 轻量级：如果一个框架没有侵入性，就说该框架是轻量级的。 侵入性：如果使用一个框架必须实现框架提供的接口，或者继承框架提供的类。 在Struts2之前是Struts1。Struts1出现很早，市场占有率比较高，所以不支持一些新的试图层展示技术，逐渐被淘汰。Struts2=Struts1+webwork Struts2是基于请求的mvc框架。 Struts2的目录结构 apps：应用案例。 docs：文档。 lib：使用的库包。 src：源码。 Struts2的Hello World案例 新建web项目 导入jar包 编写web.xml文件–配置struts2的前端控制器（分发器） 123456789&lt;!-- 配置struts2的前端控制器 --&gt;&lt;filter&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;url-pattern&gt;*.action&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 编写业务处理类 123456789101112131415161718package demo;/**** struts2的第一个案例* @author 朱楚利**/public class HelloWorld &#123; /*** * 在Struts2中，所有的业务方法都是public * 返回值都为String类，所有的业务方法都没有参数 * 方法名可以自定义，默认是execute() * @return */ public String execute() &#123; System.out.println(\"Hello struts2\"); return \"success\"; &#125;&#125; 在src下，添加strut2的配置文件，名称为为struts.xml，该配置文件名不能更改，并进行配置。 123456789101112131415&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE struts PUBLIC \"-//Apache Software Foundation//DTD Struts Configuration 2.3//EN\" \"http://struts.apache.org/dtds/struts-2.3.dtd\"&gt;&lt;struts&gt; &lt;package name=\"default\" namespace=\"/\" extends=\"struts-default\"&gt; &lt;!-- 配置action 配置url和处理类的方法进行映射 --&gt; &lt;action name=\"hello\" class=\"demo.HelloWorld\"&gt; &lt;result&gt;/hello.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; 编写hello.jsp页面 123456789101112&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt; &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Insert title here&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;hello world struts2&lt;/h1&gt; &lt;/body&gt; &lt;/html&gt; 发布项目并进行测试。 第四讲 配置讲解 web.xml 123456789101112131415 &lt;!-- 配置struts2的前端控制器 struts2框架开始工作的入口 接管请求 --&gt;&lt;filter&gt; &lt;!-- 名称自定义 --&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;!-- Struts2提供的控制器类 --&gt; &lt;filter-class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;url-pattern&gt;*.action&lt;/url-pattern&gt;&lt;/filter-mapping&gt; struts2.xml 该配置文件的文件名固定，并且只能放在src目录下。 1234567891011121314151617181920212223242526272829303132333435363738 &lt;struts&gt;&lt;!-- package 分模块管理 name属性属性值自定义但是不能重复，在一个项目中是唯一的 namespace属性命名空间与url请求路径直接相关 如：“/” 请求为 /hello.action; 如：\"/user\"，则请求路径为/user/hello.action extends 继承 必须直接或间接继承struts-default result的请求路径是相对namespace的属性值 --&gt;&lt;package name=\"default\" namespace=\"/\" extends=\"struts-default\"&gt; &lt;!-- 配置action 配置url和处理类的方法进行映射 name为请求名称 不加后缀 class 处理类的完全限定名称 包名+类名，如果不配置，由默认类来处理 com.opensymphony.xwork2.ActionSupport method指定处理请求的方法，默认是execute()方法 --&gt; &lt;action name=\"hello\" class=\"demo.HelloWorld\" method=\"hello\"&gt; &lt;!-- result结果集配置 name 结果集名称，和处理方法的返回之匹配 默认为success，可以自定义。 Struts2提供了5个返回结果： Action.SUCCESS： 执行成功，跳转到下一个试图 Action.NONE：执行成功，不需要试图展示 Action.ERRPR:执行失败，显示失败页面 Action.INPUT：要执行该Action需要更多的输入条件 Action.LOGIN：需要登陆后才能执行 type指定响应结果类型 dispatcher 请求转发，默认使用 redirect 请求重定向 redirectAction 重定向到另一个action result的值为跳转页面 不加\"/\"为相对namespace路径，建议使用绝对路径 --&gt; &lt;result name=\"\" type=\"\"&gt;/hello.jsp&lt;/result&gt; &lt;/action&gt;&lt;/package&gt; 第五讲 Struts2的执行流程 浏览器发起请求 –&gt; 服务器接收请求并交给Struts2的前端控制器 —–&gt; 根据请求的url查看struts.xml中的namespace+actionName是否存在 –&gt; 执行action所对应的类的对应方法 —&gt; 根据方法的执行结果到action的结果集进行匹配 –&gt; 响应结果。 Struts2 第六讲 Struts2的数据处理一 在struts2中，对表单数据的处理有三种：属性驱动，对象驱动，模型驱动 使用Strut2获取表达数据：只需要表单域数据名称和Action处理类的属性名称一致，并且提供属性的set方法，那么在Action处理类中即可获取表单数据。这种获取数据的方式称为属性驱动。 处理类： 1234567891011121314151617181920212223242526272829package demo;import com.opensymphony.xwork2.Action;/*** * Struts2数据处理案列 * @author 1huangzewei * */public class LoginAction &#123; private String username; private String password; //登陆处理业务 public String login() &#123; System.out.println(\"username=\"+username+\";password=\"+password); return Action.SUCCESS; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public void setPassword(String password) &#123; this.password = password; &#125; &#125; 12345678910111213141516&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Struts2的数据处理&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=\"login.action\" method=\"post\"&gt; username:&lt;input type=\"text\" name=\"username\"/&gt;&lt;br&gt; password:&lt;input type=\"password\" name=\"password\"/&gt;&lt;br&gt; &lt;input type=\"button\" value=\"登录\"/&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 123456789&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE struts PUBLIC \"-//Apache Software Foundation//DTD Struts Configuration 2.3//EN\" \"http://struts.apache.org/dtds/struts-2.3.dtd\"&gt;&lt;struts&gt; &lt;package name=\"login\" namespace=\"/\" extends=\"struts-default\"&gt; &lt;action name=\"login\" class=\"demo.LoginAction\" method=\"login\"&gt; &lt;result&gt;/success.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; 如果数据需要显示在页面上，那么该数据可以作为处理类的数据，处理方法后该属性有值，并且有该属性的get方法，那么在页面上可以直接通过el表达式获取。 1234567891011121314151617181920212223242526272829303132333435package demo;import com.opensymphony.xwork2.Action;/*** * Struts2数据处理案列 * @author 1huangzewei * */public class LoginAction &#123; private String username; private String password; //登陆处理业务 public String login() &#123; System.out.println(\"username=\"+username+\";password=\"+password); return Action.SUCCESS; &#125; public String getUsername() &#123; return username; &#125; public String getPassword() &#123; return password; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public void setPassword(String password) &#123; this.password = password; &#125; &#125; 12345678910111213&lt;%@ page language=\"java\" contentType=\"text/html; charset=utf-8\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"utf-8\"&gt;&lt;title&gt;成功页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;My First Struts Demo&lt;/h1&gt; &lt;h3&gt;恭喜$&#123;username&#125;登录成功&lt;h3&gt; &lt;h2&gt;$&#123;password&#125;&lt;h2&gt;&lt;/body&gt;&lt;/html&gt; 第七讲 数据处理二 IOC：控制反转 对象驱动方式获取属性：（重点） 在action的处理类中，属性以对象的形式存在，该属性对象只需声明并为其提供get方法和set方法即可，需要保证该属性对象有无参构造方法。 在表单域中的表单域名称以属性对象.属性对象的属性来命名。 这种方式比较重要 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//User类package entity;public class User &#123; //如果要提供构造函数，要提供一个无参构造方法 private String username; private String password; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; &#125;//处理类package demo;import com.opensymphony.xwork2.Action;import entity.User;/*** * Struts2数据处理案列 * @author 1huangzewei` * */public class LoginAction02 &#123; //保证对象要有无参的构造方法 private User user; //IOC方式 //登陆处理业务 public String login() &#123; System.out.println(\"username=\"+user.getUsername()+\"\\tpassword=\"+user.getPassword()); return Action.SUCCESS; &#125; public User getUser() &#123; return user; &#125; public void setUser(User user) &#123; this.user = user; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435&lt;!--显示成功页面--&gt;&lt;%@ page language=\"java\" contentType=\"text/html; charset=utf-8\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"utf-8\"&gt;&lt;title&gt;成功页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;My First Struts Demo&lt;/h1&gt; &lt;!-- 属性驱动 --&gt; &lt;!--&lt;h3&gt;恭喜$&#123;username&#125;登录成功&lt;h3&gt; &lt;h2&gt;$&#123;password&#125;&lt;h2&gt;--&gt; &lt;!-- 对象驱动 --&gt; &lt;h3&gt;恭喜$&#123;user.username&#125;登录成功&lt;h3&gt; &lt;h2&gt;$&#123;user.password&#125;&lt;h2&gt;&lt;/body&gt;&lt;/html&gt;&lt;!--登录页面--&gt;&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Struts2的数据处理&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=\"login02.action\" method=\"post\"&gt; username:&lt;input type=\"text\" name=\"user.username\"/&gt;&lt;br&gt; password:&lt;input type=\"password\" name=\"user.password\"/&gt;&lt;br&gt; &lt;input type=\"button\" value=\"登录\"/&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 模式驱动：在对象驱动中，页面的表单域名称比较复杂，如果对象属性比较多的情况下，代码量比较大。通过模式驱动可以解决这个问题。 模式驱动需要实现ModelDriver接口，并且主动将对象创建好。 12345678910111213141516171819202122232425262728293031323334//处理类package demo;import com.opensymphony.xwork2.Action;import com.opensymphony.xwork2.ModelDriven;import entity.User;/*** * Struts2数据处理案列：模型驱动 * @author 1huangzewei * */public class LoginAction03 implements ModelDriven&lt;User&gt;&#123; //保证对象要有无参的构造方法 private User user=new User(); //IOC方式 //登陆处理业务 public String login() &#123; System.out.println(\"username=\"+user.getUsername()+\"\\tpassword=\"+user.getPassword()); return Action.SUCCESS; &#125; public User getUser() &#123; return user; &#125; public void setUser(User user) &#123; this.user = user; &#125; @Override public User getModel() &#123; // TODO Auto-generated method stub return user; &#125;&#125; 12345678910111213141516171819202122232425262728293031&lt;!--登录页面--&gt;&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Struts2的数据处理&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=\"login02.action\" method=\"post\"&gt; username:&lt;input type=\"text\" name=\"username\"/&gt;&lt;br&gt; password:&lt;input type=\"password\" name=\"password\"/&gt;&lt;br&gt; &lt;input type=\"button\" value=\"登录\"/&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;&lt;!--显示页面--&gt;&lt;%@ page language=\"java\" contentType=\"text/html; charset=utf-8\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"utf-8\"&gt;&lt;title&gt;成功页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;My First Struts Demo&lt;/h1&gt; &lt;h3&gt;恭喜$&#123;username&#125;登录成功&lt;h3&gt; &lt;h2&gt;$&#123;password&#125;&lt;h2&gt;&lt;/body&gt;&lt;/html&gt; 第七讲 数据处理二 IOC：控制反转 对象驱动方式获取属性：（重点） 在action的处理类中，属性以对象的形式存在，该属性对象只需声明并为其提供get方法和set方法即可，需要保证该属性对象有无参构造方法。 在表单域中的表单域名称以属性对象.属性对象的属性来命名。 这种方式比较重要 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//User类package entity;public class User &#123; //如果要提供构造函数，要提供一个无参构造方法 private String username; private String password; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; &#125;//处理类package demo;import com.opensymphony.xwork2.Action;import entity.User;/*** * Struts2数据处理案列 * @author 1huangzewei * */public class LoginAction02 &#123; //保证对象要有无参的构造方法 private User user; //IOC方式 //登陆处理业务 public String login() &#123; System.out.println(\"username=\"+user.getUsername()+\"\\tpassword=\"+user.getPassword()); return Action.SUCCESS; &#125; public User getUser() &#123; return user; &#125; public void setUser(User user) &#123; this.user = user; &#125;&#125; 123456789101112131415161718&lt;!--显示成功页面--&gt;&lt;%@ page language=\"java\" contentType=\"text/html; charset=utf-8\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"utf-8\"&gt;&lt;title&gt;成功页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;My First Struts Demo&lt;/h1&gt; &lt;!-- 属性驱动 --&gt; &lt;!--&lt;h3&gt;恭喜$&#123;username&#125;登录成功&lt;h3&gt; &lt;h2&gt;$&#123;password&#125;&lt;h2&gt;--&gt; &lt;!-- 对象驱动 --&gt; &lt;h3&gt;恭喜$&#123;user.username&#125;登录成功&lt;h3&gt; &lt;h2&gt;$&#123;user.password&#125;&lt;h2&gt;&lt;/body&gt;&lt;/html&gt; 第八讲 action的几种创建方式 在Struts2中有三种方式来创建action处理类 实现action接口的方式来创建处理类,好处: 可以直接使用Action类提供的常量 必须重写默认的处理方法。 这种方法使用比较少。 123456789101112131415161718192021package com.zhuchuli.action;import com.opensymphony.xwork2.Action;/*** * 通过实现Action接口来创建处理类：好处 *实现action接口的方式可以使用Action提供的常量 *必须重写默认处理方法 *这种方式使用的比较少 * @author 1huangzewei * */public class HelloAction implements Action&#123; @Override public String execute() throws Exception &#123; System.out.println(\"action execute\"); return SUCCESS; &#125;&#125; 通过继承ActionSupport类来创建Action的处理类，Strut2推荐使用这种方式。 1234567891011121314151617package com.zhuchuli.action;import com.opensymphony.xwork2.ActionSupport;/*** * 通过继承ActionSupport创建Action处理类：好处 * 并且ActionSupport类提供了很多其他Struts2的功能。 * 比如：数据校验，国际化 * 内部已经提供了默认实现方法 * * @author 1huangzewei * */public class HelloAction02 extends ActionSupport&#123;&#125; 无侵入性的实现方式 12345678910111213141516package com.zhuchuli.action;import com.opensymphony.xwork2.Action;/*** * 无侵入性的实现方式 * @author 1huangzewei * */public class Hello02Action &#123; public String execute() &#123; System.out.println(\"无侵入性的实现方式\"); return Action.SUCCESS; &#125;&#125; 第九讲 Struts2配置讲解2 constant标签 1234567 &lt;!-- strut2的常量配置 --&gt;&lt;!-- 扩展名的配置 --&gt;&lt;constant name=\"struts.action.extension\" value=\"do,zhangsan,,action\"&gt;&lt;/constant&gt;&lt;!-- 设置页面字符集，页面解决 --&gt;&lt;constant name=\"struts.i18n.encoding\" value=\"utf-8\"&gt;&lt;/constant&gt;&lt;!-- 开发模式 --&gt;&lt;constant name=\"struts.devMode\" value=\"true\"&gt;&lt;/constant&gt; include标签：引入其他的配置文件，在团队开发中使用 1234567&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE struts PUBLIC \"-//Apache Software Foundation//DTD Struts Configuration 2.3//EN\" \"http://struts.apache.org/dtds/struts-2.3.dtd\"&gt;&lt;struts&gt; &lt;include file=\"struts2/conguration/system.xml\"&gt;&lt;/include&gt; &lt;/struts&gt; 第十讲 action的优化配置 在Struts2中，随着业务的增加，action的配置文件会急剧增加，导致了配置文件膨胀的问题。struts2中提供了三种方式来解决这个问题。 通过动态方法调用来解决。 通过通配符来解决。 通过注解来解决。 传统的action方式，配置文件会变得很庞大 1234567891011121314151617181920&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE struts PUBLIC \"-//Apache Software Foundation//DTD Struts Configuration 2.3//EN\" \"http://struts.apache.org/dtds/struts-2.3.dtd\"&gt;&lt;struts&gt; &lt;package name=\"default\" namespace=\"/\" extends=\"struts-default\"&gt; &lt;action name=\"save\" class=\"com.zhuchuli.action.UserAction\" method=\"save\"&gt; &lt;result type=\"redirectAction\"&gt;find&lt;/result&gt; &lt;/action&gt; &lt;action name=\"delete\" class=\"com.zhuchuli.action.UserAction\" method=\"delete\"&gt; &lt;result type=\"redirectAction\"&gt;find&lt;/result&gt; &lt;/action&gt; &lt;action name=\"update\" class=\"com.zhuchuli.action.UserAction\" method=\"update\"&gt; &lt;result type=\"redirectAction\"&gt;find&lt;/result&gt; &lt;/action&gt; &lt;action name=\"query\" class=\"com.zhuchuli.action.UserAction\" method=\"query\"&gt; &lt;result&gt;/list.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt; &lt;/struts&gt; 12345678910111213141516171819202122package com.zhuchuli.action;import com.opensymphony.xwork2.Action;public class UserAction &#123; //增加 public String save() &#123; return Action.SUCCESS; &#125; //删除 public String delete() &#123; return Action.SUCCESS; &#125; //修改 public String update() &#123; return Action.SUCCESS; &#125; //查询 public String query() &#123; return Action.SUCCESS; &#125;&#125; 通过动态方法解决该问题 在常量中开启动态方法调用。&lt;constant name=&quot;struts.enable.DynamicMethodInvocation&quot; value=&quot;true&quot;&gt;&lt;/constant&gt; 配置action,一个Action处理类，只需配置一次。不需要配置处理方法。 123456&lt;action name=\"userAction\" class=\"com.zhuchuli.action.UserAction\"&gt; &lt;result type=\"redirect\"&gt;userAction!query.action&lt;/result&gt; &lt;result type=\"redirect\"&gt;userAction!delete.action&lt;/result&gt; &lt;result name=\"list\"&gt;/list.jsp&lt;/result&gt; &lt;result name=\"delete\"&gt;/delete.jsp&lt;/result&gt;&lt;/action&gt; 调用处理方法，ActionName!method.action，例如:http://localhost:8080/Struts_study02/userAction!delete.action 注意：使用动态方法调用需要不同处理方法的返回值是否一致问题。会配置多个结果集。这种方式不推荐使用，不安全。 12345678&lt;!-- *表示一个或多个字符 --&gt;&lt;!-- 占位符&#123;1&#125;表示匹配第一个“*”的内容 --&gt;&lt;!-- 使用通配符配置时，需要注意如果有不是通配符的action，先匹配action再匹配通配符--&gt;&lt;!-- 在实际应用开发中，使用通配符比较常见 --&gt;&lt;action name=\"*\" class=\"com.zhuchuli.action.UserAction\" method=\"&#123;1&#125;\"&gt; &lt;result type=\"redirect\"&gt;query&lt;/result&gt; &lt;result&gt;/list.jsp&lt;/result&gt;&lt;/action&gt; 注意如果使用通配符配置，那么需要注意不同处理方法的返回值的问题。 使用注解来解决。 使用注解需要导入struts2-convention-plugin-2.3.37.jar、asm-3.3.jar、asm-commons-3.3.jar、asm-tree-3.3.jar 在处理类上填写相关注解 123456789101112131415161718192021222324252627282930313233343536373839package com.zhuchuli.action;import org.apache.struts2.convention.annotation.Action;import org.apache.struts2.convention.annotation.Namespace;import org.apache.struts2.convention.annotation.ParentPackage;import org.apache.struts2.convention.annotation.Result;@ParentPackage(value=\"struts-default\")@Namespace(value=\"/\")public class UserAction &#123; //增加 @Action(value=\"save\",results= &#123; @Result(location=\"/list.jsp\") &#125;) public String save() &#123; System.out.println(\"save\"); return \"success\"; &#125; //删除 public String delete() &#123; System.out.println(\"delete\"); return \"success\"; &#125; //修改 public String update() &#123; System.out.println(\"update\"); return \"success\"; &#125; // //查询 @Action(value=\"query\",results= &#123; @Result(name=\"list\",location=\"/list.jsp\") &#125;) public String query() &#123; System.out.println(\"query\"); return \"list\"; &#125;&#125; 第十一讲 ThreadLocal和ActionContext ThreadLocal是一个容器，存放在容器中的数据是线程安全的。 123456789101112131415161718package threadlocal;public class ThreadLocalDemo &#123; public static void main(String[] args) &#123; final ThreadLocal&lt;Integer&gt; th=new ThreadLocal&lt;Integer&gt;(); //向ThreadLocal中存放数据 th.set(23); new Thread(() -&gt; &#123; th.set(12); System.out.println(\"====================\"); //获取存放在容器中的数据 System.out.println(\"thread--&gt;\"+th.get());//12 &#125;) .start(); System.out.println(\"main --&gt;\"+th.get()); //23 &#125;&#125; ActionContext：是Struts2的上下文对象，它的本质是一个容器，也是一个Map结构的对象。ActionContext贯穿于整个Action生命周期，每次接受请求后都会新建一个ActionContext对象，将ServletAPI中的数据存入到ActionContext中，实现了struts2和Servlet的解耦，使得测试可以不依赖容器。而且ActionContext是线程安全的。由于每次请求都会重新创建ActionContext，导致执行效率比Servlet低。 ActionContext有六个对象： request：存放的是HttpServletRequest域中的数据。 session：存放的是HttpSession域中的数据。 application：存放的是ServletContext域中的数据。 parameters：存放的是请求参数 attr：存放的是request、session、application中的数据。 ValueStacke：业务处理类的相关数据。 12345678// helpers to get access to request/session/application scopeextraContext.put(\"request\", requestMap);extraContext.put(\"session\", sessionMap);extraContext.put(\"application\", applicationMap);extraContext.put(\"parameters\", parameterMap);AttributeMap attrMap = new AttributeMap(extraContext);extraContext.put(\"attr\", attrMap); ServletContext:是一个容器，是一个对象，相当于map。 第十二讲 ognl ognl：Object graph navigation language，对象导航图语言。 在Struts2中，ognl完成数据设置和类型转换两个功能。 在struts2中是通过ognl来设值和取值的。ActionContext作为ognl的上下文，ValueStack作为ognl的root对象 在struts2中使用ognl表达式获取数据需要使用struts2的标签库，使用struts2的标签库，需要注意一定是通过过滤器后才能解析struts2的标签 123456789101112131415161718192021222324252627282930313233343536373839package demo;import com.opensymphony.xwork2.Action;import com.opensymphony.xwork2.ActionContext;/*** * Struts2数据处理案列：属性驱动 * @author 1huangzewei * */public class LoginAction &#123; private String username; private String password; //登陆处理业务 public String login() &#123; System.out.println(\"username=\"+username+\";password=\"+password); ActionContext.getContext().getApplication().put(\"address\", \"北京尚学堂\"); return Action.SUCCESS; &#125; public String getUsername() &#123; return username; &#125; public String getPassword() &#123; return password; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public void setPassword(String password) &#123; this.password = password; &#125; &#125; 12345678910111213141516&lt;%@ page language=\"java\" contentType=\"text/html; charset=utf-8\"%&gt;&lt;%@ taglib prefix=\"s\" uri=\"/struts-tags\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"utf-8\"&gt;&lt;title&gt;成功页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;My First Struts Demo&lt;/h1&gt; 登录成功，欢迎&lt;s:property value=\"username\"/&gt;&lt;br&gt; &lt;h2&gt;$&#123;password&#125;&lt;h2&gt; &lt;h3&gt;&lt;s:property value=\"#application.address\"/&gt;&lt;/h3&gt; &lt;h3&gt;&lt;s:property value=\"#parameters.username\"/&gt;&lt;/h3&gt;&lt;/body&gt;&lt;/html&gt; ognl获取各种域中的数据如下： application：#application.username、#application[&#39;username&#39;]； session：#session.username、#session[&#39;username&#39;]； request：#request.username、#request[&#39;username&#39;]； parameters：#parameters.username、#parameter[&#39;username&#39;]； attr：#attr.username、#attr[&#39;username&#39;]，按pageContext、request、session、application顺序查找。 第十三讲 ServletAPI 在Struts2的开发中，依然需要使用到ServletAPI，比如用户登录之后，需要将用户信息保存到session中.在Struts2中有两种方式可以获取ServletAPI,一种解耦方式，一种是耦合方式。 解耦的实现方式 12345678910111213141516171819202122232425262728293031package com.zhuchuli.action;import com.opensymphony.xwork2.Action;import com.opensymphony.xwork2.ActionContext;import cn.zhuchuli.vo.User;public class LoginAction &#123; //保证对象要有无参的构造方法 private User user; public User getUser() &#123; return user; &#125; public void setUser(User user) &#123; this.user = user; &#125; public String login() &#123; System.out.println(\"username=\"+user.getUsername()+\"\\tpassword=\"+user.getPassword()); if(\"possible\".equals(user.getUsername()) &amp;&amp; \"123456\".equals(user.getPassword())) &#123; //用户登录成功，将用户信息写入到session ActionContext.getContext().getSession().put(\"currentUser\", user); //获取request Map&lt;String,Object&gt; req=(Map&lt;String,Object&gt;)ActionContext.getContext().get(\"request\"); return Action.SUCCESS; &#125; return Action.LOGIN; &#125;&#125; 耦合的方式 直接通过ServletContext获取 12345678910public String login() &#123; System.out.println(\"username=\"+user.getUsername()+\"\\tpassword=\"+user.getPassword()); if(\"possible\".equals(user.getUsername()) &amp;&amp; \"123456\".equals(user.getPassword())) &#123; //直接获取ServletAPI,所以是耦合的方式 HttpServletRequest req=ServletActionContext.getRequest(); req.getSession().setAttribute(\"currentUser\", user); return Action.SUCCESS; &#125; return Action.LOGIN;&#125; 通过ActionContext获取 1234567891011public String login() &#123; System.out.println(\"username=\"+user.getUsername()+\"\\tpassword=\"+user.getPassword()); if(\"possible\".equals(user.getUsername()) &amp;&amp; \"123456\".equals(user.getPassword())) &#123; //通过ActionContext方式获取ServletAPI System.out.println(\"通过ActionContext方式获取ServletAPI\"); HttpServletRequest req=(HttpServletRequest) ActionContext.getContext().get(StrutsStatics.HTTP_REQUEST); req.getSession().setAttribute(\"currentUser\", user); return Action.SUCCESS; &#125; return Action.LOGIN; &#125; 通过IOC方式直接获取到ServletAPI 12345678910111213141516171819202122232425262728public class LoginAction03 implements ServletRequestAware&#123; //保证对象要有无参的构造方法 private User user; private HttpServletRequest req; public User getUser() &#123; return user; &#125; public void setUser(User user) &#123; this.user = user; &#125; public String login() &#123; System.out.println(\"username=\"+user.getUsername()+\"\\tpassword=\"+user.getPassword()); if(\"possible\".equals(user.getUsername()) &amp;&amp; \"123456\".equals(user.getPassword())) ; //通过IOC方法获取ServletAPI对象 System.out.println(\"通过IOC方法获取ServletAPI对象\"); req.getSession().setAttribute(\"currentUser\", user); return Action.SUCCESS; &#125; return Action.LOGIN; &#125; @Override public void setServletRequest(HttpServletRequest request) &#123; this.req=request; &#125;&#125; 第十四讲 类型转换 在Struts2中，对常用的数据类型已经自动进行了类型装换工作。但是对于自定义类型，Struts2没法去做类型转换工作。需要自定义类型转换器来实现类型的转换。 类型转换的实现步骤： 新建一个类型转换并继承StrutsTypeConverter 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package cn.zhuchuli.pointconverter;import java.util.Map;import org.apache.struts2.util.StrutsTypeConverter;import cn.zhuchuli.vo.Point;/*** * 自定义类型转换器 * @author 1huangzewei * */public class PointConverter extends StrutsTypeConverter &#123; /** * 将表单提交的数据在这个方法中被转换。 * 返回值是目标点对象 * Converts one or more String values to the specified class. * * @param context the action context * @param values the String values to be converted, such as those submitted from an HTML form * @param toClass the class to convert to * @return the converted object */ @Override public Object convertFromString(Map context, String[] values, Class toClass) &#123; System.out.println(\"将String转化为指定类型\"); String value=values[0]; Point point=new Point(); point.setX(Integer.parseInt(value.substring(1,value.indexOf(\",\")))); point.setY(Integer.parseInt(value.substring(value.indexOf(\",\")+1,value.indexOf(\")\")))); return point; &#125; /** * Converts the specified object to a String. * * @param context the action context * @param o the object to be converted * @return the converted String * 使用ognl表达式获取值会调用该方法 */ @Override public String convertToString(Map context, Object o) &#123; // TODO Auto-generated method stub System.out.println(\"将指定的类型转化为String\"); Point p=(Point) o; return \"(\"+p.getX()+\",\"+p.getY()+\")\"; &#125;&#125; 在src下添加xwork-conversion.properties配置文件 # be converted type=converter cn.zhuchuli.vo.Point = cn.zhuchuli.pointconverter.PointConverter 第十五讲 数据校验一 （硬编码实现） 数据校验分为2类，一类是前端的数据校验，一般通过js实现，一类是后端的数据验证。在对一些安全级别较高项目都需要对其进行后台验证。Struts2提供了两种后台校验方法，一种是硬编码实现，一种是校验框架实现。 如果要使用struts2的数据校验功能，action需要继承ActionSupport类。在该类中提供了validate方法，可以将验证规则写在该方法中，只有方法执行通过之后，才会执行业务方法。 实现步骤 业务处理类 123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.zhuchuli.action;import java.util.regex.Matcher;import java.util.regex.Pattern;import com.opensymphony.xwork2.ActionSupport;import cn.zhuchuli.vo.User;/*** * 数据校验 * @author 1huangzewei * */public class UserAction extends ActionSupport&#123; private User user; //限制validate方法，方法通过执行后执行execute发明方法。 //默认该方法是通过的。 //在validate方法中，添加了FieldError或者ActionError那么该方法将执行不能通过，并且返回结果集为INPUT // @Override public void validate() &#123; System.out.println(\"-------validate-------\"); Pattern p=Pattern.compile(\"[\\\\w]+[A-Za-z0-9]&#123;6,16&#125;\"); Matcher m=p.matcher(user.getName()); if(!m.find()) &#123; //用户名不合法，添加错误信息 this.addFieldError(\"user.name\", \"用户名不合法\"); &#125; super.validate(); &#125; public String execute() &#123; System.out.println(\"------execute---------\"); System.out.println(user); return SUCCESS; &#125; public User getUser() &#123; return user; &#125; public void setUser(User user) &#123; this.user = user; &#125; &#125; 在配置文件中配置input结果集 1234&lt;action name=\"user\" class=\"com.zhuchuli.action.UserAction\"&gt; &lt;result&gt;/success.jsp&lt;/result&gt; &lt;result name=\"input\"&gt;/save.jsp&lt;/result&gt;&lt;/action&gt; 在页面中添加struts2的标签库，并且添加错误标签 123456789101112131415161718&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib prefix=\"s\" uri=\"/struts-tags\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=\"user.action\" method=\"post\"&gt; name:&lt;input type=\"text\" name=\"user.name\"/&gt;&lt;s:fielderror fieldName=\"user.name\"&gt;&lt;/s:fielderror&gt;&lt;br&gt; sex:&lt;input type=\"text\" name=\"user.sex\"/&gt;&lt;br&gt; age:&lt;input type=\"text\" name=\"user.age\"/&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"登录\"/&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 通过上述方法来实现数据校验会有一个问题。一个业务类中有多个业务方法，并且每个业务方法的验证规则可能不一致，但是所有的业务方法都会通过validate。导致功能不能实现。在struts2中，如果一个业务类中有多个业务方法，那么需要为每个业务方法添加自己的验证方法。验证方法的命名规则为validate+业务方法名(首字母大写)。这样执行业务方法时，执行顺序为validateXxxx ---&gt; validate ---&gt; xxxx。这样的话，validate方法中填写的公共的验证方法。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package com.zhuchuli.action;import java.util.regex.Matcher;import java.util.regex.Pattern;import com.opensymphony.xwork2.ActionSupport;import cn.zhuchuli.vo.User;/*** * 数据校验 * @author 1huangzewei * */public class UserAction extends ActionSupport&#123; private User user; //限制validate方法，方法通过执行后执行execute发明方法。 //默认该方法是通过的。 //在validate方法中，添加了FieldError或者ActionError那么该方法将执行不能通过，并且返回结果集为INPUT // @Override public void validate() &#123; System.out.println(\"-------validate-------\"); Pattern p=Pattern.compile(\"[\\\\w]+[A-Za-z0-9]&#123;6,16&#125;\"); Matcher m=p.matcher(user.getName()); if(!m.find()) &#123; //用户名不合法，添加错误信息 this.addFieldError(\"user.name\", \"用户名不合法\"); &#125; super.validate(); &#125; public void validateExecute() &#123; System.out.println(\"-------validateExecute-------\"); Pattern p=Pattern.compile(\"[\\\\w]+[A-Za-z0-9]&#123;6,16&#125;\"); Matcher m=p.matcher(user.getName()); if(!m.find()) &#123; //用户名不合法，添加错误信息 this.addFieldError(\"user.name\", \"用户名不合法\"); &#125; super.validate(); &#125; public String execute() &#123; System.out.println(\"------execute---------\"); System.out.println(user); return SUCCESS; &#125; public User getUser() &#123; return user; &#125; public void setUser(User user) &#123; this.user = user; &#125; &#125; 第十五讲 数据校验二（使用Struts2提供的校验框架实现数据校验） 实现步骤 创建jsp页面 123456789101112131415161718&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib prefix=\"s\" uri=\"/struts-tags\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=\"user.action\" method=\"post\"&gt; name:&lt;input type=\"text\" name=\"user.name\"/&gt;&lt;s:fielderror fieldName=\"user.name\"&gt;&lt;/s:fielderror&gt;&lt;br&gt; sex:&lt;input type=\"text\" name=\"user.sex\"/&gt;&lt;br&gt; age:&lt;input type=\"text\" name=\"user.age\"/&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"登录\"/&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 创建Action类 12345678910111213141516171819202122232425package com.zhuchuli.action;import com.opensymphony.xwork2.ActionSupport;import cn.zhuchuli.vo.User;public class UserFormAction extends ActionSupport&#123; private User user; public String execute() &#123; System.out.println(\"------execute---------\"); System.out.println(user); return SUCCESS; &#125; public User getUser() &#123; return user; &#125; public void setUser(User user) &#123; this.user = user; &#125;&#125; 在Action类所在包下，添加校验规则文件以ActionClassName-validation.xml命名 123456789101112131415161718&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;!DOCTYPE validators PUBLIC \"-//Apache Struts//XWork Validator 1.0//EN\" \"http://struts.apache.org/dtds/xwork-validator-1.0.dtd\"&gt; &lt;validators&gt; &lt;!--field表示对哪个表单域进行验证 --&gt; &lt;field name=\"user.name\"&gt; &lt;!-- 字段验证器 Struts2默认提供了很多验证器 --&gt; &lt;field-validator type=\"requiredstring\"&gt; &lt;message&gt;你必须输入姓名。&lt;/message&gt; &lt;/field-validator&gt; &lt;field-validator type=\"stringlength\"&gt; &lt;param name=\"maxLength\"&gt;10&lt;/param&gt; &lt;param name=\"minLength\"&gt;4&lt;/param&gt; &lt;message&gt;你必须输入姓名在$&#123;maxLength&#125;和$&#123;minLength&#125;之间&lt;/message&gt; &lt;/field-validator&gt; &lt;/field&gt; &lt;/validators&gt; 配置Struts.xml文件 12345678910111213141516171819&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE struts PUBLIC \"-//Apache Software Foundation//DTD Struts Configuration 2.3//EN\" \"http://struts.apache.org/dtds/struts-2.3.dtd\"&gt;&lt;struts&gt; &lt;package name=\"default\" namespace=\"/\" extends=\"struts-default\"&gt; &lt;!-- &lt;action name=\"point\" class=\"com.zhuchuli.action.PointAction\"&gt; &lt;result&gt;/success.jsp&lt;/result&gt; &lt;/action&gt; &lt;action name=\"user\" class=\"com.zhuchuli.action.UserAction\"&gt; &lt;result&gt;/success.jsp&lt;/result&gt; &lt;result name=\"input\"&gt;/save.jsp&lt;/result&gt; &lt;/action&gt; --&gt; &lt;action name=\"user\" class=\"com.zhuchuli.action.UserFormAction\"&gt; &lt;result&gt;/success.jsp&lt;/result&gt; &lt;result name=\"input\"&gt;/save.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt; &lt;/struts&gt; 第十七讲 Struts2拦截器 struts2中的所有功能都是由拦截器来实现的。拦截器是Struts2的核心。拦截器和过滤器非常相似，过滤器过滤的是所有的请求，拦截器纸过滤action，并且在struts2中所有的功能都是可插拔的。在struts2中还可以自定义拦截器来实现一些struts2没有提供的功能。在struts2中拦截器的实现是通过代理来实现的。（AOP）在Struts2中拦截器都是单列的，所有的action共享相同的拦截器，所以在拦截器定义常量时要注意线程安全问题。 Struts2中提供很多拦截器来实现各种功能，在开发中可以根据不同的应用选择不同的拦截器来实现功能。Struts2提供了一系列默认的拦截器（拦截器栈）来实现功能。 默认拦截器说明 alias：对于HTTP请求包含的参数设置别名 autowiring：将某些JavaBean实例自动绑定到其他Bean对应的属性中。有点类似Spring的自动绑定，在Spring部分会详细说明。 Chain：在Web项目开发中，以前使用Struts开发时候经常碰到两个Action互相传递参数或属性的情况。该拦截器就是让前一Action的参数可以在现有Action中使用。 conversionError：从ActionContext中将转化类型时候发生的错误添加到Action的值域错误中，在校验时候经常被使用到来显示类型转化错误的信息。 cookie：从Struts&lt; xmlnamespace prefix=&quot;ST1&quot; &gt;2.0.7版本开始，可以把cookie注入Action中可设置的名字或值中。 createSession：自动创建一个HTTP的Session，尤其是对需要HTTP的Session的拦截器特别有用。比如下面介绍的TokenInterceptor。 debugging：用来对在视图间传递的数据进行调试。 ExecAndWait：不显式执行Action，在视图上显示给用户的是一个正在等待的页面，但是Action其实是在“背后”正在执行着。该拦截器尤其在对进度条进行开发的时候特别有用。 exception：将异常和Action返回的result相映射。 fileUpload：支持文件上传功能的拦截器。 i18n：支持国际化的拦截器。 logger：拥有日志功能的拦截器。 modelDriven：Action执行该拦截器时候，可以将getModel方法得到的result值放入值栈中 scopedModelDriven：执行该拦截器时候，它可以从一个scope范围检索和存储model值，通过调用setModel方法去设置model值。 params：将HTTP请求中包含的参数值设置到Action中。 prepare：假如Action继承了Preparable接口，则会调用prepare方法。 staticParams：对于在struts.xml文件中Action中设置的参数设置到对应的Action中。 scope：在session或者application范围中设置Action的状态 servletConfig：该拦截器提供访问包含HttpServletResquest和HttpServletResponse对象的Map的方法。 timer：输出Action的执行时间。 token：避免重复提交的校验拦截器 tokenSession：和token拦截器类似，但它还能存储提交的数据到session里。 validation：运行在action-validation.xml(校验章节将介绍)文件中定义的校验规则。 workflow：在Action中调用validate校验方法。如果Action有错误则返回到input视图。 store：执行校验功能时候，该拦截器提供存储和检索Action的所有错误和正确信息的功能。 checkbox：视图中如果有checkbox存在的情况，该拦截器自动将unchecked的checkbox当作一个参数（通常值为“false”）记录下来。这样可以用一个隐藏的表单值来记录所有未提交的checkbox，而且缺省unchecked的checkbox值是布尔类型的，如果视图中checkbox的值设置的不是布尔类型，它就会被覆盖成布尔类型的值。 profiling：通过参数来激活或不激活分析检测功能，前提是Web项目是在开发模式下。（涉及到调试和性能检验时使用） roles：进行权限配置的拦截器，如果登录用户拥有相应权限才去执行某一特定Action。 Struts2中的默认拦截器是定义在struts-default.xml中。这些拦截器都是定义在struts-default包下的。所以在使用struts2时定义的package要直接或间接继承struts-default 常见内置拦截器的使用，使用内置拦截器是需要引用拦截器。 Timer拦截器的使用 创建action类 12345678package com.zhuchuli.interceptor;public class TimerAction &#123; public String execute() &#123; System.out.println(\"Hello action\"); return \"none\"; &#125;&#125; 在配置文件中进行配置 1234567891011&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE struts PUBLIC \"-//Apache Software Foundation//DTD Struts Configuration 2.3//EN\" \"http://struts.apache.org/dtds/struts-2.3.dtd\"&gt;&lt;struts&gt; &lt;package name=\"default\" namespace=\"/\" extends=\"struts-default\"&gt; &lt;action name=\"interceptor\" class=\"com.zhuchuli.interceptor.TimerAction\"&gt; &lt;result&gt;&lt;/result&gt; &lt;!-- 使用拦截器时，需要在指定的action中引用拦截器 --&gt; &lt;interceptor-ref name=\"timer\"&gt;&lt;/interceptor-ref&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; token拦截器的使用 创建Action类 12345678910111213141516171819202122232425package com.zhuchuli.interceptor;import com.opensymphony.xwork2.Action;import com.opensymphony.xwork2.ActionSupport;import com.zhuchuuli.vo.User;public class UserAction extends ActionSupport&#123; private User user; public String toSave() &#123; return Action.SUCCESS; &#125; public String save() &#123; System.out.println(\"add user to database\"); System.out.println(user); return Action.SUCCESS; &#125; public User getUser() &#123; return user; &#125; public void setUser(User user) &#123; this.user = user; &#125; &#125; 在页面中添加token标签 123456789101112131415161718&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib prefix=\"s\" uri=\"/struts-tags\" %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;提交页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=\"interceptor.action\" method=\"post\"&gt; &lt;s:token&gt;&lt;/s:token&gt; name:&lt;input type=\"text\" name=\"user.name\"/&gt;&lt;br&gt; age:&lt;input type=\"text\" name=\"user.age\"/&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"save\" /&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 在action中引用token 1234567891011121314&lt;action name=\"save\" class=\"com.zhuchuli.interceptor.UserAction\" method=\"save\"&gt; &lt;interceptor-ref name=\"token\"&gt;&lt;/interceptor-ref&gt; &lt;interceptor-ref name=\"basicStack\"/&gt; &lt;result&gt;/success.jsp&lt;/result&gt; &lt;result name=\"invalid.token\"&gt;/invalid.jsp&lt;/result&gt; &lt;!-- 使用拦截器时，需要在指定的action中引用拦截器 --&gt; &lt;!-- &lt;interceptor-ref name=\"timer\"&gt;&lt;/interceptor-ref&gt; --&gt; &lt;!-- 当用户重复提交时，会返回invalid.token结果集 --&gt; &lt;/action&gt; &lt;action name=\"toSave\" class=\"com.zhuchuli.interceptor.UserAction\" method=\"toSave\"&gt; &lt;result&gt;/save.jsp&lt;/result&gt; &lt;/action&gt; 编写失效页面。 123456789101112&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;表单不能重复提交&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 第十八讲 自定义拦截器 在开发中，经常会使用到struts2中没有提供的一些功能，这时需要我们自定义拦截器来实现。当引用自定义拦截器后，struts2提供的默认拦截器将不起作用，需要重新引入。 自定义拦截器的实现步骤： 定义拦截器 123456789101112131415161718192021222324252627282930313233343536373839package com.zhuchuli.myinterceptor;import com.opensymphony.xwork2.ActionInvocation;import com.opensymphony.xwork2.interceptor.Interceptor;/*** * 自定义拦截器 * 有两种实现方式 * 实现Interceptor接口 * 继承AbstractInterceptor类 * @author 1huangzewei * */public class MyInterceptor implements Interceptor&#123; @Override public void destroy() &#123; // TODO Auto-generated method stub &#125; @Override public void init() &#123; // TODO Auto-generated method stub &#125; //拦截器的主体实现 /*** * 当拦截器的方法被调用执行后，需要调用 invocation.invoke调用下一个拦截器。 * 如果没有拦截器，那么执行action中的业务方法。 */ @Override public String intercept(ActionInvocation invocation) throws Exception &#123; System.out.println(\"-------------------自定义拦截器被执行了o-------------------\"); //返回值为结果集 return invocation.invoke(); &#125;&#125; 在package中配置拦截器 1234&lt;!-- 拦截器的配置 --&gt;&lt;interceptors&gt; &lt;interceptor name=\"MyIntercept\" class=\"com.zhuchuli.myinterceptor.MyInterceptor\"&gt;&lt;/interceptor&gt;&lt;/interceptors&gt; 在使用action中引用拦截器 123456&lt;action name=\"timer\" class=\"com.zhuchuli.interceptor.TimerAction\"&gt; &lt;interceptor-ref name=\"timer\"&gt;&lt;/interceptor-ref&gt; &lt;!-- 使用自定义拦截器 --&gt; &lt;interceptor-ref name=\"MyIntercept\"&gt;&lt;/interceptor-ref&gt; &lt;result&gt;/success.jsp&lt;/result&gt;&lt;/action&gt; 登录拦截器的实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.zhuchuli.myinterceptor;import com.opensymphony.xwork2.Action;import com.opensymphony.xwork2.ActionInvocation;import com.opensymphony.xwork2.interceptor.Interceptor;/*** * 登录拦截器的实现 * @author 1huangzewei * */public class LoginInterceptor implements Interceptor&#123; @Override public void destroy() &#123; // TODO Auto-generated method stub &#125; @Override public void init() &#123; // TODO Auto-generated method stub &#125; /** * 判断是否是登录的action，如果是，继续执行 * 如果不是 判断session中是否存在用户， * 如果没有，跳转到登录界面 * 如果有继续执行 */ @Override public String intercept(ActionInvocation invocation) throws Exception &#123; String actionName= invocation.getProxy().getActionName(); if(\"login\".equals(actionName)) &#123; return invocation.invoke(); &#125; Object currentUser=invocation.getInvocationContext().getSession().get(\"currentUser\"); if(currentUser!=null) &#123; return invocation.invoke(); &#125; return Action.LOGIN; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839&lt;package name=\"default\" namespace=\"/\" extends=\"struts-default\"&gt; &lt;!-- 拦截器的配置 --&gt; &lt;interceptors&gt; &lt;interceptor name=\"MyIntercept\" class=\"com.zhuchuli.myinterceptor.MyInterceptor\"&gt;&lt;/interceptor&gt; &lt;interceptor name=\"loginIntercept\" class=\"com.zhuchuli.myinterceptor.LoginInterceptor\"&gt;&lt;/interceptor&gt; &lt;/interceptors&gt; &lt;!-- 配置全局结果集 --&gt; &lt;!-- 当前action结果集找不到，就去找全局结果集，如果再找不到，返回404 --&gt; &lt;global-results&gt; &lt;result name=\"login\"&gt;/login.jsp&lt;/result&gt; &lt;result name=\"input\"&gt;/login.jsp&lt;/result&gt; &lt;/global-results&gt; &lt;action name=\"timer\" class=\"com.zhuchuli.interceptor.TimerAction\"&gt; &lt;interceptor-ref name=\"timer\"&gt;&lt;/interceptor-ref&gt; &lt;!-- 使用自定义拦截器 --&gt; &lt;interceptor-ref name=\"MyIntercept\"&gt;&lt;/interceptor-ref&gt; &lt;result&gt;/success.jsp&lt;/result&gt; &lt;interceptor-ref name=\"loginIntercept\"/&gt; &lt;/action&gt; &lt;action name=\"save\" class=\"com.zhuchuli.interceptor.UserAction\" method=\"save\"&gt; &lt;!-- 使用拦截器时，需要在指定的action中引用拦截器 --&gt; &lt;!-- &lt;interceptor-ref name=\"timer\"&gt;&lt;/interceptor-ref&gt; --&gt; &lt;!-- 当用户重复提交时，会返回invalid.token结果集 --&gt; &lt;interceptor-ref name=\"token\"&gt;&lt;/interceptor-ref&gt; &lt;interceptor-ref name=\"basicStack\"/&gt; &lt;interceptor-ref name=\"loginIntercept\"/&gt; &lt;result&gt;/success.jsp&lt;/result&gt; &lt;result name=\"invalid.token\"&gt;/invalid.jsp&lt;/result&gt; &lt;/action&gt; &lt;action name=\"toSave\" class=\"com.zhuchuli.interceptor.UserAction\" method=\"toSave\"&gt; &lt;result&gt;/save.jsp&lt;/result&gt; &lt;interceptor-ref name=\"loginIntercept\"/&gt; &lt;/action&gt; &lt;action name=\"login\" class=\"com.zhuchuli.interceptor.UserAction02\" method=\"login\"&gt; &lt;result&gt;/success.jsp&lt;/result&gt; &lt;interceptor-ref name=\"loginIntercept\"/&gt; &lt;interceptor-ref name=\"basicStack\"/&gt; &lt;/action&gt; &lt;/package&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.zhuchuli.interceptor;import java.util.regex.Matcher;import java.util.regex.Pattern;import org.apache.struts2.ServletActionContext;import com.opensymphony.xwork2.Action;import com.opensymphony.xwork2.ActionSupport;import com.zhuchuuli.vo.User02;public class UserAction02 extends ActionSupport&#123; private User02 user; //进行数据校验 public void validate() &#123; Pattern p=Pattern.compile(\"[\\\\w]+[A-Za-z0-9]&#123;6,16&#125;\"); Matcher m=p.matcher(user.getPwd()); if(!((user.getName().length()&gt;=4||user.getName().length()&lt;=10)&amp;&amp; m.find())) &#123; //用户名不合法，添加错误信息 this.addFieldError(\"user.name\", \"用户名或密码不合法\"); &#125; &#125; public String toSave() &#123; return Action.SUCCESS; &#125; public String login() &#123; System.out.println(\"------login---------\"); //ServletActionContext.getRequest().getSession().setAttribute(\"currentUser\", user); //采用解耦的方式进行SevletAPI操作 if(\"possible\".equals(user.getName())&amp;&amp;\"123456\".equals(user.getPwd())) &#123; ServletActionContext.getContext().getSession().put(\"currentUser\", user); System.out.println(ServletActionContext.getContext().getSession().get(\"currentUser\")); return Action.SUCCESS; &#125;else &#123; return Action.LOGIN; &#125; &#125; public User02 getUser() &#123; return user; &#125; public void setUser(User02 user) &#123; this.user = user; &#125; &#125; 12345678910111213141516171819package com.zhuchuuli.vo;public class User02 &#123; private String name; private String pwd; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getPwd() &#123; return pwd; &#125; public void setPwd(String pwd) &#123; this.pwd = pwd; &#125; &#125; 12345678910111213141516171819&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib prefix=\"s\" uri=\"/struts-tags\" %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=\"login.action\" method=\"post\"&gt; 用户名：&lt;input type=\"text\" name=\"user.name\"/&gt;&lt;br&gt; 密码：&lt;input type=\"password\" name=\"user.pwd\"/&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"登录\"/&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 第十九讲 拦截器栈和方法拦截器 拦截器栈：就是一组拦截器，放在一个配置中，在拦截器栈中可以引用多个拦截器，在真正需要调用时只需要一个栈即可,方便引用,拦截器中可以引用另外一个拦截器栈, 1234567891011&lt;!-- 拦截器的配置 --&gt;&lt;interceptors&gt; &lt;interceptor name=\"MyIntercept\" class=\"com.zhuchuli.myinterceptor.MyInterceptor\"&gt;&lt;/interceptor&gt; &lt;interceptor name=\"loginIntercept\" class=\"com.zhuchuli.myinterceptor.LoginInterceptor\"&gt;&lt;/interceptor&gt; &lt;!-- 拦截器栈 --&gt; &lt;interceptor-stack name=\"myStack\"&gt; &lt;interceptor-ref name=\"basicStack\"/&gt; &lt;interceptor-ref name=\"loginIntercept\"/&gt; &lt;interceptor-ref name=\"basicStack\"/&gt; &lt;/interceptor-stack&gt;&lt;/interceptors&gt; 拦截器栈的引用，与拦截器引用一致，可以将拦截器栈当做拦截器来使用 1&lt;interceptor-ref name=\"myStack\"&gt;&lt;/interceptor-ref&gt; 设置默认拦截器栈 12&lt;!-- 设置默认拦截器--&gt;&lt;!-- &lt;default-action-ref name=\"myStack\"&gt;&lt;/default-action-ref&gt;--&gt; Struts2定义了默认的拦截器栈是defaultStack，里面有默认的18个拦截器。 拦截器拦截的是整个action，action中的所有业务方法都会被拦截。比较粗粒度。有时只需拦截action中某个方法或某几个方法就能实现功能，那么拦截器就会造成效率降低。这时可以通过方法拦截器来解决这个问题。 方法拦截器的实现 123456789101112131415161718192021222324package com.zhuchuli.myinterceptor;import com.opensymphony.xwork2.ActionInvocation;import com.opensymphony.xwork2.interceptor.MethodFilterInterceptor;/*** * 方法拦截器的实现 继承 MethodFilterInterceptor * @author 1huangzewei * */public class MethodInterceptor extends MethodFilterInterceptor&#123; /** * */ private static final long serialVersionUID = 1L; @Override protected String doIntercept(ActionInvocation invocation) throws Exception &#123; System.out.println(\"方法拦截器被执行\"); return invocation.invoke(); &#125;&#125; 12345678910111213141516&lt;interceptors&gt; &lt;interceptor name=\"MyIntercept\" class=\"com.zhuchuli.myinterceptor.MyInterceptor\"&gt;&lt;/interceptor&gt; &lt;interceptor name=\"loginIntercept\" class=\"com.zhuchuli.myinterceptor.LoginInterceptor\"&gt;&lt;/interceptor&gt; &lt;interceptor name=\"methodInterceptor\" class=\"com.zhuchuli.myinterceptor.MethodInterceptor\"&gt;&lt;/interceptor&gt; &lt;!-- 拦截器栈 --&gt; &lt;interceptor-stack name=\"myStack\"&gt; &lt;interceptor-ref name=\"basicStack\"/&gt; &lt;interceptor-ref name=\"loginIntercept\"/&gt; &lt;interceptor-ref name=\"basicStack\"/&gt; &lt;interceptor-ref name=\"methodInterceptor\"&gt; &lt;!-- 配置哪些方法被拦截 --&gt; &lt;param name=\"includeMethods\"&gt;timer,toSave&lt;/param&gt; &lt;!-- 配置哪些方法不被拦截 --&gt; &lt;param name=\"excludeMethods\"&gt;timer,toSave&lt;/param&gt; &lt;/interceptor-ref&gt; &lt;/interceptor-stack&gt;&lt;/interceptors&gt; 第二十讲 内置拦截器的使用情况。第二十一讲 struts 文件上传（使用默认的内置拦截器） 在大部分应用中都有文件上传的功能。servlet中可以使用第三方插件来实现文件上传：smartfileupload、commons-fileuoload 文件上传步骤 添加jsp页面，注意表单提交必须是post提交，并且设置`enctype=”multipart/form-data” 1234567891011121314&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;文件上传&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=\"upload.action\" method=\"post\" enctype=\"multipart/form-data\"&gt; 文件:&lt;input type=\"file\" name=\"file\"/&gt;&lt;input type=\"submit\" value=\"上传\"&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 添加文件上传处理类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package com.zhuchuli.action;import java.io.File;import java.io.IOException;import org.apache.commons.io.FileUtils;import org.apache.struts2.ServletActionContext;import com.opensymphony.xwork2.Action;/*** * 文件上传处理类 * @author 1huangzewei * */public class UploadAction &#123; //File属性名与表单域相同 类型为File private File file; //上传文件的名称，也是由struts2设置好 //属性名=表单域名+FileName private String fileFileName; //文件类型 = 表单域名+ContentType private String fileContentType; //上传文件的业务方法 public String upload() &#123; //获取上传文件目录 String path=ServletActionContext.getServletContext().getRealPath(\"/upload\"); try &#123; FileUtils.copyFile(file, new File(path,fileFileName)); return Action.SUCCESS; &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; return Action.ERROR; &#125; public File getFile() &#123; return file; &#125; public void setFile(File file) &#123; this.file = file; &#125; public String getFileFileName() &#123; return fileFileName; &#125; public void setFileFileName(String fileFileName) &#123; this.fileFileName = fileFileName; &#125; public String getFileContentType() &#123; return fileContentType; &#125; public void setFileContentType(String fileContentType) &#123; this.fileContentType = fileContentType; &#125; &#125; 添加配置文件 12345678910111213141516171819&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE struts PUBLIC \"-//Apache Software Foundation//DTD Struts Configuration 2.3//EN\" \"http://struts.apache.org/dtds/struts-2.3.dtd\"&gt;&lt;struts&gt; &lt;!-- 设置文件上传的临时目录 --&gt; &lt;constant name=\"struts.multipart.saveDir\" value=\"d:/\"&gt;&lt;/constant&gt; &lt;!-- 常量设置 --&gt;&lt;!-- 设置上传文件总大小 --&gt; &lt;constant name=\"struts.multipart.maxSize\" value=\"67388135\"&gt;&lt;/constant&gt; &lt;package name=\"default\" namespace=\"/\" extends=\"struts-default\"&gt; &lt;action name=\"upload\" class=\"com.zhuchuli.action.UploadAction\" method=\"upload\"&gt; &lt;result&gt;/success.jsp&lt;/result&gt; &lt;result name=\"error\"&gt;/error.jsp&lt;/result&gt; &lt;interceptor-ref name=\"fileupload\"&gt; &lt;!-- 设置上传单个文件的大小 --&gt; &lt;param name=\"maximumSize\"&gt;67388135&lt;/param&gt; &lt;/interceptor-ref&gt; &lt;interceptor-ref name=\"basicStack\"&gt;&lt;/interceptor-ref&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; 第二十二讲 批量文件上传 批量文件下载 Jsp页面 123456789101112131415&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;文件上传&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=\"batch.action\" method=\"post\" enctype=\"multipart/form-data\"&gt; 文件1:&lt;input type=\"file\" name=\"file\"/&gt;&lt;br&gt;文件2:&lt;input type=\"file\" name=\"file\"/&gt;&lt;br&gt;&lt;input type=\"submit\" value=\"上传\"&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;&gt;&gt;* 批量下载业务处理方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package com.zhuchuli.action;import java.io.File;import java.io.IOException;import org.apache.commons.io.FileUtils;import org.apache.struts2.ServletActionContext;import com.opensymphony.xwork2.Action;import com.opensymphony.xwork2.ActionSupport;/*** * 文件上传处理类 * @author 1huangzewei * */public class BatchUploadAction extends ActionSupport&#123; /** * */ private static final long serialVersionUID = 1L; //File属性名与表单域相同 类型为File private File file[]; //上传文件的名称，也是由struts2设置好 //属性名=表单域名+FileName private String fileFileName[]; //文件类型 = 表单域名+ContentType private String fileContentType[]; //上传文件的业务方法 public String upload() &#123; //System.out.println(file+\";\"+fileFileName); //获取上传文件目录 String path=ServletActionContext.getServletContext().getRealPath(\"/upload\"); try &#123; for(var i=0;i&lt;file.length;i++) &#123; FileUtils.copyFile(file[i], new File(path,fileFileName[i])); &#125; return Action.SUCCESS; &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; return Action.ERROR; &#125; public File[] getFile() &#123; return file; &#125; public void setFile(File[] file) &#123; this.file = file; &#125; public String[] getFileFileName() &#123; return fileFileName; &#125; public void setFileFileName(String[] fileFileName) &#123; this.fileFileName = fileFileName; &#125; public String[] getFileContentType() &#123; return fileContentType; &#125; public void setFileContentType(String[] fileContentType) &#123; this.fileContentType = fileContentType; &#125; &#125; struts.xml配置文件 12345678&lt;action name=\"batch\" class=\"com.zhuchuli.action.BatchUploadAction\" method=\"upload\"&gt; &lt;result&gt;/success.jsp&lt;/result&gt; &lt;result name=\"error\"&gt;/error.jsp&lt;/result&gt; &lt;interceptor-ref name=\"fileUpload\"&gt; &lt;param name=\"maximumSize\"&gt;67388135&lt;/param&gt; &lt;/interceptor-ref&gt; &lt;interceptor-ref name=\"basicStack\"&gt;&lt;/interceptor-ref&gt;&lt;/action&gt; 第二十三讲 文件下载 文件下载可以通过超链接直接实现，但是通过超链接直接下载的文件不安全。任何用户得到超链接都可以下载，没法权限的控制。浏览器如果能打开文件，那么浏览会直接将文件打开。 通过流的方式来实现文件下载 业务处理方法 1234567891011121314151617181920212223242526272829303132333435363738394041package com.zhuchuli.action;import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.InputStream;import org.apache.struts2.ServletActionContext;import com.opensymphony.xwork2.Action;/*** * 实现文件下载 * @author 1huangzewei *高等数学 水以v立方厘米/秒的输的灌入圆锥形水箱.水箱尖点朝下 */public class DownloadAction &#123; private String fileName; public String execute() &#123; System.out.println(\"Download\"); return Action.SUCCESS; &#125; public InputStream getInputStream() &#123; String path=ServletActionContext.getServletContext().getRealPath(\"/download\"); try &#123; return new FileInputStream(new File(path,fileName)); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); return null; &#125; &#125; public String getFileName() &#123; return fileName; &#125; public void setFileName(String fileName) &#123; this.fileName = fileName; &#125; &#125; 配置文件 12345&lt;action name=\"download\" class=\"com.zhuchuli.action.DownloadAction\"&gt; &lt;result type=\"stream\"&gt; &lt;param name=\"contentDisposition\"&gt;attachment;filename=$&#123;fileName&#125;&lt;/param&gt; &lt;/result&gt;&lt;/action&gt; jsp页面 123456789101112&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Struts2文件下载&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;a href=\"download.action?fileName=jiaoben5614.rar\"&gt;文件下载&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 第二十四讲 ajax 在Struts2中依然可以使用Servlet中的ajax 12345678910111213141516171819202122232425262728293031package com.zhuchuli.ajax;import java.io.IOException;import javax.servlet.http.HttpServletResponse;import org.apache.struts2.ServletActionContext;public class AjaxAction &#123; private String username; //ajax public String checkName() throws IOException &#123; HttpServletResponse resp=ServletActionContext.getResponse(); System.out.println(\"checkName ---&gt;\" + username); if(\"possible\".equals(username)) &#123; resp.getWriter().print(\"true\"); &#125;else &#123; resp.getWriter().print(\"false\"); &#125; return \"none\"; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; &#125; Struts2对ajax也提供了异步支持，使用步骤 导入相关jar包 编写jsp页面 12345678910111213141516171819202122232425262728293031323334353637383940&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;ajax&lt;/title&gt; &lt;script type=\"text/javascript\" src=\"js/jquery-3.2.1.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; $(function()&#123; $(\"#btn\").click(function()&#123; $.post(\"list.action\",function(data)&#123; console.log(data); var html=\"\"; for(var i=0;i&lt;data.length;i++)&#123; html+=\"&lt;tr&gt;&lt;td&gt;\"+data[i].id+\"&lt;/td&gt;&lt;td&gt;\"+data[i].name+\"&lt;/td&gt;&lt;td&gt;\"+data[i].age+\"&lt;/td&gt;&lt;/tr&gt;\"; &#125; $(\"#content\").html(html); &#125;,'json') &#125;) &#125;) &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;button id=\"btn\"&gt;获取数据&lt;/button&gt; &lt;table width=\"80%\" align=\"center\"&gt; &lt;thead&gt; &lt;tr&gt; &lt;td&gt;编号&lt;/td&gt; &lt;td&gt;姓名&lt;/td&gt; &lt;td&gt;年龄&lt;/td&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody id=\"content\"&gt; &lt;/tbody&gt; &lt;tfoot&gt;&lt;/tfoot&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 编写业务处理方法 123456789101112131415161718192021222324252627282930package com.zhuchuli.ajax;import java.util.ArrayList;import java.util.List;import com.opensymphony.xwork2.Action;import com.zhuchuli.vo.User;public class JsonAction &#123; private List&lt;User&gt; list; //获取数据 public String list() &#123; list=new ArrayList&lt;User&gt;(); list.add(new User(1,\"张三\",19)); list.add(new User(2,\"李四\",20)); list.add(new User(3,\"possible\",16)); for(User u:list) &#123; System.out.println(u.getId()+\"--&gt;\"+u.getName()+\"--&gt;\"+u.getAge()); &#125; return Action.SUCCESS; &#125; public List&lt;User&gt; getList() &#123; return list; &#125; public void setList(List&lt;User&gt; list) &#123; this.list = list; &#125; &#125; 配置文件 12345678910111213&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE struts PUBLIC \"-//Apache Software Foundation//DTD Struts Configuration 2.3//EN\" \"http://struts.apache.org/dtds/struts-2.3.dtd\"&gt;&lt;struts&gt; &lt;package name=\"default\" namespace=\"/\" extends=\"json-default\"&gt; &lt;action name=\"checkName\" class=\"com.zhuchuli.ajax.AjaxAction\" method=\"checkName\"&gt;&lt;/action&gt; &lt;action name=\"hello\" class=\"com.zhuchuli.ajax.HelloAction\"&gt;&lt;/action&gt; &lt;action name=\"list\" class=\"com.zhuchuli.ajax.JsonAction\" method=\"list\"&gt; &lt;result type=\"json\"&gt; &lt;param name=\"root\"&gt;list&lt;/param&gt; &lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; 第二十五讲 异常处理 异常处理在实际的应用开发中必不可少。比如：开发中不能直接将错误信息展示给用户看，需要对其进行处理，给用户一个更友好的提示。 异常处理类 123456789101112131415package com.zhuchuli.action;import com.opensymphony.xwork2.Action;import com.zhuchuli.exception.UserException;import com.zhuchuli.service.UserServiceImpl;import com.zhuchuli.service.Userserivce;public class UserAction &#123; private Userserivce userService=new UserServiceImpl(); //try-catch 需要通过异步进行处理ss public String delete() throws UserException &#123; userService.delete(0); return Action.SUCCESS; &#125;&#125; 配置文件 12345&lt;action name=\"delete\" class=\"com.zhuchuli.action.UserAction\" method=\"delete\"&gt; &lt;result&gt;/success.jsp&lt;/result&gt; &lt;result name=\"userexp\"&gt;/exp.jsp&lt;/result&gt; &lt;exception-mapping result=\"userexp\" exception=\"com.zhuchuli.exception.UserException\"&gt;&lt;/exception-mapping&gt; &lt;/action&gt; 第二十六讲 Struts最新版","categories":[],"tags":[]},{"title":"Log4j与Junit测试","slug":"Log4j与Junit测试","date":"2019-09-09T08:28:00.000Z","updated":"2019-09-10T02:46:25.461Z","comments":true,"path":"2019/09/09/Log4j与Junit测试/","link":"","permalink":"https://CPWS.github.io/2019/09/09/Log4j与Junit测试/","excerpt":"","text":"Log4j的作用和级别 什么是日志 日志是系统运行过程中的后台输出信息，方便程序员进行系统运行的管控以及Bug查找 什么是Log4j Log4j是一个日志输出插件，专门用来进行日志的管理的。 传统方式获取日志 使用System.out.println(); 问题： 日志信息无法保存。 无法显示完整日志信息。 日志的显示没有级别所有日志混杂在一起显示（无法进行日志信息筛选）。 日志显示格式不友好。 解决：使用Log4j 使用Log4j进行日志管理特点: 日志可以单独保存在文件。 可以获取完整的日志信息。 可以进行日志显示的筛选。 格式友好。 Log4j的使用流程 导入log4j的jar包 配置Log4j的配置文件 log4j的日志级别 FATAL 致命的错误 Error 错误级 WARM 警告级 INFO 信息级 DEBUG 调试级 日志记录器（Logger）org.apache.log4j.Logger类实例的作用是用来取代System.ou或者System.err的日志写出器，主要用来输出日志信息。 可以通过如下几个方式来获取Logger类的实例 根据指定名称来获取一个日志记录器的实例：Logger logger=Logger.getLogger(String name); 根据指定的类信息中的类名来获取一个日志记录器的实例：Logger logger=Logger.getLogger(Class clazz); 获取(Logger)日志实例之后，就可以使用它提供的以下方法来记录日志了： public void debug(Object msg) public void debug(Object msg,Throwable t) public void info(Object msg) public void info(Object msg,Throwable t) public void warn(Object msg) public void warn(Object msg,Throwable t) public void error(Object msg) public void error(Object msg,Throwable t) log4j的日志级别 FATAL 致命的错误 对应的level为0 使用方法logger.fatal() Error 错误级 对应的level为3 使用方法logger.error() WARM 警告级 对应的level为4 使用方法logger.warn() INFO 信息级 对应的level为6 使用方法logger.info() DEBUG 调试级 对应的level为7 使用方法logger.debug() 日志级别的设置是通过在Log4j的配置文件中指定的。 日志输出目的地（Appender）Appender的功能是把格式好的日志信息输出到指定的目的地。 日志目的地通过Log4j配置文件来指定的。 对于不同的日志目的地，Log4j提供不同的Appender实现类，常用的Appender实现类包括： 用于控制台的org.apache.log4j.ConsoleAppender。 用于文件的org.apache.log4j.FileAppender。 org.apache.log4j.RollingFileAppender–文件到达指定大小时产生一个新的文件。 org.apache.log4j.DailyRollingFileAppender – 每天产生一个日志文件。 用于以流格式发送到任意位置的org.apache.log4j.WriterAppender。 用于添加到数据库的org.apache.log4j.jdbc.JDBCAppender。 用于邮件发送的org.apache.log4j.net.SMTPAppender。 通过在配置文件中指定不同的Appender实现类，就可以让日志内容输出到相应的目的地。 日志格式化器（Layout）Layout用来把日志信息按指定的格式格式化字符串。而具体的格式是通过log4j的配置文件来配置的。 Log4j中提供用来格式化输出结果的各种布局实现类，包括： org.apache.log4j.SimpleLayout：简单输出。此布局的输出中仅包含日志消息的层次，紧跟着“-”，然后是日志消息字符串。 org.apache.log4j.PatternLayout：模式布局。可以根据指定的模式字符串来决定消息的输出格式。它是一种最常用的一种格式化字符串。 org.apache.log4j.TTCCLayout：日志的格式包含产生的日期，线程，类别等信息。 org.apache.log4j.HTMLLayout：以HTML表格形式布局。 org.apache.xml.XMLLayout：以XML形式布局。 Log4j的使用 Log4j的配置文件：“XMl格式的文件”，“Java属性文件:log4j.properties(键=值)” Log4j.properties log4j.xml 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE log4j:configuration SYSTEM \"log4j.dtd\"&gt;&lt;!--日志级别以及优先级排序: OFF &gt; FATAL &gt; ERROR &gt; WARN &gt; INFO &gt; DEBUG &gt; TRACE &gt; ALL --&gt;&lt;!--Configuration后面的status，这个用于设置log4j2自身内部的信息输出，可以不设置，当设置成trace时，你会看到log4j2内部各种详细输出--&gt;&lt;!--monitorInterval：Log4j能够自动检测修改配置 文件和重新配置本身，设置间隔秒数--&gt;&lt;configuration status=\"WARN\" monitorInterval=\"30\"&gt; &lt;!--先定义所有的appender--&gt; &lt;!--设置日志目的地类型和日志格式化器--&gt; &lt;appenders&gt; &lt;!--这个输出控制台的配置--&gt; &lt;console name=\"Console\" target=\"SYSTEM_OUT\"&gt; &lt;!--输出日志的格式--&gt; &lt;PatternLayout pattern=\"[%d&#123;HH:mm:ss:SSS&#125;] [%p] - %l - %m%n\"/&gt; &lt;/console&gt; &lt;!--文件会打印出所有信息，这个log每次运行程序会自动清空，由append属性决定，这个也挺有用的，适合临时测试用--&gt; &lt;File name=\"log\" fileName=\"log/test.log\" append=\"false\"&gt; &lt;PatternLayout pattern=\"%d&#123;HH:mm:ss.SSS&#125; %-5level %class&#123;36&#125; %L %M - %msg%xEx%n\"/&gt; &lt;/File&gt; &lt;!-- 这个会打印出所有的info及以下级别的信息，每次大小超过size，则这size大小的日志会自动存入按年份-月份建立的文件夹下面并进行压缩，作为存档--&gt; &lt;RollingFile name=\"RollingFileInfo\" fileName=\"$&#123;sys:user.home&#125;/logs/info.log\" filePattern=\"$&#123;sys:user.home&#125;/logs/$$&#123;date:yyyy-MM&#125;/info-%d&#123;yyyy-MM-dd&#125;-%i.log\"&gt; &lt;!--控制台只输出level及以上级别的信息（onMatch），其他的直接拒绝（onMismatch）--&gt; &lt;ThresholdFilter level=\"info\" onMatch=\"ACCEPT\" onMismatch=\"DENY\"/&gt; &lt;PatternLayout pattern=\"[%d&#123;HH:mm:ss:SSS&#125;] [%p] - %l - %m%n\"/&gt; &lt;Policies&gt; &lt;TimeBasedTriggeringPolicy/&gt; &lt;SizeBasedTriggeringPolicy size=\"100 MB\"/&gt; &lt;/Policies&gt; &lt;/RollingFile&gt; &lt;RollingFile name=\"RollingFileWarn\" fileName=\"$&#123;sys:user.home&#125;/logs/warn.log\" filePattern=\"$&#123;sys:user.home&#125;/logs/$$&#123;date:yyyy-MM&#125;/warn-%d&#123;yyyy-MM-dd&#125;-%i.log\"&gt; &lt;ThresholdFilter level=\"warn\" onMatch=\"ACCEPT\" onMismatch=\"DENY\"/&gt; &lt;PatternLayout pattern=\"[%d&#123;HH:mm:ss:SSS&#125;] [%p] - %l - %m%n\"/&gt; &lt;Policies&gt; &lt;TimeBasedTriggeringPolicy/&gt; &lt;SizeBasedTriggeringPolicy size=\"100 MB\"/&gt; &lt;/Policies&gt; &lt;!-- DefaultRolloverStrategy属性如不设置，则默认为最多同一文件夹下7个文件，这里设置了20 --&gt; &lt;DefaultRolloverStrategy max=\"20\"/&gt; &lt;/RollingFile&gt; &lt;RollingFile name=\"RollingFileError\" fileName=\"$&#123;sys:user.home&#125;/logs/error.log\" filePattern=\"$&#123;sys:user.home&#125;/logs/$$&#123;date:yyyy-MM&#125;/error-%d&#123;yyyy-MM-dd&#125;-%i.log\"&gt; &lt;ThresholdFilter level=\"error\" onMatch=\"ACCEPT\" onMismatch=\"DENY\"/&gt; &lt;PatternLayout pattern=\"[%d&#123;HH:mm:ss:SSS&#125;] [%p] - %l - %m%n\"/&gt; &lt;Policies&gt; &lt;TimeBasedTriggeringPolicy/&gt; &lt;SizeBasedTriggeringPolicy size=\"100 MB\"/&gt; &lt;/Policies&gt; &lt;/RollingFile&gt; &lt;/appenders&gt; &lt;!--设置根记录器--&gt; &lt;root&gt; &lt;!--设置级别--&gt; &lt;level value=\"DEBUG\" /&gt; &lt;!--设置目的地--&gt; &lt;appender-ref ref=\"STDOUT\"/&gt; &lt;appender-ref ref=\"File\"&gt; &lt;/root&gt; &lt;!--然后定义logger，只有定义了logger并引入的appender，appender才会生效--&gt; &lt;loggers&gt; &lt;!--过滤掉spring和mybatis的一些无用的DEBUG信息--&gt; &lt;logger name=\"org.springframework\" level=\"INFO\"&gt;&lt;/logger&gt; &lt;logger name=\"org.mybatis\" level=\"INFO\"&gt;&lt;/logger&gt; &lt;root level=\"all\"&gt; &lt;appender-ref ref=\"Console\"/&gt; &lt;appender-ref ref=\"RollingFileInfo\"/&gt; &lt;appender-ref ref=\"RollingFileWarn\"/&gt; &lt;appender-ref ref=\"RollingFileError\"/&gt; &lt;/root&gt; &lt;/loggers&gt; &lt;/configuration&gt; Log4j在默认的情况下，会首先查找使用log4j.xml的配置，然后再去查找log4j.properties。 log4j的配置文件必须放置于项目的类路径（ClassPath）下。 在Java中使用Log4j打印日志信息的步骤如下： 得到记录器。 public static Logger logger=Logger.getLogger(String name); static Logger logger=Logger.getLogger(Test.class.getName()); 读取配置文件。 BasicConfigurator.configure(); //自动快速的使用默认的log4j环境 PropertyConfigurator.configure(String configFileName);//读取使用Java的特性文件编写的配置文件。 插入记录信息。 Logger.debug(Object message);Junit单元测试Junit-概述Junit-环境设置Junit-基本用法Junit-APIJunit-编写测试Junit-使用断言Junit-执行过程Junit-执行测试Junit-囊括测试Junit-忽略测试","categories":[],"tags":[]},{"title":"正则表达式","slug":"正则表达式","date":"2019-09-08T01:36:32.000Z","updated":"2019-09-09T09:39:24.456Z","comments":true,"path":"2019/09/08/正则表达式/","link":"","permalink":"https://CPWS.github.io/2019/09/08/正则表达式/","excerpt":"","text":"正则表达式基本知识 基本语法 高级语法 练习 editplus,notpad++,ultraedit,eclipse中使用正则表达式 正则表达式（Regular Expression）简介 为什么需要使用正则表达式？ 文本的复杂处理。 正则表达式的优势和用途 一种强大而灵活的文本处理工具。 大部分编程语言、数据库、文本编辑器、开发环境都支持正则表达式。 正则表达式定义 正如他的名字一样是描述一种规则，通过这个规则可以匹配一类字符串。 学习正则表达式很大程度上就是学习正则表达式的语法规则。 开发中使用正则表示的流程 分析所要匹配的数据，写出测试用的典型数据。 在工具软件中进行匹配测试。 在程序中调用通过测试的正则表达式。 正则表达式基本语法 普通字符 字母、数字、汉字、下划线、以及没有特殊定义的标点符号，都是“普通字符”。表达式中的普通字符，在匹配一个字符串的时候，匹配与之相同的一个字符。 简单转义字符 \\n 代表换行符 \\t 制表符 \\ 代表\\本身 ^,$,.,{,},?,+,*,|,[,] 匹配这些字符创本身 标准字符集合： 能够与“多种字符”匹配的表达式 主义区分大小写，大写是相反的意思。 \\d 任意一个数字，0-9中的任意一个。 \\w 任意一个字母或数字或下划线，也就是A-Z,a-z,0-9,_中任意一个。 \\s 包括空格、制表符、换行符等空白字符的其中任意一个。 . 小数点可以匹配任意一个字符（除了换行符）如果要匹配在”\\n”在内的所有字符，一般用[\\s\\S]。 [\\s\\S] 匹配包含“\\n”在内所有字符串 自定义字符集合 []方括号匹配方式，能够匹配方括号中任意一个字符. [ab5@]：匹配”a”或”b”或”5”或”@” [^abc]：匹配”a”，”b”，”c”之外的任意一个字符 [f-k]：匹配日”f”-“k”之间的任意一个字符 [^A-f0-3]：匹配”A”-“F”，”0”-“3’之外的任意一个字符 正则表达式的特殊符号，被包含到中括号中，则失去特殊意义，除了^,-之外。 标准字符集合，处理小数点之外，如果被包含于中括号，自定义字符集合将包含该集合。 [\\d.-+]讲匹配数组，小数点 + - 量词（Quantifier） 修饰匹配次数的特殊符号 {n} 表达重复n次 {m，n} 表达至少重复m次，最多重复n次 {m,} 表达至少重复m次 ? 匹配表达式0次或1次，相当于{0,1} + 表达式至少出现1线，相当{1,} * 表达式不会出现或出现任意次，{0，} 匹配次数中的贪婪模式（匹配字符越多越好，默认！）。 匹配次数中的非贪婪模式（匹配字符越少越好，修饰匹配次数的特殊符号后再加上一个”?”号）。 字符边界 （本组编辑匹配的不是字符而是位置，符合某种条件的位置）() ^ 与字符串开始的位置匹配 $ 与字符串结束的地方配置 \\b 匹配一个当前的边界 \\b匹配这样一个位置，前面的字符和后面的字符不全是\\w 选择符和分组 表达式 作用 ` `分支结构 ()捕获组 (1)在被修饰匹配次数的时候，括号中的表达式可以作为整体被修饰(2)取得匹配结果的时候，括号中的表达式匹配到的内容可以被单独得到(3)每个括号会分配一个编号，使用（）的捕获根据左括号的顺序从1开始自动编号。捕获元素编号为0的第一个捕获是由整个正则表达式模式匹配的文本 非捕获组（?:Exception）（?:([a-z]{2})） 一些表达式中，不得不使用()，但又不需要保存()中子表达式匹配的内容，这时候可以使用非捕获组来抵消使用()带来的副作用。 反向引用（\\nnn）： 每一个()都会分配一个编号，使用（）的捕获根据左括号的顺序从1开始自动编导。 通过反向作用，可以对分组已捕获的字符串进行引用。 正则表达式的匹配模式 INGORECASE 忽略大小写模式 匹配时忽略大小写。 默认情况下，正则表达式是要区分大小写的。 SIGNLELINE 单行模式 整个文本看做是一个字符串，只有一个开头，一个结尾。 使小数点“.”可以匹配包含“\\n”在内的任意字符。 MULTILINE 多行模式 每行都是一个字符串，都有开头和结尾。 在指定了MULTILINE之后，如果需要仅匹配字符串开始和结束位置，可以使用\\A和\\Z 预搜索（零宽断言）（环视） 占有字符还是零宽度，是针对匹配的内容是否保存到最终的匹配结果中而言的。 零宽断言的几种方式 (?=exp)：断言自身出现的位置的后面能匹配表达式exp。 (?&lt;=exp&gt;):断言自身出现的位置的前面能匹配表达式exp。 (?!exp):断言此位置的后面不能匹配exp。 (?&lt;!exp&gt;):断言此位置的前面不能匹配表达式exp。 正则表达式的应用 电话号码的应用 电话号码有数字和”-“构成。 电话号码为7到8位。 如果电话号码中包含有取号，那么区号为三位或四位，首位为0。 区号用”-“和其它部分隔开。 移动电话号码为11位 11位一定电话号码的第一位和第二位为”13“、”15“、”18“ 结果：(0\\d{2,3}-\\d{7,9})|(1[35789]\\d{9}) 电子邮件的地址验证 用户名：字母，数字，下划线，中划线组成 @ 网址：字母、数字组成 小数点 . 组织域名：2-4字母组成 不区分大小写 结果 [\\w-]+@[a-z0-9A-Z]+(.[A-Za-z]{2,3}){1,2} Java程序中使用正则表达式 相关类位于：java.util.regex包下面 类pattern： 正则表达式的编译表示形式。 Pattern p=Pattern.compile(r,int);//建立正则表达式，并启动响应模式 类matcher： 通过解释Pattern对character sequence执行匹配操作的引擎。 Matcher m=p.matcher(str);//匹配str字符串 Java模拟编程的原理123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package regular;import java.io.BufferedReader;import java.io.InputStreamReader;import java.net.URL;import java.util.ArrayList;import java.util.List;import java.util.regex.Matcher;import java.util.regex.Pattern;/*** * 网络爬虫取连接 * @author 1huangzewei * */public class webSpiderTest &#123; //获得urlStr网页的源代码 public static String getURLContent(String urlStr) &#123; StringBuilder sb=new StringBuilder(); try &#123; URL url=new URL(urlStr); BufferedReader reader=new BufferedReader(new InputStreamReader(url.openStream())); String temp=\"\"; while((temp=reader.readLine())!=null) &#123; sb.append(temp); &#125; &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; return sb.toString(); &#125; public static List&lt;String&gt; getMatcher(String destStr,String regex) &#123; List&lt;String&gt; result=new ArrayList&lt;String&gt;(); //Pattern p=Pattern.compile(\"&lt;a[\\\\s\\\\S]+?&lt;/a&gt;\");//找到超链接 Pattern p = Pattern.compile(regex);//找到a href; Matcher m = p.matcher(destStr); while (m.find()) &#123; result.add(m.group(1)); &#125; return result; &#125; public static void main(String[] args) &#123; String destStr=getURLContent(\"http://163.com\"); //List&lt;String&gt; list=getMatcher(destStr,\"href=\\\"([\\\\s\\\\S]+?)\\\"\"); //List&lt;String&gt; list=getMatcher(destStr,\"(&lt;img+[\\\\S\\\\s]+?)&gt;\"); List&lt;String&gt; list=getMatcher(destStr,\"data-original=\\\"([\\\\s\\\\S]+?)\\\"\"); for(String temp:list) &#123; System.out.println(temp); &#125; &#125;&#125;","categories":[],"tags":[]},{"title":"注解与反射","slug":"注解与反射","date":"2019-09-02T08:08:40.000Z","updated":"2019-09-05T11:28:08.710Z","comments":true,"path":"2019/09/02/注解与反射/","link":"","permalink":"https://CPWS.github.io/2019/09/02/注解与反射/","excerpt":"","text":"注解入门 Annotation是JDK5.0开始引入的新技术 Annotation的作用 不是程序本身，可以对程序作出解释。 可以被其他程序（比如：编译器等）读取。（注解信息处理流程，是注解和注释的重大区别。如果没有注解信息处理流程，则注解毫无意义）。 Annotation格式 注解是以“@注释名”在代码中存在的，可以添加一些参数值，例如：@SeppressWarnings(value=”unchecked”)。 Annotation在哪里使用？ 可以附加在package，class，method，field等上面，相当于它它们添加了额外的辅助信息，我们可以通过反射机制编程实现对这些数据的访问。 内置注解 @Override：定义在java.lang.Override中，此注释只适用修饰方法，表示一个方法声明打算重写超类中的另一个方法声明。 @Deprecated：定义在java.lang.Deprecated中，此注释可以用于修饰方法、属性、类，表示不鼓励程序员使用这样的元素，通常是因为它很危险吗或存在更好的选择。（一般不建议使用） @SuppressWarnings：用来抑制编译器运行时的警告信息。 @SuppressWarnings(&quot;unchecked&quot;)告诉编译器忽略 unchecked 警告信息，如使用List，ArrayList等未进行参数化产生的警告信息。 @SuppressWarnings(&quot;serial&quot;)如果编译器出现这样的警告信息：The serializable class WmailCalendar does not declare a static final serialVersionUID field of type long 使用这个注释将警告信息去掉。 @SuppressWarnings(&quot;deprecation&quot;)如果使用了使用@Deprecated注释的方法，编译器将出现警告信息。 使用这个注释将警告信息去掉。 @SuppressWarnings(&quot;unchecked&quot;, &quot;deprecation&quot;)告诉编译器同时忽略unchecked和deprecation的警告信息。 @SuppressWarnings(value={&quot;unchecked&quot;, &quot;deprecation&quot;})等同于@SuppressWarnings(“unchecked”, “deprecation”) 自定义注解、元注解元注解 @Target 作用：用于描述注解的使用范围 |所修饰的范围|取值ElemnetType||-|-|-||package包|PACKAGE||类、接口、枚举、Annotation类型|TYPE||类型成员（方法、构造器、成员变量、枚举值）|CONSTRUCTOR：用于描述构造器。FIELD：用于描述域METHOD：用于描述方法||方法参数和本地变量|LOCAL_VALUE：用于描述局部变量PARANETER：用于描述参数| @Target(value=ElementType.Type) @Retention 作用：表示需要在什么级别保存该注解，用于描述注解的生命周期。 取值 RetentionPolicy 作用 SOURCE 在源文件中有效（即源文件保存） CLASS 在class文件中有效（即class保留） RUNTIME 在运行时有效（即运行时保留）为Runtime可以被反射机制读取 注意： 注解元素的参数的默认值一般设置为0或空字符窜； 也可能是-1，表示什么也没有 @Documented 作用：用于描述其它类型的annotation应该被作为被标注的程序成员的公共API，因此可以被例如javadoc此类的工具文档化。它是一个标记注解，没有成员。 @Inherited 作用：用于表示某个被标注的类型是被继承的。如果一个使用了@Inherited修饰的annotation类型被用于一个class，则这个annotation将被用于该class的子类 反射机制读取注解 什么是ORM（Object Relationship Mapping） 类和表结构对应 属性和字段对应 对象和记录对应 使用注解完成类和表结构的映射关系 学了反射机制后，我们可以定义注解的执行流程读取这些注解，实现更复杂的功能 123456789101112package annotation;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target; @Target(value = ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)public @interface Table &#123; String value();&#125; 1234567891011121314package annotation;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Target(value = ElementType.FIELD)@Retention(RetentionPolicy.RUNTIME)public @interface Field &#123; String columnName(); String type(); int length();&#125; 123456789101112131415161718192021222324252627282930package annotation;@Table(\"tb_student\")public class Student &#123; @Field(columnName=\"id\",type=\"int\",length=3) private int id; @Field(columnName=\"sname\",type=\"varchar\",length=10) private String studentName; @Field(columnName=\"age\",type=\"int\",length=10) private int age; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getStudentName() &#123; return studentName; &#125; public void setStudentName(String studentName) &#123; this.studentName = studentName; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; &#125; 1234567891011121314151617181920212223242526272829303132package annotation;import java.lang.annotation.Annotation;/** * 使用反射处理注解信息，模拟处理注解信息的流程 * @author 1huangzewei * */public class Demo3 &#123; public static void main(String[] args) &#123; try &#123; Class clazz=Class.forName(\"annotation.Student\"); //获取类所有有效的注解 Annotation[] annotations=clazz.getAnnotations(); for(Annotation a:annotations) &#123; System.out.println(a); &#125; //获取指定的注解 Table table=(Table) clazz.getAnnotation(Table.class); System.out.println(table.value()); //获取类的属性的注解 Field f=clazz.getDeclaredField(\"studentName\").getAnnotation(Field.class); System.out.println(f.columnName() + \"---&gt;\" + f.type() + \"---&gt;\" + f.length()); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125; Java的动态性 动态语言：程序运行时，可以改变程序结果或变量类。 Java可以称为准动态语言。 反射机制 reflection 指的是可以于运行时加载、探知、使用编译期间完全未知的类。 程序在运行状态中，可以动态加载一个只有名称的类，对于任意一个已加载的类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性。 1Class c=Class.forName(\"包名.类名\"); 加载完类之后，在堆内存中，就产生了一个Class类型的对象（一个类只有一个Class对象），这个对象就包含了完整的类的结构信息。我们可以通过这个对象看到类的结构。这个对象就像一面镜子，通过这个镜子可以看到类的结构，所以我们形象的称之为：反射。 Class类的对象如何获取 运用getClass() 运用Class.forName()（最常被使用） 运用类.class 123456789101112131415161718192021222324252627282930313233343536package com.zhuchuli.reflection;import com.zhuchuli.testBean.User;/*** * 测试java.lang.Class对象的获取方式。 * 测试各种数据类型java.lang.Class对象的获取方式。 * 1.利用类.class * 2.利用类.getClass() * 3.利用Class.forName() * @author 1huangzewei * */@SuppressWarnings(\"all\")public class Demo01 &#123; public static void main(String[] args) &#123; String path= \"com.zhuchuli.testBean.User\"; try &#123; Class clazz = Class.forName(path); //对象是表示或封装一些数据。一个类被加载之后，Jvm会创建一个对应该类的Class对象，类的整个结构信息会放到对象的Class对象中。 //这个Class对象就像一面镜子一样，通过这个镜子，我们可以看到类的全部信息。 System.out.println(clazz.hashCode()); //获取Class对象的三种方式 Class strClazz=String.class; Class strClazz2=path.getClass(); System.out.println(strClazz==strClazz2); //基本数据类型 Class intClaszz=int.class; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 反射机制的常见作用 动态加载类、动态获取类的信息（属性、方法、构造器） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package com.zhuchuli.reflection;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.Method;/*** * 应用反射API，获取类的信息（类的名字、属性、方法、构造器等） * @author 1huangzewei * */public class Demo02 &#123; public static void main(String[] args) &#123; String path= \"com.zhuchuli.testBean.User\"; try &#123; Class clazz = Class.forName(path); //获取类的名字 System.out.println(\"---------------------------------通过反射获取类名---------------------------------\"); System.out.println(clazz.getName());//获得包名+类名 com.zhuchuli.testBean.User System.out.println(clazz.getSimpleName());//获得类名 User System.out.println(\"------------------------------------------------------------------------------\"); //获取属性信息 System.out.println(\"---------------------------------通过反射获取属性---------------------------------\"); //Field[] fields=clazz.getFields();//只能获取public的属性 Field[] fields=clazz.getDeclaredFields();//获得所有的field Field f=clazz.getDeclaredField(\"uname\"); System.out.println(f); for(Field field:fields) &#123; System.out.println(\"属性：\"+field); &#125; System.out.println(\"------------------------------------------------------------------------------\"); //获取方法信息 System.out.println(\"---------------------------------通过反射获取方法---------------------------------\"); Method[] methods=clazz.getMethods();//只能获取public修饰的方法 Method[] methodss=clazz.getDeclaredMethods();//获取所有的方法 Method m01=clazz.getDeclaredMethod(\"getUname\", null); System.out.println(m01); Method m02=clazz.getDeclaredMethod(\"setUname\", String.class);//如果方法有参数，则必须指明参数的类型，即参数类型.class System.out.println(m02); for(Method method:methodss) &#123; System.out.println(\"方法：\"+method); &#125; System.out.println(\"------------------------------------------------------------------------------\"); //获取构造器信息 System.out.println(\"---------------------------------通过反射获取构造器---------------------------------\"); Constructor[] constructors=clazz.getConstructors();//获取public修饰的构造器 Constructor[] constructorss=clazz.getDeclaredConstructors(); for(Constructor constructor:constructorss) &#123; System.out.println(\"构造器：\"+constructor); &#125; System.out.println(\"根据参数类型获取构造器\"); Constructor c=clazz.getDeclaredConstructor(null); System.out.println(\"构造器：\"+c); Constructor cc=clazz.getConstructor(int.class,String.class,int.class); System.out.println(\"构造器：\"+cc); System.out.println(\"------------------------------------------------------------------------------\"); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 动态构造对象 动态调用类和对象的任意方法、构造器 动态调用和处理属性 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.zhuchuli.reflection;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.Method;import com.zhuchuli.testBean.User;/*** * 通过反射API动态的操作：构造器，方法和属性 * @author 1huangzewei * */public class Demo03 &#123; public static void main(String[] args) &#123; //动态操作构造器 String path= \"com.zhuchuli.testBean.User\"; try &#123; Class clazz = Class.forName(path); //通过反射API调用构造方法，构造对象 User u=(User) clazz.getConstructor().newInstance();//其实调用JavaBean的无参数构造器 System.out.println(u); Constructor&lt;User&gt; c=clazz.getConstructor(int.class,String.class,int.class); User u2=c.newInstance(1001,\"lee\",18); System.out.println(u2.getId()+\"--\"+u2.getUname()+\"--\"+u2.getAge()); //通过反射API调用普通方法 User u3=(User) clazz.getConstructor().newInstance(); Method method=clazz.getDeclaredMethod(\"setUname\", String.class); method.invoke(u3, \"lee2\");//类似于u3.setUname=\"lee2\" System.out.println(u3.getUname()); //通过反射API调用属性 User u4=(User) clazz.getConstructor().newInstance(); Field f=clazz.getDeclaredField(\"uname\"); f.setAccessible(true);//这个属性不需要做安全检查，可以直接访问。 f.set(u4, \"lee3\");//通过放射获取属性的值 System.out.println(u4.getUname()); System.out.println(f.get(u4));//通过反射读取对象的值 &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 获取泛型信息（Generic） Java使用泛型擦除机制来引入泛型。Java中的泛型仅仅是给编译器JavaC使用的，确保数据的安全性和免去强制类型转换的麻烦。但是编译一旦完成，所有和泛型有关的类全部被擦除。 为了通过反射操作这些类型以迎合实际开发的需要，Java新增了PatameterType，GenericArrayType，TypeVariable，和WildCardType几种类型来代表不能被归一到Class类中的类型但是又和原始类型齐名的类型。 ParameterizedType:表示一种参数化的类型，比如Collection&lt; String &gt;. GenericArrayType:表示一种元素类型是参数化类型或者类型变量的数组类型. TypeVariable:是各种类型变量的公共父接. WildcardType:代表一种通配符类型表达式，比如？、？ extends Number、？ super Integer。（wildcard是一个单词：就是”通配符“）. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package com.zhuchuli.reflection;import java.lang.reflect.Method;import java.lang.reflect.ParameterizedType;import java.lang.reflect.Type;import java.util.List;import java.util.Map;import com.zhuchuli.testBean.User;/*** * 通过反射获取泛型信息 * @author 1huangzewei * */public class Demo04 &#123; public void test01(Map&lt;String,User&gt; map,List&lt;User&gt; list) &#123; System.out.println(\"Demo04 test01()\"); &#125; public Map&lt;Integer,User&gt; test02()&#123; System.out.println(\"Demo01 test02()\"); return null; &#125; public static void main(String[] args) &#123; try &#123; //获取执行方法参数的泛型信息 Method method = Demo04.class.getDeclaredMethod(\"test01\", Map.class, List.class); Type[] t=method.getGenericParameterTypes(); for(Type paramType:t) &#123; System.out.println(\"#\"+paramType); if(paramType instanceof ParameterizedType) &#123; //获取泛型中的具体信息 Type[] genericTypes = ((ParameterizedType) paramType).getActualTypeArguments(); for(Type genericType:genericTypes) &#123; System.out.println(\"泛型类型：\" + genericType); &#125; &#125; &#125; //获取指定方法返回值泛型信息 Method method2=Demo04.class.getDeclaredMethod(\"test02\",null); Type returnType=method2.getGenericReturnType(); if(returnType instanceof ParameterizedType) &#123; //获取泛型中的具体信息 Type[] genericTypes = ((ParameterizedType) returnType).getActualTypeArguments(); for(Type genericType:genericTypes) &#123; System.out.println(\"泛型类型：\" + genericType); &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 处理注解：功能与案例代码与上面雷同。 反射机制的性能问题 setAccessible 启动和禁用访问安全检查的机关，值为true则指示反射的对象在使用时应该取消Java语言访问检查。值为false则指示表明反射的对象应该实施Java语言访问检查。并不是为true就能访问为false就不能访问。 禁止安全检查，可以提高反射的运行速度。 可以考虑使用：cglib/javaassist字节码操作 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.zhuchuli.reflection;import java.lang.reflect.Method;import com.zhuchuli.testBean.User;public class Demo05 &#123; public static void test01() &#123; User user=new User(); long before=System.currentTimeMillis(); for(var i=0;i&lt;1000000000L;i++) &#123; user.getUname(); &#125; long after=System.currentTimeMillis(); System.out.println(\"没有反射，共消耗：&lt;\"+(after-before)+\"&gt;毫秒\"); &#125; public static void test02() throws Exception &#123; User user=new User(); Method method=Class.forName(\"com.zhuchuli.testBean.User\").getDeclaredMethod(\"getUname\", null); long before=System.currentTimeMillis(); for(var i=0;i&lt;1000000000L;i++) &#123; method.invoke(user, null); &#125; long after=System.currentTimeMillis(); System.out.println(\"加安全检查，共消耗：&lt;\"+(after-before)+\"&gt;毫秒\"); &#125; public static void test03() throws Exception &#123; User user=new User(); Method method=Class.forName(\"com.zhuchuli.testBean.User\").getDeclaredMethod(\"getUname\", null); method.setAccessible(true); long before=System.currentTimeMillis(); for(var i=0;i&lt;1000000000L;i++) &#123; method.invoke(user, null); &#125; long after=System.currentTimeMillis(); System.out.println(\"不加安全检查，共消耗：&lt;\"+(after-before)+\"&gt;毫秒\"); &#125; public static void main(String[] args) throws Exception &#123; test01(); test02(); test03(); &#125;&#125; 动态编译 Java6.0引入了动态编译机制 动态编译的应用场景 可以做一个浏览器端编写java代码，上传服务器编译和运行的在线测评系统。 服务器动态加载某些类文件进行编译。 动态编译的两种方式 通过Runtime调用javac，启动新的进程去操作 Runtime run=Runtime.getRuntime(); Process process=run.exec(javac -cp d:/myjava/ HelloWorld.java); 通过JavaCompiler动态编译 123456789101112131415161718192021222324package com.zhuchuli.test;import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.FileReader;import java.io.FileWriter;import java.io.IOException;import javax.tools.JavaCompiler;import javax.tools.ToolProvider;public class Demo01 &#123; public static void main(String[] args) throws IOException &#123; String str=\"public class Hi&#123;public static void main(String[] args[]) &#123;System.out.println(\\\"Hello Hi haha\\\");&#125;&#125;\"; BufferedWriter br=new BufferedWriter(new FileWriter(\"d:/MyJava/Hi.java\")); br.write(str); br.flush(); //获得系统编译器，如果使用jre（运行环境）则无法获得编译器 JavaCompiler complier=ToolProvider.getSystemJavaCompiler(); int result=complier.run(null, null, null,\"d:/MyJava/Hi.java\"); System.out.println(result==0?\"编译成功\":\"编译失败\"); br.close(); &#125;&#125; 编译结果 1234567891011121314151617181920212223242526272829303132package com.zhuchuli.test;import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.FileReader;import java.io.FileWriter;import java.io.IOException;import java.io.InputStreamReader;import javax.tools.JavaCompiler;import javax.tools.ToolProvider;public class Demo02 &#123; public static void main(String[] args) throws IOException &#123; String str=\"public class Hi&#123;public static void main(String[] args) &#123;System.out.println(\\\"Hello Hi haha\\\");&#125;&#125;\"; BufferedWriter bw=new BufferedWriter(new FileWriter(\"d:/MyJava/Hi.java\")); bw.write(str); bw.flush(); //获得系统编译器，如果使用jre（运行环境）则无法获得编译器 JavaCompiler complier=ToolProvider.getSystemJavaCompiler(); int result=complier.run(null, null, null,\"d:/MyJava/Hi.java\"); System.out.println(result==0?\"编译成功\":\"编译失败\"); Runtime run=Runtime.getRuntime(); Process process=run.exec(\"java -cp d:/MyJava Hi\"); BufferedReader br=new BufferedReader(new InputStreamReader(process.getInputStream())); String info=\"\"; while((info=br.readLine())!=null) &#123; System.out.println(info); &#125; &#125;&#125; 编译结果 通过反射机制，启动新的线程去执行 12345678910111213141516171819202122232425262728293031323334353637383940414243package com.zhuchuli.test;import java.io.BufferedWriter;import java.io.FileWriter;import java.io.IOException;import java.lang.reflect.Method;import java.net.URL;import java.net.URLClassLoader;import javax.tools.JavaCompiler;import javax.tools.ToolProvider;/** * 通过反射机制调用执行类 * @author 1huangzewei * */public class Demo03 &#123; public static void main(String[] args) throws IOException &#123; String str=\"public class Hi&#123;public static void main(String[] args) &#123;System.out.println(\\\"Hello Hi haha\\\");&#125;&#125;\"; BufferedWriter bw=new BufferedWriter(new FileWriter(\"d:/MyJava/Hi.java\")); bw.write(str); bw.flush(); //获得系统编译器，如果使用jre（运行环境）则无法获得编译器 JavaCompiler complier=ToolProvider.getSystemJavaCompiler(); int result=complier.run(null, null, null,\"d:/MyJava/Hi.java\"); System.out.println(result==0?\"编译成功\":\"编译失败\"); try &#123; URL[] urls=new URL[] &#123;new URL(\"file:/\"+\"d:/MyJava/\")&#125;; URLClassLoader loader=new URLClassLoader(urls); Class c=loader.loadClass(\"Hi\"); Method m=c.getMethod(\"main\", String[].class); m.invoke(null, (Object)new String[] &#123;&#125;); //m.invoke(null,new String[] &#123;\"a\",\"b\"&#125;); //由于可变参数是Java5.0之后才有。上面的代码会被运行成;m.invoke(null,\"a\",\"b\")，就发生了参数个数不匹配，从而出现错误,因此要加上(Object)转型，避免出现出错; //public static void mmm(String[] a,String[] b) //public static void main(String[] args); &#125;catch(Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 编译结果 动态执行javascript代码 Java脚本引擎是从JDK6.0之后添加的新功能 脚本引擎介绍 使得Java应用程序可以通过一套固定的接口与各种脚本引擎交互，从而达到在Java平台上调用各种脚本语言的目的。 Java脚本API是连通Java平台和脚本语言的桥梁。 可以把一些复杂异变的业务逻辑交给与脚本语言处理，这又大大提高了开发效率。 获得脚本引擎 ScriptEngineManager sem=new ScriptEngineManager(); ScriptEngine engine=sem.getEngineByName(“javascript”); Java脚本API为开发者提供了如下功能： 获取脚本程序输入，通过脚本引擎运行脚本并返回运行结果，这是最核心的接口。 注意是：接口。Java可以使用各种不同的表现，从而通用的调用js、groovy、python等脚本 js使用了:Rhino，Rhino是一种使用Java语言编写的JavaScript的开源实现，原先是由Mozilla开发，现在被集成进入JDK6.0 通过脚本引擎的运行上下文在脚本和Java平台间交换数据。 通过Java应用程序调用脚本函数。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970package com.zhuchuli.rhino;import java.io.FileNotFoundException;import java.io.FileReader;import java.net.URL;import java.util.List;import javax.script.Invocable;import javax.script.ScriptEngine;import javax.script.ScriptEngineManager;import javax.script.ScriptException;/*** * 测试脚本引擎执行JavaScript代码 * @author 1huangzewei * */public class Demo01 &#123; public static void main(String[] args) throws ScriptException, NoSuchMethodException &#123; //获取脚本引擎对象 ScriptEngineManager sem=new ScriptEngineManager(); ScriptEngine engine=sem.getEngineByName(\"javascript\"); //定义变量，存储到引擎上下文中 engine.put(\"msg\", \"lee is a good student\"); String str=\"var user= &#123;name:'aaa',age:18,schools:['gdaib','dgef']&#125;;\"; str += \"print(user.schools);\"; //执行脚本 engine.eval(str); //修改msg的值 engine.eval(\"msg='very happy today'\"); System.out.println(engine.get(\"msg\")); System.out.println(\"--------------------\"); //定义函数 engine.eval(\"function add(a,b)&#123;var sum=a+b;return sum;&#125;\"); //执行js函数 取得调用接口 Invocable jsInvoke=(Invocable) engine; //执行脚本中定义的方法 Object i=jsInvoke.invokeFunction(\"add\", new Object[] &#123;10,20&#125;); System.out.println(i); //导入其他java包，使用其他包中的java类 String jsCode=\"var list=java.util.Arrays.asList([\\\"北京尚学堂\\\",\\\"北京大学\\\"]);\"; engine.eval(jsCode); List&lt;String&gt; list2=(List&lt;String&gt;) engine.get(\"list\"); for(String temp:list2) &#123; System.out.println(temp); &#125; //执行一个JS文件 URL url=Demo01.class.getClassLoader().getResource(\"a.js\"); try &#123; FileReader fr = new FileReader(url.getPath()); engine.eval(fr); fr.close(); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125; 运行结果 动态字字节码操作：javaassist Java动态性的两种常见实现方式： 字节码操作 反射 运行时操作字节码可以让我们实现如下功能 动态生成新的类。 动态改变某个类的结构（添加、删除、修改 新的属性、方法 ） 优势 比反射开销小，性能高。 Javaassist性能高于反射，低于ASM 常见的字节码操作类库 BCEL 基于底层Jvm的操作和指令 ASM 基于底层Jvm的操作和指令 CGLIB 基于ASM实现 Javaassist Javaassist库的API详解 javaassist的最外层的API和java的反射包中的API颇为类似。 它主要有CtClass,CtMethod，以及CtField几个类组成。用以执行和JDK反射API中java.lang.Class,java.lang.reflection.Method，java.lang.reflection.Field相同的操作。 JAVAassist库的简单使用。 创建一个全新的类 使用XJAD反编译工具，将生成的class文件反编译成Java文件\\ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.zhuchuli.javaassist;import java.io.IOException;import javassist.CannotCompileException;import javassist.ClassPool;import javassist.CtClass;import javassist.CtConstructor;import javassist.CtField;import javassist.CtMethod;import javassist.NotFoundException;/*** * 测试 使用javaassist动态生成一个新类 * @author 1huangzewei * */public class Demo01 &#123; public static void main(String[] args) throws CannotCompileException, NotFoundException, IOException &#123; //创建一个类池 ClassPool pool=ClassPool.getDefault(); CtClass cc=pool.makeClass(\"com.zhuchuli.bean.Emp\"); //创建属性 CtField f1=CtField.make(\"private String ename;\",cc); CtField f2=CtField.make(\"private int empno;\",cc); cc.addField(f1); cc.addField(f2); //创建方法 CtMethod c1=CtMethod.make(\"public String getEname()&#123;return ename;&#125; \", cc); CtMethod c2=CtMethod.make(\"public void setEname(String ename)&#123;this.ename=ename;&#125; \", cc); cc.addMethod(c1); cc.addMethod(c2); CtMethod c3=CtMethod.make(\"public int getEmpno()&#123;return empno;&#125; \", cc); CtMethod c4=CtMethod.make(\"public void setEmpno(int empno)&#123;this.empno=empno;&#125; \", cc); cc.addMethod(c3); cc.addMethod(c4); //创建构造器 CtConstructor constructor=new CtConstructor(new CtClass[] &#123;pool.get(\"java.lang.String\"), CtClass.intType&#125;, cc); constructor.setBody(\"&#123;this.ename=ename;this.empno=empno;&#125;\"); CtConstructor constructor2=new CtConstructor(null,cc); cc.addConstructor(constructor); cc.addConstructor(constructor2); cc.writeFile(\"d:/MyJava/Emp.java\");//将创建的这一类存放到指定位置上 &#125;&#125; Javaassist的AIP使用 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package com.zhuchuli.javaassist;import java.lang.reflect.Method;import java.util.Arrays;import javassist.ClassPool;import javassist.CtClass;import javassist.CtMethod;import javassist.Modifier;/*** * 测试Javaassist的API * @author 1huangzewei * */public class Demo02 &#123; //处理类的基本用法 public static void test01() &#123; ClassPool pool=ClassPool.getDefault(); try &#123; CtClass cc = pool.get(\"com.zhuchuli.javaassist.Emp\"); //将类转换成字节数组 byte[] bytes=cc.toBytecode(); System.out.println(Arrays.toString(bytes)); System.out.println(cc.getName());//获取类名 System.out.println(cc.getSuperclass());//获取父类 System.out.println(cc.getInterfaces());//获取接口 System.out.println(cc.getSimpleName ());//获得简要类名 &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; //处理方法的基本用法 产生新的方法 public static void test02() &#123; ClassPool pool=ClassPool.getDefault(); try &#123; CtClass cc = pool.get(\"com.zhuchuli.javaassist.Emp\"); //CtMethod method=CtMethod.make(\"public int add(int a,int b)&#123;System.out.println(\\\"test02\\\");return a+b;&#125;\", cc); //第一个参数为返回值类型,第二个参数为方法名 第三个参数为方法参数 第四个参数为所要加入的对象 CtMethod m=new CtMethod(CtClass.intType, \"add\", new CtClass[] &#123;CtClass.intType,CtClass.intType&#125;,cc); //设置方法的修饰符 m.setModifiers(Modifier.PUBLIC); //设置方法体 $1代表参数位置 m.setBody(\"&#123;System.out.println(\\\"test02\\\");return $1+$2;&#125;\"); cc.addMethod(m); Class&lt;?&gt; clazz=cc.toClass(); Object obj=clazz.getConstructor().newInstance(); Method method=clazz.getDeclaredMethod(\"add\", int.class,int.class); Object result=method.invoke(obj, 200,300); System.out.println(result); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; //... 还有注解 构造器 和 属性 public static void main(String[] args) &#123; test01(); &#125;&#125; JVM运行和类加载全过程 为什么要研究加载全过程？ 有助于了解JVM运行过程 更深入了解Java动态性（解耦部署，动态加载），提高程序的灵活性。 类加载全过程 （如下图所示） 加载 链接 （验证 准备 解析）:将Java类的二进制代码合并到JVM的运行状态之中的过程。 初始化：静态属性或静态方法或静态块只会被初始化一次。 使用 卸载 类的主动引用（一定会发生类初始化） new一个类的对象。 调用类的静态成员（除了final常量）和静态方法。 使用java.lang.reflect包的方法对类进行反射调用。 当虚拟机启动，java hello则一定会初始化Hello类，说白了就是先启动main方法所在的类。 当初始化一个类，如果其父类没有被初始化，则会先初始化他的父类。 类的被动引用 当访问一个静态域时，只有真正声明这个域的类才会被初始化。 通过子类引用父类的静态变量，不会导致子类初始化。 通过数组定义类引用，不会触发此类的初始化 引用常量不会触发此类的初始化（常量在编译阶段就存入调用类的常量池中了）。 深入类加载器 类加载器原理 类加载器的作用：将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区中的运行时数据结构，在堆中生成一个代表这个类的java.lang.Class对象，作为方法区类数据的访问入口。 类缓存：标准的JavaSE类加载器可以按要求查找类，但一旦某个类被加载到类加载器中，它将维持加载（缓存）一段时间。不过JVM垃圾集成器可以回收这些Class对象。 类加载器树状结构，双亲委托（代理）机制 引导类加载器（bootstrap class loader） 扩展类加载器（extensions class loader） 应用程序类加载器（application clasas loader） 自定义类加载器 双亲委托机制是为了保证Java核心库的类型安全。（请求 —&gt; 交给父类 —&gt; 交给爷爷辈） tomcat则与此相反 自定义类加载器（文件、网络、加密） 注意：同一个类被不同的加载器加载，JVM也会认为他们不是相同的类 线程上下文类加载器 服务器类加载器原理和OSGI介绍(面向Java的动态模块系统) Eclipse是基于OSGI技术来构建的","categories":[],"tags":[]},{"title":"文件上传","slug":"文件上传","date":"2019-06-28T01:51:14.000Z","updated":"2019-07-03T09:17:14.711Z","comments":true,"path":"2019/06/28/文件上传/","link":"","permalink":"https://CPWS.github.io/2019/06/28/文件上传/","excerpt":"","text":"1. 文件上传功能的实现上传和下载是Web应用开发需求中出现频率较高的词汇。在JSP应用开发过程中，编写“文件上传”功能代码主要有三种方式： 采用自编写的JavaBean组件 采用JspSmart公司自己编写的JspSmartUnload组件 采用O’Reilly公司的Cos组件 1.1 采用自编写的JavaBean组件 要编写一个实现文件上传功能的组件，首先需要先了解数据传输的原理，根据数据处理的规律来完成相关的编码。步骤为： 1.获取上传数据的规律。案列如下： 12&lt;!--如果要实现文件上传功能 需要添加 enctype=\"MULTIPART/FORM-DATA\"--&gt;&lt;form enctype=\"MULTIPART/FORM-DATA\"&gt;&lt;/form&gt; 12//js版给form添加属性，实现文件上传form.encding=\"multipart/form-data\" 1234567891011121314151617181920212223242526272829&lt;!--index.jsp--&gt;&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;文件上载&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=\"up.jsp\" enctype=\"multipart/form-data\" method=\"post\"&gt; 作者： &lt;input type=\"text\" name=\"author\"&gt;&lt;br&gt; 公司： &lt;input type=\"text\" name=\"company\"&gt;&lt;br&gt; 选择要上传的文件 &lt;input type=\"file\" name=\"filename\"&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"上载\"&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;&lt;!--up.jsp--&gt;&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;jsp:useBean id=\"TheBean\" scope=\"page\" class=\"org.xmh.demo.UploadBean\" /&gt; &lt;% TheBean.doUpload(request); %&gt;&lt;/body&gt;&lt;/html&gt; 12345678910111213141516171819package org.xmh.demo;import javax.servlet.ServletInputStream;import javax.servlet.http.HttpServletRequest;import java.io.BufferedWriter;import java.io.FileWriter;import java.io.IOException;import java.io.PrintWriter;public class UploadBean &#123; public void doUpload(HttpServletRequest request) throws IOException &#123; PrintWriter pw=new PrintWriter(new BufferedWriter(new FileWriter(\"d:\\\\xmh.txt\"))); ServletInputStream in=request.getInputStream(); int i=in.read(); while(i!=-1)&#123; pw.print((char)i); i=in.read(); &#125; pw.close(); &#125;&#125; 编写上传组件。 根据上文所述，如果想要获取表单提取的数据，需要设计一个功能类来处理相关的数据信息。下面设计了一个FileUploadBean.java的类，他就是自定义处理上传功能的类。 使用自编写的上传组件。 案例2 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;自编写上传组件--文件上传示例&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=\"selfBean.jsp\" enctype=\"multipart/form-data\" method=\"post\"&gt; 作者：&lt;input type=\"text\" name=\"author\"&gt;&lt;br&gt; 公司：&lt;input type=\"text\" name=\"company\"&gt;&lt;br&gt; 说明: &lt;textarea name=\"comment\" &gt;&lt;/textarea&gt;&lt;br&gt; 选择要上载的文件: &lt;input type=file name=\"filename\"&gt;&lt;br&gt; 文件描述: &lt;input type=\"text\" name=\"description\"&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"Upload\"&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;jsp:useBean id=\"TheBean\" class=\"org.xmh.demo.FileUploadBean\" scope=\"page\"&gt; &lt;% TheBean.setSavePath(\"d:/\"); TheBean.doUpload(request); out.println(\"Filename:\"+TheBean.getFilename()); out.println(\"&lt;BR&gt;内容类型:\"+TheBean.getContentType()); out.println(\"&lt;BR&gt;作者:\"+TheBean.getFieldValue(\"author\")); out.println(\"&lt;BR&gt;公司:\"+TheBean.getFieldValue(\"company\")); out.println(\"&lt;BR&gt;说明:\"+TheBean.getFieldValue(\"comment\")); %&gt; &lt;/jsp:useBean&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123package org.xmh.demo;import javax.servlet.ServletInputStream;import javax.servlet.http.HttpServletRequest;import java.io.*;import java.util.Hashtable;public class FileUploadBean &#123; private String savePath; private String filepath; private String filename; private String contentType; private Hashtable&lt;String, String&gt; fields; // 返回filename私有域的值 public String getFilename() &#123; return filename; &#125; // 返回filepath私有域的值 public String getFilepath() &#123; return filepath; &#125; // 返回savePath私有域的值 public void setSavePath(String savePath) &#123; this.savePath = savePath; &#125; // 返回contentType私有域的值 public String getContentType() &#123; return contentType; &#125; // 返回HTML表单中指定输入元素的值，元素的名字通过fieldName参数指定 public String getFieldValue(String fieldName) &#123; if (fields == null || fieldName == null) return null; return (String) fields.get(fieldName); &#125; private void setFilename(String s) &#123; if (s == null) return; int pos = s.indexOf(\"filename=\\\"\"); if (pos != -1) &#123; filepath = s.substring(pos + 10, s.length() - 1);// Windows浏览器发送完整的文件路径和名字// 但Linux/Unix和Mad浏览器只发送文件名字 pos = filepath.lastIndexOf(\"\\\\\"); if (pos != -1) filename = filepath.substring(pos + 1); else filename = filepath; &#125; &#125; private void setContentType(String s) &#123; if (s == null) return; int pos = s.indexOf(\": \"); if (pos != -1) contentType = s.substring(pos + 2, s.length()); &#125; //处理请求数据的方法 public void doUpload(HttpServletRequest request) throws IOException &#123; ServletInputStream in = request.getInputStream(); // 创建字节数组充当缓冲容器的作用 byte[] line = new byte[128]; int i = in.readLine(line, 0, 128); if (i &lt; 3) return; // -2丢弃换行字符 int boundaryLength = i - 2; String boundary = new String(line, 0, boundaryLength); fields = new Hashtable&lt;String, String&gt;(); while(i!=-1)&#123; String newLine=new String(line,0,i); if(newLine.startsWith(\"Content-Disposition: form-data; name=\\\"\"))&#123; //判断文件类型 if(newLine.indexOf(\"filename=\\\"\") != -1)&#123; setFilename(new String(line,0,i-2)); if(filename == null)&#123; return; &#125; i=in.readLine(line,0,128); setContentType(new String(line,0,i-2)); i=in.readLine(line,0,128); newLine=new String(line,0,i); PrintWriter pw=new PrintWriter(new BufferedWriter(new FileWriter((savePath == null ? \"\":savePath)+filename))); while(i!=-1 &amp;&amp; !newLine.startsWith(boundary))&#123; //文件的最后一行包含换行符 //因此必须检查当前行是否是最后一行 i=in.readLine(line,0,128); if( (i == boundaryLength+2 || i==boundaryLength+4) &amp;&amp; (new String(line,0,i).startsWith(boundary)))&#123; pw.print(newLine.substring(0,newLine.length()-2)); &#125;else&#123; pw.print(newLine); &#125; newLine=new String(line,0,i); &#125; pw.close(); &#125;else&#123; //普通表单输入元素 //获取输入元素名字 int pos=newLine.indexOf(\"name=\\\"\"); String fieldName=newLine.substring(pos+6,newLine.length()-3); i=in.readLine(line,0,128); newLine=new String(line,0,i); StringBuffer fieldValue=new StringBuffer(128); while(i!=-1 &amp;&amp; !newLine.startsWith(boundary))&#123; //最后一行包含换行符 //因此必须检查当前行是否是最后一行 i=in.readLine(line,0,128); if( (i==boundaryLength+2 || i==boundaryLength+4) &amp;&amp;(new String(line,0,i).startsWith(boundary)))&#123; fieldValue.append(newLine.substring(0,newLine.length()-2)); &#125;else fieldValue.append(newLine); newLine=new String(line,0,i); &#125; fields.put(fieldName,fieldValue.toString()); &#125; &#125; i=in.readLine(line,0,128); &#125; &#125;&#125; 1.2 JspSmartUpload上传组件JspSmartUpload是由JspSmart公司开发的，它可以免费下载，下载地址:https://pan.baidu.com/s/10OTcN5GOwNly-Ty9oybwQQ，提取码：4fzf因为要反馈给用户上传成功与否，所以需要将上传功能的执行顺序优先于表单的文本数据执行。 12345678910111213141516171819202122232425&lt;!--上传界面--&gt;&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;上传图片&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=\"upload_pic.jsp\" method=\"post\" enctype=\"multipart/form-data\" name=\"form1\"&gt; &lt;table border=\"1\" align=\"center\" cellpadding=\"1\" cellspacing=\"1\"&gt; &lt;tr&gt; &lt;td height=\"45\" align=\"center\" valign=\"middle\"&gt; 请选择上传的图片 &lt;input type=\"file\" name=\"file\" /&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td align=\"center\"&gt; &lt;input type=\"submit\" name=\"submit\" value=\"上传\" /&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109&lt;!--处理图片 ， 获取上传图图片，然后生成缩略图 --&gt;&lt;%@ page language=\"java\" pageEncoding=\"utf-8\" import=\"java.util.*,java.io.*\"%&gt;&lt;%@ page import=\"com.jspsmart.upload.SmartUpload\"%&gt;&lt;%@ page import=\"javax.servlet.jsp.tagext.TryCatchFinally\"%&gt;&lt;%@ page import=\"javax.imageio.ImageIO\"%&gt;&lt;%@ page import=\"java.awt.image.BufferedImage\"%&gt;&lt;%@ page import=\"javax.servlet.*\"%&gt;&lt;%@ page import=\"javax.servlet.http.*\"%&gt;&lt;%@ page import=\"java.awt.*\" %&gt;&lt;% String path = request.getContextPath(); String basePath = request.getScheme() + \"://\" + request.getServerName() + \":\" + request.getServerPort() + path + \"/\";%&gt;&lt;% SmartUpload mySmartUpload = new SmartUpload();//实例SmartUpload对象 long file_size_max = 4000000; String fileName2;//文件名 String ext;//文件扩展名 String url = \"D:/\";//应保证在WebRoot目录下有此目录的存在 //初始化 mySmartUpload.initialize(pageContext); //只允许上载此类文件 try &#123; //支持上载文件的后缀名 //mySmartUpload.setAllowedFilesList(\"jpg,gif\"); //mySmartUpload.setAllowedFilesList(\"jpg,gif,jpeg,png\"); //不支持指定的后缀 mySmartUpload.setDeniedFilesList(\"exe\"); //上载文件 mySmartUpload.upload();//不指定编码的upload()方法 //mySmartUpload.upload(\"utf-8\");//指定编码的upload()方法 &#125; catch (Exception e) &#123; out.print(\"&lt;script type=\\\"text/javascript\\\"&gt;\"); out.print(\"window.alert(\\\"文件格式不符\\\");\"); out.print(\"window.location=\\\"upload.html;\\\"\"); out.print(\"&lt;/script&gt;\"); &#125; try &#123; com.jspsmart.upload.File myFile = mySmartUpload.getFiles().getFile(0); if (myFile.isMissing()) &#123;//如果没有拿到文件，提示 out.print(\"&lt;script type=\\\"text/javascript\\\"&gt;\"); out.print(\"window.alert(\\\"请先选择要上传的文件\\\");\"); out.print(\"window.location=\\\"upload.html;\\\"\"); out.print(\"&lt;/script&gt;\"); &#125; else &#123; String myFileName = myFile.getFileName();//取得上载的文件的文件名 ext = myFile.getFileExt();//取得后缀名 if (!(ext.length() &gt; 0)) &#123; out.println(\"**************myFileName的文件名是：\" + myFileName); &#125; int file_size = myFile.getSize();//取得文件的大小 String saveUrl = \"\";//文件保存路径 if (file_size &lt; file_size_max) &#123; //更改文件名，取得当前上传时间的毫秒数值 Calendar calendar = Calendar.getInstance(); String fileName = String.valueOf(calendar.getTimeInMillis());//设置新的文件名 saveUrl += fileName + \".\" + ext; myFile.saveAs(saveUrl, mySmartUpload.SAVE_PHYSICAL);//保存文件 //上传完成，开始生成缩略图 java.io.File file = new java.io.File(saveUrl);//读入刚才上传的文件 out.println(\"ext = \" + ext); String newUrl = url + fileName + \"_min.\" + ext;//新的缩略图保存地址 System.out.println(newUrl); BufferedImage image=ImageIO.read(file); int imageWidth=image.getWidth(); //取出图片额宽度 int imageHeight=image.getHeight();//取出图片的高度 int n_w=0; //缩略图的宽度 int n_h=0; //缩略图的高度 System.out.println(\"imageWidth=\"+imageWidth + \";\"+\"imageHeight=\"+imageHeight); float tempDouble; if(imageHeight &gt; imageWidth)&#123; tempDouble = imageHeight /200; &#125;else&#123; tempDouble = imageWidth /200; &#125; n_w = (int) (imageWidth/tempDouble); n_h = (int) (imageHeight/tempDouble); FileOutputStream fos=new FileOutputStream(newUrl); BufferedImage bi=new BufferedImage(n_w,n_h,BufferedImage.TYPE_INT_RGB); Graphics g=bi.getGraphics(); g.drawImage(image,0,0,n_w,n_h,Color.LIGHT_GRAY,null); g.dispose(); ImageIO.write(bi,\"jpg\",fos); &#125; else &#123; out.print(\"&lt;script type=\\\"text/javascript\\\"&gt;\"); out.print(\"window.alert(\\\"上传文件大小不能超过\\\"+(file_size_max/1000)+\\\"K\\\");\"); out.print(\"window.location=\\\"upload.html;\\\"\"); out.print(\"&lt;/script&gt;\"); &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;%&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;处理上传的图片&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 1.3 Cos上传组件 （Cloud Object Storage） Cos组件是O&#39;Reilly公司开发的一款免费组件。 Cos包下载地址：http://www.servlets.com/cos/2.3.1 在Cos组件中MultipartRequest类主要负责文件上传的处理 (1) MultipartRequest有8个构造函数，它们分别是： public MulipartRequest(HttpServletRequest request,String saveDirectory) throws IOException public MultipartRequest(HttpServletRequest request,String saveDirectory,int maxPostSize) throws IOException public MiltipartRequest(HttpServletRequest request,String saveDirectory,int maxPostSize,FileRenamePolicy policy) throws IOException public MultipartRequest(HttpServletRequest request,String saveDirectory,int maxPostSize,String encoding) throws IOException public MultipartRequest(HttpServletRequest request,String saveDirectory,int maxPostSize,String encoding,FileRenamePolicy policy) throws IOException public MultipartRequest(HttpServletRequest request,String saveDirectory,String encoding) throws IOException public MulipartRequest(HttpServletRequest request,String saveDirectory) throws IOException public MulipartRequest(HttpServletRequest request,String saveDirectory,int maxPostSize)throws IOException (2) MultipartRequest类工具有8中方法： public Enumeration getParameters(): 取得请求参数的名称 public String getParameter(String name): 此方法返回参数为name的值 public String[] getParameterValues(String name)：当指定参数具有多个值时，此方法会返回String数组 public Enumeration getFileName()：传回所有文件输入类型的名称 public String getFilesystemNames(String name)： 用此方法得到上传文件的真正的文件名称，这里的name指文件输入类型的名称 public String getContentType(String name)： 此方法得到上传文件的文件类型 public File getFile(String name)：此方法得到一个文件对象，代表存储在服务器上的name值 public String getOriginalFileName(String name)：返回文件在修改政策有效之前的文件名称。 注意：Cos组件在上传大容量文件时，效率比起前面介绍的自编写JavaBean组件和JspSmart上传组件高。 案例： 1234567891011121314151617181920&lt;!--upload.html--&gt;&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;style&gt; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!--enctype的值很重要，upload.jsp处理上传的JSP--&gt; &lt;form action=\"upload.jsp\" enctype=\"multipart/form-data\" name=\"form1\" method=\"post\"&gt; &lt;p&gt;&lt;input type=\"file\" name=\"file1\"&gt;&lt;/p&gt; &lt;p&gt;&lt;input type=\"file\" name=\"file2\"&gt;&lt;/p&gt; &lt;p&gt;&lt;input type=\"file\" name=\"file3\"&gt;&lt;/p&gt; &lt;p&gt;&lt;input type=\"submit\" name=\"Submit\" value=\"上传\"&gt;&lt;/p&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324252627282930313233&lt;%@ page import=\"java.io.File\" %&gt;&lt;%@ page import=\"com.oreilly.servlet.MultipartRequest\" %&gt;&lt;%@ page import=\"java.util.Enumeration\" %&gt;&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;% //文件上传后，保存在d:/JavaWebs String saveDirectory=\"d:\"+ File.separator+\"JavaWebs\"; //每个文化最大500M,最多三个文件，所以... int maxPostSize=3*500*1024*1024; //response的编码为gd2312，同时采用缺省的文件名冲突解决策略，实现上传 MultipartRequest multi=new MultipartRequest(request,saveDirectory,maxPostSize,\"UTF-8\"); //输出反馈信息 Enumeration files=multi.getFileNames(); while (files.hasMoreElements())&#123; System.err.println(\"ccc\"); String name= (String) files.nextElement(); File f=multi.getFile(name); if(f!=null)&#123; String fileName=multi.getFilesystemName(name); String lastFileName=saveDirectory+\"\\\\\"+fileName; out.println(\"上传的文件:\"+lastFileName); out.println(\"&lt;hr&gt;\"); &#125; &#125;%&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 以上内容大部分都是参考一本书叫做《软件开发 JSP》，感谢作者!!!!","categories":[],"tags":[]},{"title":"解决中文乱码","slug":"解决中文乱码","date":"2019-06-28T01:47:18.000Z","updated":"2019-06-28T01:50:29.669Z","comments":true,"path":"2019/06/28/解决中文乱码/","link":"","permalink":"https://CPWS.github.io/2019/06/28/解决中文乱码/","excerpt":"","text":"1.1 熟悉Web应用程序中与编码相关的部分 JSP编译 指定文件的存储编码,很明显。该设置应该位于文件的开头：&lt;%@page pageEncoding=&quot;UTF-8&quot; %&gt; 另外对于一般的class文件，可以在编译的时候指定编码。 JSP输出 指定文件输出到Browser时的使用的编码，该设置也应该设置在文件的开头。&lt;%@page contentType=&quot;text/html;charset=UTF8&quot; %&gt; 该设置与response.setCharacterEncoding(&quot;GBK&quot;);等效 META设置 指定网页使用的编码，该设置对静态网页尤其有用，因为静态网页无法使用采用JSP的设置而且也无法执行response.setCharacterEncoding(&quot;UTF-8&quot;) ；例如：&lt;meta http-equiv=&quot;Content-Type&quot; contentType=&quot;text/html;charset=UTF-8&quot;/&gt; 注意：如果同时采用了JSP输出和meta设置两种编码指定方式，那么JSP指定的优先。因为JSP指定的直接体现在Response中。 Form设置 当浏览器提交表单时，可以指定相应的编码，例如:&lt;form accept-charset=&quot;UTF-8&quot;&gt;&lt;/form&gt;一般不需要设置，浏览器会直接使用网页的编码 1.2 熟悉Web应用程序产生中文乱码的原因 JSP页面被编译成class文件时,如果未指定字符集时,默认使用ISO-8859-1的编码格式，这样中文会出现乱码。 提交表单时如果设定提交方式为Post而没有设置提交的编码的格式，则会以ISO-8859-1方式提交，而接收的JSP却以UTF-8的方式接收，这样也会导致中文乱码。 提交表单时如果设定提交方式为Get而没有设置提交的编码的格式，Tomcat会以GET的默认编码格式ISO8859-1对汉字进行编码，编码后追加到URL，导致接收页面得到的参数为乱码。 1.3 解决中文乱码 设置文件本身的编码格式。这可以在Eclipse或MyEclipse中进行设置。 在JSP页面中指定字符集，通常页面字符集的设置如下： 1234567&lt;%@ page contentType=\"text/html;charset=UTF-8\" %&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=\"Content-Type\" contentType=\"text/html;charset=UTF8\"/&gt; &lt;title&gt;字符集设置联系&lt;/title&gt; &lt;/head&gt;&lt;/html&gt; 数据库连接时指定的字符集。 1String url=\"jdbc:msqyl://localhost:3306/test?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=UTF-8\" 在程序中获取页面数据时使用如下代码 12response.setContentType(\"text/html;charset=UTF-8\");request.setCharacterEncoding(\"UTF-8\"); 注意： 如果需要将中文作为参数传递，需要在传递和接受时进行相应的处理、具体方法如下所示： 在传递参数时对参数编码 : &quot;...RearshRes.jsp?keywords=&quot;+java.net.URLEncoder.encode(keywords) 然后在接收参数页面中使用如下语句接收 keywords=new String(request.getParameter(&quot;keywords&quot;).getBytes(&quot;ISO-8859-1&quot;))","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2019-06-27T05:37:31.802Z","updated":"2019-06-27T05:45:09.482Z","comments":true,"path":"2019/06/27/hello-world/","link":"","permalink":"https://CPWS.github.io/2019/06/27/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Hello HexoCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}
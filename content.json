{"meta":{"title":"Prossible's Blog","subtitle":null,"description":null,"author":"zhuli","url":"https://CPWS.github.io","root":"/"},"pages":[],"posts":[{"title":"正则表达式","slug":"正则表达式","date":"2019-09-08T01:36:32.000Z","updated":"2019-09-08T12:02:21.474Z","comments":true,"path":"2019/09/08/正则表达式/","link":"","permalink":"https://CPWS.github.io/2019/09/08/正则表达式/","excerpt":"","text":"正则表达式基本知识 基本语法 高级语法 练习 editplus,notpad++,ultraedit,eclipse中使用正则表达式 正则表达式（Regular Expression）简介 为什么需要使用正则表达式？ 文本的复杂处理。 正则表达式的优势和用途 一种强大而灵活的文本处理工具。 大部分编程语言、数据库、文本编辑器、开发环境都支持正则表达式。 正则表达式定义 正如他的名字一样是描述一种规则，通过这个规则可以匹配一类字符串。 学习正则表达式很大程度上就是学习正则表达式的语法规则。 开发中使用正则表示的流程 分析所要匹配的数据，写出测试用的典型数据。 在工具软件中进行匹配测试。 在程序中调用通过测试的正则表达式。 正则表达式基本语法 普通字符 字母、数字、汉字、下划线、以及没有特殊定义的标点符号，都是“普通字符”。表达式中的普通字符，在匹配一个字符串的时候，匹配与之相同的一个字符。 简单转义字符 \\n 代表换行符 \\t 制表符 \\ 代表\\本身 ^,$,.,{,},?,+,*,|,[,] 匹配这些字符创本身 标准字符集合： 能够与“多种字符”匹配的表达式 主义区分大小写，大写是相反的意思。 \\d 任意一个数字，0-9中的任意一个。 \\w 任意一个字母或数字或下划线，也就是A-Z,a-z,0-9,_中任意一个。 \\s 包括空格、制表符、换行符等空白字符的其中任意一个。 . 小数点可以匹配任意一个字符（除了换行符）如果要匹配在”\\n”在内的所有字符，一般用[\\s\\S]。 [\\s\\S] 匹配包含“\\n”在内所有字符串 自定义字符集合 []方括号匹配方式，能够匹配方括号中任意一个字符. |[ab5@]|匹配&quot;a&quot;或&quot;b&quot;或&quot;5&quot;或&quot;@&quot;| |:-:|-| |[^abc]|匹配&quot;a&quot;，&quot;b&quot;，&quot;c&quot;之外的任意一个字符| |[f-k]|匹配日&quot;f&quot;-&quot;k&quot;之间的任意一个字符| |[^A-f0-3]|匹配&quot;A&quot;-&quot;F&quot;，&quot;0&quot;-&quot;3&apos;之外的任意一个字符| - 正则表达式的特殊符号，被包含到中括号中，则失去特殊意义，除了`^`,`-`之外。 - 标准字符集合，处理小数点之外，如果被包含于中括号，自定义字符集合将包含该集合。 - [\\d.\\-+]讲匹配数组，小数点 + - 量词（Quantifier） 修饰匹配次数的特殊符号 {n} 表达重复n次 {m，n} 表达至少重复m次，最多重复n次 {m,} 表达至少重复m次 ? 匹配表达式0次或1次，相当于{0,1} + 表达式至少出现1线，相当{1,} * 表达式不会出现或出现任意次，{0，} 匹配次数中的贪婪模式（匹配字符越多越好，默认！）。 匹配次数中的非贪婪模式（匹配字符越少越好，修饰匹配次数的特殊符号后再加上一个”?”号）。 字符边界 （本组编辑匹配的不是字符而是位置，符合某种条件的位置）() ^ 与字符串开始的位置匹配 $ 与字符串结束的地方配置 \\b 匹配一个当前的边界 \\b匹配这样一个位置，前面的字符和后面的字符不全是\\w 选择符和分组 表达式 作用 ` `分支结构 ()捕获组 (1)在被修饰匹配次数的时候，括号中的表达式可以作为整体被修饰(2)取得匹配结果的时候，括号中的表达式匹配到的内容可以被单独得到(3)每个括号会分配一个编号，使用（）的捕获根据左括号的顺序从1开始自动编号。捕获元素编号为0的第一个捕获是由整个正则表达式模式匹配的文本 非捕获组（?:Exception）（?:([a-z]{2})） 一些表达式中，不得不使用()，但又不需要保存()中子表达式匹配的内容，这时候可以使用非捕获组来抵消使用()带来的副作用。 反向引用（\\nnn）： 每一个()都会分配一个编号，使用（）的捕获根据左括号的顺序从1开始自动编导。 通过反向作用，可以对分组已捕获的字符串进行引用。 正则表达式的匹配模式 INGORECASE 忽略大小写模式 匹配时忽略大小写。 默认情况下，正则表达式是要区分大小写的。 SIGNLELINE 单行模式 整个文本看做是一个字符串，只有一个开头，一个结尾。 使小数点“.”可以匹配包含“\\n”在内的任意字符。 MULTILINE 多行模式 每行都是一个字符串，都有开头和结尾。 在指定了MULTILINE之后，如果需要仅匹配字符串开始和结束位置，可以使用\\A和\\Z 预搜索（零宽断言）（环视） 占有字符还是零宽度，是针对匹配的内容是否保存到最终的匹配结果中而言的。 零宽断言的几种方式 (?=exp)：断言自身出现的位置的后面能匹配表达式exp。 (?&lt;=exp&gt;):断言自身出现的位置的前面能匹配表达式exp。 (?!exp):断言此位置的后面不能匹配exp。 (?&lt;!exp&gt;):断言此位置的前面不能匹配表达式exp。 正则表达式的应用 电话号码的应用 电话号码有数字和”-“构成。 电话号码为7到8位。 如果电话号码中包含有取号，那么区号为三位或四位，首位为0。 区号用”-“和其它部分隔开。 移动电话号码为11位 11位一定电话号码的第一位和第二位为”13“、”15“、”18“ 结果：(0\\d{2,3}-\\d{7,9})|(1[35789]\\d{9}) 电子邮件的地址验证 用户名：字母，数字，下划线，中划线组成 @ 网址：字母、数字组成 小数点 . 组织域名：2-4字母组成 不区分大小写 结果 [\\w-]+@[a-z0-9A-Z]+(.[A-Za-z]{2,3}){1,2} Java程序中使用正则表达式 相关类位于：java.util.regex包下面 类pattern： 正则表达式的编译表示形式。 Pattern p=Pattern.compile(r,int);//建立正则表达式，并启动响应模式 类matcher： 通过解释Pattern对character sequence执行匹配操作的引擎。 Matcher m=p.matcher(str);//匹配str字符串 Java模拟编程的原理123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package regular;import java.io.BufferedReader;import java.io.InputStreamReader;import java.net.URL;import java.util.ArrayList;import java.util.List;import java.util.regex.Matcher;import java.util.regex.Pattern;/*** * 网络爬虫取连接 * @author 1huangzewei * */public class webSpiderTest &#123; //获得urlStr网页的源代码 public static String getURLContent(String urlStr) &#123; StringBuilder sb=new StringBuilder(); try &#123; URL url=new URL(urlStr); BufferedReader reader=new BufferedReader(new InputStreamReader(url.openStream())); String temp=\"\"; while((temp=reader.readLine())!=null) &#123; sb.append(temp); &#125; &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; return sb.toString(); &#125; public static List&lt;String&gt; getMatcher(String destStr,String regex) &#123; List&lt;String&gt; result=new ArrayList&lt;String&gt;(); //Pattern p=Pattern.compile(\"&lt;a[\\\\s\\\\S]+?&lt;/a&gt;\");//找到超链接 Pattern p = Pattern.compile(regex);//找到a href; Matcher m = p.matcher(destStr); while (m.find()) &#123; result.add(m.group(1)); &#125; return result; &#125; public static void main(String[] args) &#123; String destStr=getURLContent(\"http://163.com\"); //List&lt;String&gt; list=getMatcher(destStr,\"href=\\\"([\\\\s\\\\S]+?)\\\"\"); //List&lt;String&gt; list=getMatcher(destStr,\"(&lt;img+[\\\\S\\\\s]+?)&gt;\"); List&lt;String&gt; list=getMatcher(destStr,\"data-original=\\\"([\\\\s\\\\S]+?)\\\"\"); for(String temp:list) &#123; System.out.println(temp); &#125; &#125;&#125;","categories":[],"tags":[]},{"title":"注解与反射","slug":"注解与反射","date":"2019-09-02T08:08:40.000Z","updated":"2019-09-05T11:28:08.710Z","comments":true,"path":"2019/09/02/注解与反射/","link":"","permalink":"https://CPWS.github.io/2019/09/02/注解与反射/","excerpt":"","text":"注解入门 Annotation是JDK5.0开始引入的新技术 Annotation的作用 不是程序本身，可以对程序作出解释。 可以被其他程序（比如：编译器等）读取。（注解信息处理流程，是注解和注释的重大区别。如果没有注解信息处理流程，则注解毫无意义）。 Annotation格式 注解是以“@注释名”在代码中存在的，可以添加一些参数值，例如：@SeppressWarnings(value=”unchecked”)。 Annotation在哪里使用？ 可以附加在package，class，method，field等上面，相当于它它们添加了额外的辅助信息，我们可以通过反射机制编程实现对这些数据的访问。 内置注解 @Override：定义在java.lang.Override中，此注释只适用修饰方法，表示一个方法声明打算重写超类中的另一个方法声明。 @Deprecated：定义在java.lang.Deprecated中，此注释可以用于修饰方法、属性、类，表示不鼓励程序员使用这样的元素，通常是因为它很危险吗或存在更好的选择。（一般不建议使用） @SuppressWarnings：用来抑制编译器运行时的警告信息。 @SuppressWarnings(&quot;unchecked&quot;)告诉编译器忽略 unchecked 警告信息，如使用List，ArrayList等未进行参数化产生的警告信息。 @SuppressWarnings(&quot;serial&quot;)如果编译器出现这样的警告信息：The serializable class WmailCalendar does not declare a static final serialVersionUID field of type long 使用这个注释将警告信息去掉。 @SuppressWarnings(&quot;deprecation&quot;)如果使用了使用@Deprecated注释的方法，编译器将出现警告信息。 使用这个注释将警告信息去掉。 @SuppressWarnings(&quot;unchecked&quot;, &quot;deprecation&quot;)告诉编译器同时忽略unchecked和deprecation的警告信息。 @SuppressWarnings(value={&quot;unchecked&quot;, &quot;deprecation&quot;})等同于@SuppressWarnings(“unchecked”, “deprecation”) 自定义注解、元注解元注解 @Target 作用：用于描述注解的使用范围 |所修饰的范围|取值ElemnetType||-|-|-||package包|PACKAGE||类、接口、枚举、Annotation类型|TYPE||类型成员（方法、构造器、成员变量、枚举值）|CONSTRUCTOR：用于描述构造器。FIELD：用于描述域METHOD：用于描述方法||方法参数和本地变量|LOCAL_VALUE：用于描述局部变量PARANETER：用于描述参数| @Target(value=ElementType.Type) @Retention 作用：表示需要在什么级别保存该注解，用于描述注解的生命周期。 取值 RetentionPolicy 作用 SOURCE 在源文件中有效（即源文件保存） CLASS 在class文件中有效（即class保留） RUNTIME 在运行时有效（即运行时保留）为Runtime可以被反射机制读取 注意： 注解元素的参数的默认值一般设置为0或空字符窜； 也可能是-1，表示什么也没有 @Documented 作用：用于描述其它类型的annotation应该被作为被标注的程序成员的公共API，因此可以被例如javadoc此类的工具文档化。它是一个标记注解，没有成员。 @Inherited 作用：用于表示某个被标注的类型是被继承的。如果一个使用了@Inherited修饰的annotation类型被用于一个class，则这个annotation将被用于该class的子类 反射机制读取注解 什么是ORM（Object Relationship Mapping） 类和表结构对应 属性和字段对应 对象和记录对应 使用注解完成类和表结构的映射关系 学了反射机制后，我们可以定义注解的执行流程读取这些注解，实现更复杂的功能 123456789101112package annotation;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target; @Target(value = ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)public @interface Table &#123; String value();&#125; 1234567891011121314package annotation;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Target(value = ElementType.FIELD)@Retention(RetentionPolicy.RUNTIME)public @interface Field &#123; String columnName(); String type(); int length();&#125; 123456789101112131415161718192021222324252627282930package annotation;@Table(\"tb_student\")public class Student &#123; @Field(columnName=\"id\",type=\"int\",length=3) private int id; @Field(columnName=\"sname\",type=\"varchar\",length=10) private String studentName; @Field(columnName=\"age\",type=\"int\",length=10) private int age; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getStudentName() &#123; return studentName; &#125; public void setStudentName(String studentName) &#123; this.studentName = studentName; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; &#125; 1234567891011121314151617181920212223242526272829303132package annotation;import java.lang.annotation.Annotation;/** * 使用反射处理注解信息，模拟处理注解信息的流程 * @author 1huangzewei * */public class Demo3 &#123; public static void main(String[] args) &#123; try &#123; Class clazz=Class.forName(\"annotation.Student\"); //获取类所有有效的注解 Annotation[] annotations=clazz.getAnnotations(); for(Annotation a:annotations) &#123; System.out.println(a); &#125; //获取指定的注解 Table table=(Table) clazz.getAnnotation(Table.class); System.out.println(table.value()); //获取类的属性的注解 Field f=clazz.getDeclaredField(\"studentName\").getAnnotation(Field.class); System.out.println(f.columnName() + \"---&gt;\" + f.type() + \"---&gt;\" + f.length()); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125; Java的动态性 动态语言：程序运行时，可以改变程序结果或变量类。 Java可以称为准动态语言。 反射机制 reflection 指的是可以于运行时加载、探知、使用编译期间完全未知的类。 程序在运行状态中，可以动态加载一个只有名称的类，对于任意一个已加载的类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性。 1Class c=Class.forName(\"包名.类名\"); 加载完类之后，在堆内存中，就产生了一个Class类型的对象（一个类只有一个Class对象），这个对象就包含了完整的类的结构信息。我们可以通过这个对象看到类的结构。这个对象就像一面镜子，通过这个镜子可以看到类的结构，所以我们形象的称之为：反射。 Class类的对象如何获取 运用getClass() 运用Class.forName()（最常被使用） 运用类.class 123456789101112131415161718192021222324252627282930313233343536package com.zhuchuli.reflection;import com.zhuchuli.testBean.User;/*** * 测试java.lang.Class对象的获取方式。 * 测试各种数据类型java.lang.Class对象的获取方式。 * 1.利用类.class * 2.利用类.getClass() * 3.利用Class.forName() * @author 1huangzewei * */@SuppressWarnings(\"all\")public class Demo01 &#123; public static void main(String[] args) &#123; String path= \"com.zhuchuli.testBean.User\"; try &#123; Class clazz = Class.forName(path); //对象是表示或封装一些数据。一个类被加载之后，Jvm会创建一个对应该类的Class对象，类的整个结构信息会放到对象的Class对象中。 //这个Class对象就像一面镜子一样，通过这个镜子，我们可以看到类的全部信息。 System.out.println(clazz.hashCode()); //获取Class对象的三种方式 Class strClazz=String.class; Class strClazz2=path.getClass(); System.out.println(strClazz==strClazz2); //基本数据类型 Class intClaszz=int.class; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 反射机制的常见作用 动态加载类、动态获取类的信息（属性、方法、构造器） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package com.zhuchuli.reflection;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.Method;/*** * 应用反射API，获取类的信息（类的名字、属性、方法、构造器等） * @author 1huangzewei * */public class Demo02 &#123; public static void main(String[] args) &#123; String path= \"com.zhuchuli.testBean.User\"; try &#123; Class clazz = Class.forName(path); //获取类的名字 System.out.println(\"---------------------------------通过反射获取类名---------------------------------\"); System.out.println(clazz.getName());//获得包名+类名 com.zhuchuli.testBean.User System.out.println(clazz.getSimpleName());//获得类名 User System.out.println(\"------------------------------------------------------------------------------\"); //获取属性信息 System.out.println(\"---------------------------------通过反射获取属性---------------------------------\"); //Field[] fields=clazz.getFields();//只能获取public的属性 Field[] fields=clazz.getDeclaredFields();//获得所有的field Field f=clazz.getDeclaredField(\"uname\"); System.out.println(f); for(Field field:fields) &#123; System.out.println(\"属性：\"+field); &#125; System.out.println(\"------------------------------------------------------------------------------\"); //获取方法信息 System.out.println(\"---------------------------------通过反射获取方法---------------------------------\"); Method[] methods=clazz.getMethods();//只能获取public修饰的方法 Method[] methodss=clazz.getDeclaredMethods();//获取所有的方法 Method m01=clazz.getDeclaredMethod(\"getUname\", null); System.out.println(m01); Method m02=clazz.getDeclaredMethod(\"setUname\", String.class);//如果方法有参数，则必须指明参数的类型，即参数类型.class System.out.println(m02); for(Method method:methodss) &#123; System.out.println(\"方法：\"+method); &#125; System.out.println(\"------------------------------------------------------------------------------\"); //获取构造器信息 System.out.println(\"---------------------------------通过反射获取构造器---------------------------------\"); Constructor[] constructors=clazz.getConstructors();//获取public修饰的构造器 Constructor[] constructorss=clazz.getDeclaredConstructors(); for(Constructor constructor:constructorss) &#123; System.out.println(\"构造器：\"+constructor); &#125; System.out.println(\"根据参数类型获取构造器\"); Constructor c=clazz.getDeclaredConstructor(null); System.out.println(\"构造器：\"+c); Constructor cc=clazz.getConstructor(int.class,String.class,int.class); System.out.println(\"构造器：\"+cc); System.out.println(\"------------------------------------------------------------------------------\"); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 动态构造对象 动态调用类和对象的任意方法、构造器 动态调用和处理属性 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.zhuchuli.reflection;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.Method;import com.zhuchuli.testBean.User;/*** * 通过反射API动态的操作：构造器，方法和属性 * @author 1huangzewei * */public class Demo03 &#123; public static void main(String[] args) &#123; //动态操作构造器 String path= \"com.zhuchuli.testBean.User\"; try &#123; Class clazz = Class.forName(path); //通过反射API调用构造方法，构造对象 User u=(User) clazz.getConstructor().newInstance();//其实调用JavaBean的无参数构造器 System.out.println(u); Constructor&lt;User&gt; c=clazz.getConstructor(int.class,String.class,int.class); User u2=c.newInstance(1001,\"lee\",18); System.out.println(u2.getId()+\"--\"+u2.getUname()+\"--\"+u2.getAge()); //通过反射API调用普通方法 User u3=(User) clazz.getConstructor().newInstance(); Method method=clazz.getDeclaredMethod(\"setUname\", String.class); method.invoke(u3, \"lee2\");//类似于u3.setUname=\"lee2\" System.out.println(u3.getUname()); //通过反射API调用属性 User u4=(User) clazz.getConstructor().newInstance(); Field f=clazz.getDeclaredField(\"uname\"); f.setAccessible(true);//这个属性不需要做安全检查，可以直接访问。 f.set(u4, \"lee3\");//通过放射获取属性的值 System.out.println(u4.getUname()); System.out.println(f.get(u4));//通过反射读取对象的值 &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 获取泛型信息（Generic） Java使用泛型擦除机制来引入泛型。Java中的泛型仅仅是给编译器JavaC使用的，确保数据的安全性和免去强制类型转换的麻烦。但是编译一旦完成，所有和泛型有关的类全部被擦除。 为了通过反射操作这些类型以迎合实际开发的需要，Java新增了PatameterType，GenericArrayType，TypeVariable，和WildCardType几种类型来代表不能被归一到Class类中的类型但是又和原始类型齐名的类型。 ParameterizedType:表示一种参数化的类型，比如Collection&lt; String &gt;. GenericArrayType:表示一种元素类型是参数化类型或者类型变量的数组类型. TypeVariable:是各种类型变量的公共父接. WildcardType:代表一种通配符类型表达式，比如？、？ extends Number、？ super Integer。（wildcard是一个单词：就是”通配符“）. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package com.zhuchuli.reflection;import java.lang.reflect.Method;import java.lang.reflect.ParameterizedType;import java.lang.reflect.Type;import java.util.List;import java.util.Map;import com.zhuchuli.testBean.User;/*** * 通过反射获取泛型信息 * @author 1huangzewei * */public class Demo04 &#123; public void test01(Map&lt;String,User&gt; map,List&lt;User&gt; list) &#123; System.out.println(\"Demo04 test01()\"); &#125; public Map&lt;Integer,User&gt; test02()&#123; System.out.println(\"Demo01 test02()\"); return null; &#125; public static void main(String[] args) &#123; try &#123; //获取执行方法参数的泛型信息 Method method = Demo04.class.getDeclaredMethod(\"test01\", Map.class, List.class); Type[] t=method.getGenericParameterTypes(); for(Type paramType:t) &#123; System.out.println(\"#\"+paramType); if(paramType instanceof ParameterizedType) &#123; //获取泛型中的具体信息 Type[] genericTypes = ((ParameterizedType) paramType).getActualTypeArguments(); for(Type genericType:genericTypes) &#123; System.out.println(\"泛型类型：\" + genericType); &#125; &#125; &#125; //获取指定方法返回值泛型信息 Method method2=Demo04.class.getDeclaredMethod(\"test02\",null); Type returnType=method2.getGenericReturnType(); if(returnType instanceof ParameterizedType) &#123; //获取泛型中的具体信息 Type[] genericTypes = ((ParameterizedType) returnType).getActualTypeArguments(); for(Type genericType:genericTypes) &#123; System.out.println(\"泛型类型：\" + genericType); &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 处理注解：功能与案例代码与上面雷同。 反射机制的性能问题 setAccessible 启动和禁用访问安全检查的机关，值为true则指示反射的对象在使用时应该取消Java语言访问检查。值为false则指示表明反射的对象应该实施Java语言访问检查。并不是为true就能访问为false就不能访问。 禁止安全检查，可以提高反射的运行速度。 可以考虑使用：cglib/javaassist字节码操作 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.zhuchuli.reflection;import java.lang.reflect.Method;import com.zhuchuli.testBean.User;public class Demo05 &#123; public static void test01() &#123; User user=new User(); long before=System.currentTimeMillis(); for(var i=0;i&lt;1000000000L;i++) &#123; user.getUname(); &#125; long after=System.currentTimeMillis(); System.out.println(\"没有反射，共消耗：&lt;\"+(after-before)+\"&gt;毫秒\"); &#125; public static void test02() throws Exception &#123; User user=new User(); Method method=Class.forName(\"com.zhuchuli.testBean.User\").getDeclaredMethod(\"getUname\", null); long before=System.currentTimeMillis(); for(var i=0;i&lt;1000000000L;i++) &#123; method.invoke(user, null); &#125; long after=System.currentTimeMillis(); System.out.println(\"加安全检查，共消耗：&lt;\"+(after-before)+\"&gt;毫秒\"); &#125; public static void test03() throws Exception &#123; User user=new User(); Method method=Class.forName(\"com.zhuchuli.testBean.User\").getDeclaredMethod(\"getUname\", null); method.setAccessible(true); long before=System.currentTimeMillis(); for(var i=0;i&lt;1000000000L;i++) &#123; method.invoke(user, null); &#125; long after=System.currentTimeMillis(); System.out.println(\"不加安全检查，共消耗：&lt;\"+(after-before)+\"&gt;毫秒\"); &#125; public static void main(String[] args) throws Exception &#123; test01(); test02(); test03(); &#125;&#125; 动态编译 Java6.0引入了动态编译机制 动态编译的应用场景 可以做一个浏览器端编写java代码，上传服务器编译和运行的在线测评系统。 服务器动态加载某些类文件进行编译。 动态编译的两种方式 通过Runtime调用javac，启动新的进程去操作 Runtime run=Runtime.getRuntime(); Process process=run.exec(javac -cp d:/myjava/ HelloWorld.java); 通过JavaCompiler动态编译 123456789101112131415161718192021222324package com.zhuchuli.test;import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.FileReader;import java.io.FileWriter;import java.io.IOException;import javax.tools.JavaCompiler;import javax.tools.ToolProvider;public class Demo01 &#123; public static void main(String[] args) throws IOException &#123; String str=\"public class Hi&#123;public static void main(String[] args[]) &#123;System.out.println(\\\"Hello Hi haha\\\");&#125;&#125;\"; BufferedWriter br=new BufferedWriter(new FileWriter(\"d:/MyJava/Hi.java\")); br.write(str); br.flush(); //获得系统编译器，如果使用jre（运行环境）则无法获得编译器 JavaCompiler complier=ToolProvider.getSystemJavaCompiler(); int result=complier.run(null, null, null,\"d:/MyJava/Hi.java\"); System.out.println(result==0?\"编译成功\":\"编译失败\"); br.close(); &#125;&#125; 编译结果 1234567891011121314151617181920212223242526272829303132package com.zhuchuli.test;import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.FileReader;import java.io.FileWriter;import java.io.IOException;import java.io.InputStreamReader;import javax.tools.JavaCompiler;import javax.tools.ToolProvider;public class Demo02 &#123; public static void main(String[] args) throws IOException &#123; String str=\"public class Hi&#123;public static void main(String[] args) &#123;System.out.println(\\\"Hello Hi haha\\\");&#125;&#125;\"; BufferedWriter bw=new BufferedWriter(new FileWriter(\"d:/MyJava/Hi.java\")); bw.write(str); bw.flush(); //获得系统编译器，如果使用jre（运行环境）则无法获得编译器 JavaCompiler complier=ToolProvider.getSystemJavaCompiler(); int result=complier.run(null, null, null,\"d:/MyJava/Hi.java\"); System.out.println(result==0?\"编译成功\":\"编译失败\"); Runtime run=Runtime.getRuntime(); Process process=run.exec(\"java -cp d:/MyJava Hi\"); BufferedReader br=new BufferedReader(new InputStreamReader(process.getInputStream())); String info=\"\"; while((info=br.readLine())!=null) &#123; System.out.println(info); &#125; &#125;&#125; 编译结果 通过反射机制，启动新的线程去执行 12345678910111213141516171819202122232425262728293031323334353637383940414243package com.zhuchuli.test;import java.io.BufferedWriter;import java.io.FileWriter;import java.io.IOException;import java.lang.reflect.Method;import java.net.URL;import java.net.URLClassLoader;import javax.tools.JavaCompiler;import javax.tools.ToolProvider;/** * 通过反射机制调用执行类 * @author 1huangzewei * */public class Demo03 &#123; public static void main(String[] args) throws IOException &#123; String str=\"public class Hi&#123;public static void main(String[] args) &#123;System.out.println(\\\"Hello Hi haha\\\");&#125;&#125;\"; BufferedWriter bw=new BufferedWriter(new FileWriter(\"d:/MyJava/Hi.java\")); bw.write(str); bw.flush(); //获得系统编译器，如果使用jre（运行环境）则无法获得编译器 JavaCompiler complier=ToolProvider.getSystemJavaCompiler(); int result=complier.run(null, null, null,\"d:/MyJava/Hi.java\"); System.out.println(result==0?\"编译成功\":\"编译失败\"); try &#123; URL[] urls=new URL[] &#123;new URL(\"file:/\"+\"d:/MyJava/\")&#125;; URLClassLoader loader=new URLClassLoader(urls); Class c=loader.loadClass(\"Hi\"); Method m=c.getMethod(\"main\", String[].class); m.invoke(null, (Object)new String[] &#123;&#125;); //m.invoke(null,new String[] &#123;\"a\",\"b\"&#125;); //由于可变参数是Java5.0之后才有。上面的代码会被运行成;m.invoke(null,\"a\",\"b\")，就发生了参数个数不匹配，从而出现错误,因此要加上(Object)转型，避免出现出错; //public static void mmm(String[] a,String[] b) //public static void main(String[] args); &#125;catch(Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 编译结果 动态执行javascript代码 Java脚本引擎是从JDK6.0之后添加的新功能 脚本引擎介绍 使得Java应用程序可以通过一套固定的接口与各种脚本引擎交互，从而达到在Java平台上调用各种脚本语言的目的。 Java脚本API是连通Java平台和脚本语言的桥梁。 可以把一些复杂异变的业务逻辑交给与脚本语言处理，这又大大提高了开发效率。 获得脚本引擎 ScriptEngineManager sem=new ScriptEngineManager(); ScriptEngine engine=sem.getEngineByName(“javascript”); Java脚本API为开发者提供了如下功能： 获取脚本程序输入，通过脚本引擎运行脚本并返回运行结果，这是最核心的接口。 注意是：接口。Java可以使用各种不同的表现，从而通用的调用js、groovy、python等脚本 js使用了:Rhino，Rhino是一种使用Java语言编写的JavaScript的开源实现，原先是由Mozilla开发，现在被集成进入JDK6.0 通过脚本引擎的运行上下文在脚本和Java平台间交换数据。 通过Java应用程序调用脚本函数。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970package com.zhuchuli.rhino;import java.io.FileNotFoundException;import java.io.FileReader;import java.net.URL;import java.util.List;import javax.script.Invocable;import javax.script.ScriptEngine;import javax.script.ScriptEngineManager;import javax.script.ScriptException;/*** * 测试脚本引擎执行JavaScript代码 * @author 1huangzewei * */public class Demo01 &#123; public static void main(String[] args) throws ScriptException, NoSuchMethodException &#123; //获取脚本引擎对象 ScriptEngineManager sem=new ScriptEngineManager(); ScriptEngine engine=sem.getEngineByName(\"javascript\"); //定义变量，存储到引擎上下文中 engine.put(\"msg\", \"lee is a good student\"); String str=\"var user= &#123;name:'aaa',age:18,schools:['gdaib','dgef']&#125;;\"; str += \"print(user.schools);\"; //执行脚本 engine.eval(str); //修改msg的值 engine.eval(\"msg='very happy today'\"); System.out.println(engine.get(\"msg\")); System.out.println(\"--------------------\"); //定义函数 engine.eval(\"function add(a,b)&#123;var sum=a+b;return sum;&#125;\"); //执行js函数 取得调用接口 Invocable jsInvoke=(Invocable) engine; //执行脚本中定义的方法 Object i=jsInvoke.invokeFunction(\"add\", new Object[] &#123;10,20&#125;); System.out.println(i); //导入其他java包，使用其他包中的java类 String jsCode=\"var list=java.util.Arrays.asList([\\\"北京尚学堂\\\",\\\"北京大学\\\"]);\"; engine.eval(jsCode); List&lt;String&gt; list2=(List&lt;String&gt;) engine.get(\"list\"); for(String temp:list2) &#123; System.out.println(temp); &#125; //执行一个JS文件 URL url=Demo01.class.getClassLoader().getResource(\"a.js\"); try &#123; FileReader fr = new FileReader(url.getPath()); engine.eval(fr); fr.close(); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125; 运行结果 动态字字节码操作：javaassist Java动态性的两种常见实现方式： 字节码操作 反射 运行时操作字节码可以让我们实现如下功能 动态生成新的类。 动态改变某个类的结构（添加、删除、修改 新的属性、方法 ） 优势 比反射开销小，性能高。 Javaassist性能高于反射，低于ASM 常见的字节码操作类库 BCEL 基于底层Jvm的操作和指令 ASM 基于底层Jvm的操作和指令 CGLIB 基于ASM实现 Javaassist Javaassist库的API详解 javaassist的最外层的API和java的反射包中的API颇为类似。 它主要有CtClass,CtMethod，以及CtField几个类组成。用以执行和JDK反射API中java.lang.Class,java.lang.reflection.Method，java.lang.reflection.Field相同的操作。 JAVAassist库的简单使用。 创建一个全新的类 使用XJAD反编译工具，将生成的class文件反编译成Java文件\\ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.zhuchuli.javaassist;import java.io.IOException;import javassist.CannotCompileException;import javassist.ClassPool;import javassist.CtClass;import javassist.CtConstructor;import javassist.CtField;import javassist.CtMethod;import javassist.NotFoundException;/*** * 测试 使用javaassist动态生成一个新类 * @author 1huangzewei * */public class Demo01 &#123; public static void main(String[] args) throws CannotCompileException, NotFoundException, IOException &#123; //创建一个类池 ClassPool pool=ClassPool.getDefault(); CtClass cc=pool.makeClass(\"com.zhuchuli.bean.Emp\"); //创建属性 CtField f1=CtField.make(\"private String ename;\",cc); CtField f2=CtField.make(\"private int empno;\",cc); cc.addField(f1); cc.addField(f2); //创建方法 CtMethod c1=CtMethod.make(\"public String getEname()&#123;return ename;&#125; \", cc); CtMethod c2=CtMethod.make(\"public void setEname(String ename)&#123;this.ename=ename;&#125; \", cc); cc.addMethod(c1); cc.addMethod(c2); CtMethod c3=CtMethod.make(\"public int getEmpno()&#123;return empno;&#125; \", cc); CtMethod c4=CtMethod.make(\"public void setEmpno(int empno)&#123;this.empno=empno;&#125; \", cc); cc.addMethod(c3); cc.addMethod(c4); //创建构造器 CtConstructor constructor=new CtConstructor(new CtClass[] &#123;pool.get(\"java.lang.String\"), CtClass.intType&#125;, cc); constructor.setBody(\"&#123;this.ename=ename;this.empno=empno;&#125;\"); CtConstructor constructor2=new CtConstructor(null,cc); cc.addConstructor(constructor); cc.addConstructor(constructor2); cc.writeFile(\"d:/MyJava/Emp.java\");//将创建的这一类存放到指定位置上 &#125;&#125; Javaassist的AIP使用 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package com.zhuchuli.javaassist;import java.lang.reflect.Method;import java.util.Arrays;import javassist.ClassPool;import javassist.CtClass;import javassist.CtMethod;import javassist.Modifier;/*** * 测试Javaassist的API * @author 1huangzewei * */public class Demo02 &#123; //处理类的基本用法 public static void test01() &#123; ClassPool pool=ClassPool.getDefault(); try &#123; CtClass cc = pool.get(\"com.zhuchuli.javaassist.Emp\"); //将类转换成字节数组 byte[] bytes=cc.toBytecode(); System.out.println(Arrays.toString(bytes)); System.out.println(cc.getName());//获取类名 System.out.println(cc.getSuperclass());//获取父类 System.out.println(cc.getInterfaces());//获取接口 System.out.println(cc.getSimpleName ());//获得简要类名 &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; //处理方法的基本用法 产生新的方法 public static void test02() &#123; ClassPool pool=ClassPool.getDefault(); try &#123; CtClass cc = pool.get(\"com.zhuchuli.javaassist.Emp\"); //CtMethod method=CtMethod.make(\"public int add(int a,int b)&#123;System.out.println(\\\"test02\\\");return a+b;&#125;\", cc); //第一个参数为返回值类型,第二个参数为方法名 第三个参数为方法参数 第四个参数为所要加入的对象 CtMethod m=new CtMethod(CtClass.intType, \"add\", new CtClass[] &#123;CtClass.intType,CtClass.intType&#125;,cc); //设置方法的修饰符 m.setModifiers(Modifier.PUBLIC); //设置方法体 $1代表参数位置 m.setBody(\"&#123;System.out.println(\\\"test02\\\");return $1+$2;&#125;\"); cc.addMethod(m); Class&lt;?&gt; clazz=cc.toClass(); Object obj=clazz.getConstructor().newInstance(); Method method=clazz.getDeclaredMethod(\"add\", int.class,int.class); Object result=method.invoke(obj, 200,300); System.out.println(result); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; //... 还有注解 构造器 和 属性 public static void main(String[] args) &#123; test01(); &#125;&#125; JVM运行和类加载全过程 为什么要研究加载全过程？ 有助于了解JVM运行过程 更深入了解Java动态性（解耦部署，动态加载），提高程序的灵活性。 类加载全过程 （如下图所示） 加载 链接 （验证 准备 解析）:将Java类的二进制代码合并到JVM的运行状态之中的过程。 初始化：静态属性或静态方法或静态块只会被初始化一次。 使用 卸载 类的主动引用（一定会发生类初始化） new一个类的对象。 调用类的静态成员（除了final常量）和静态方法。 使用java.lang.reflect包的方法对类进行反射调用。 当虚拟机启动，java hello则一定会初始化Hello类，说白了就是先启动main方法所在的类。 当初始化一个类，如果其父类没有被初始化，则会先初始化他的父类。 类的被动引用 当访问一个静态域时，只有真正声明这个域的类才会被初始化。 通过子类引用父类的静态变量，不会导致子类初始化。 通过数组定义类引用，不会触发此类的初始化 引用常量不会触发此类的初始化（常量在编译阶段就存入调用类的常量池中了）。 深入类加载器 类加载器原理 类加载器的作用：将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区中的运行时数据结构，在堆中生成一个代表这个类的java.lang.Class对象，作为方法区类数据的访问入口。 类缓存：标准的JavaSE类加载器可以按要求查找类，但一旦某个类被加载到类加载器中，它将维持加载（缓存）一段时间。不过JVM垃圾集成器可以回收这些Class对象。 类加载器树状结构，双亲委托（代理）机制 引导类加载器（bootstrap class loader） 扩展类加载器（extensions class loader） 应用程序类加载器（application clasas loader） 自定义类加载器 双亲委托机制是为了保证Java核心库的类型安全。（请求 —&gt; 交给父类 —&gt; 交给爷爷辈） tomcat则与此相反 自定义类加载器（文件、网络、加密） 注意：同一个类被不同的加载器加载，JVM也会认为他们不是相同的类 线程上下文类加载器 服务器类加载器原理和OSGI介绍(面向Java的动态模块系统) Eclipse是基于OSGI技术来构建的","categories":[],"tags":[]},{"title":"文件上传","slug":"文件上传","date":"2019-06-28T01:51:14.000Z","updated":"2019-07-03T09:17:14.711Z","comments":true,"path":"2019/06/28/文件上传/","link":"","permalink":"https://CPWS.github.io/2019/06/28/文件上传/","excerpt":"","text":"1. 文件上传功能的实现上传和下载是Web应用开发需求中出现频率较高的词汇。在JSP应用开发过程中，编写“文件上传”功能代码主要有三种方式： 采用自编写的JavaBean组件 采用JspSmart公司自己编写的JspSmartUnload组件 采用O’Reilly公司的Cos组件 1.1 采用自编写的JavaBean组件 要编写一个实现文件上传功能的组件，首先需要先了解数据传输的原理，根据数据处理的规律来完成相关的编码。步骤为： 1.获取上传数据的规律。案列如下： 12&lt;!--如果要实现文件上传功能 需要添加 enctype=\"MULTIPART/FORM-DATA\"--&gt;&lt;form enctype=\"MULTIPART/FORM-DATA\"&gt;&lt;/form&gt; 12//js版给form添加属性，实现文件上传form.encding=\"multipart/form-data\" 1234567891011121314151617181920212223242526272829&lt;!--index.jsp--&gt;&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;文件上载&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=\"up.jsp\" enctype=\"multipart/form-data\" method=\"post\"&gt; 作者： &lt;input type=\"text\" name=\"author\"&gt;&lt;br&gt; 公司： &lt;input type=\"text\" name=\"company\"&gt;&lt;br&gt; 选择要上传的文件 &lt;input type=\"file\" name=\"filename\"&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"上载\"&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;&lt;!--up.jsp--&gt;&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;jsp:useBean id=\"TheBean\" scope=\"page\" class=\"org.xmh.demo.UploadBean\" /&gt; &lt;% TheBean.doUpload(request); %&gt;&lt;/body&gt;&lt;/html&gt; 12345678910111213141516171819package org.xmh.demo;import javax.servlet.ServletInputStream;import javax.servlet.http.HttpServletRequest;import java.io.BufferedWriter;import java.io.FileWriter;import java.io.IOException;import java.io.PrintWriter;public class UploadBean &#123; public void doUpload(HttpServletRequest request) throws IOException &#123; PrintWriter pw=new PrintWriter(new BufferedWriter(new FileWriter(\"d:\\\\xmh.txt\"))); ServletInputStream in=request.getInputStream(); int i=in.read(); while(i!=-1)&#123; pw.print((char)i); i=in.read(); &#125; pw.close(); &#125;&#125; 编写上传组件。 根据上文所述，如果想要获取表单提取的数据，需要设计一个功能类来处理相关的数据信息。下面设计了一个FileUploadBean.java的类，他就是自定义处理上传功能的类。 使用自编写的上传组件。 案例2 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;自编写上传组件--文件上传示例&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=\"selfBean.jsp\" enctype=\"multipart/form-data\" method=\"post\"&gt; 作者：&lt;input type=\"text\" name=\"author\"&gt;&lt;br&gt; 公司：&lt;input type=\"text\" name=\"company\"&gt;&lt;br&gt; 说明: &lt;textarea name=\"comment\" &gt;&lt;/textarea&gt;&lt;br&gt; 选择要上载的文件: &lt;input type=file name=\"filename\"&gt;&lt;br&gt; 文件描述: &lt;input type=\"text\" name=\"description\"&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"Upload\"&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;jsp:useBean id=\"TheBean\" class=\"org.xmh.demo.FileUploadBean\" scope=\"page\"&gt; &lt;% TheBean.setSavePath(\"d:/\"); TheBean.doUpload(request); out.println(\"Filename:\"+TheBean.getFilename()); out.println(\"&lt;BR&gt;内容类型:\"+TheBean.getContentType()); out.println(\"&lt;BR&gt;作者:\"+TheBean.getFieldValue(\"author\")); out.println(\"&lt;BR&gt;公司:\"+TheBean.getFieldValue(\"company\")); out.println(\"&lt;BR&gt;说明:\"+TheBean.getFieldValue(\"comment\")); %&gt; &lt;/jsp:useBean&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123package org.xmh.demo;import javax.servlet.ServletInputStream;import javax.servlet.http.HttpServletRequest;import java.io.*;import java.util.Hashtable;public class FileUploadBean &#123; private String savePath; private String filepath; private String filename; private String contentType; private Hashtable&lt;String, String&gt; fields; // 返回filename私有域的值 public String getFilename() &#123; return filename; &#125; // 返回filepath私有域的值 public String getFilepath() &#123; return filepath; &#125; // 返回savePath私有域的值 public void setSavePath(String savePath) &#123; this.savePath = savePath; &#125; // 返回contentType私有域的值 public String getContentType() &#123; return contentType; &#125; // 返回HTML表单中指定输入元素的值，元素的名字通过fieldName参数指定 public String getFieldValue(String fieldName) &#123; if (fields == null || fieldName == null) return null; return (String) fields.get(fieldName); &#125; private void setFilename(String s) &#123; if (s == null) return; int pos = s.indexOf(\"filename=\\\"\"); if (pos != -1) &#123; filepath = s.substring(pos + 10, s.length() - 1);// Windows浏览器发送完整的文件路径和名字// 但Linux/Unix和Mad浏览器只发送文件名字 pos = filepath.lastIndexOf(\"\\\\\"); if (pos != -1) filename = filepath.substring(pos + 1); else filename = filepath; &#125; &#125; private void setContentType(String s) &#123; if (s == null) return; int pos = s.indexOf(\": \"); if (pos != -1) contentType = s.substring(pos + 2, s.length()); &#125; //处理请求数据的方法 public void doUpload(HttpServletRequest request) throws IOException &#123; ServletInputStream in = request.getInputStream(); // 创建字节数组充当缓冲容器的作用 byte[] line = new byte[128]; int i = in.readLine(line, 0, 128); if (i &lt; 3) return; // -2丢弃换行字符 int boundaryLength = i - 2; String boundary = new String(line, 0, boundaryLength); fields = new Hashtable&lt;String, String&gt;(); while(i!=-1)&#123; String newLine=new String(line,0,i); if(newLine.startsWith(\"Content-Disposition: form-data; name=\\\"\"))&#123; //判断文件类型 if(newLine.indexOf(\"filename=\\\"\") != -1)&#123; setFilename(new String(line,0,i-2)); if(filename == null)&#123; return; &#125; i=in.readLine(line,0,128); setContentType(new String(line,0,i-2)); i=in.readLine(line,0,128); newLine=new String(line,0,i); PrintWriter pw=new PrintWriter(new BufferedWriter(new FileWriter((savePath == null ? \"\":savePath)+filename))); while(i!=-1 &amp;&amp; !newLine.startsWith(boundary))&#123; //文件的最后一行包含换行符 //因此必须检查当前行是否是最后一行 i=in.readLine(line,0,128); if( (i == boundaryLength+2 || i==boundaryLength+4) &amp;&amp; (new String(line,0,i).startsWith(boundary)))&#123; pw.print(newLine.substring(0,newLine.length()-2)); &#125;else&#123; pw.print(newLine); &#125; newLine=new String(line,0,i); &#125; pw.close(); &#125;else&#123; //普通表单输入元素 //获取输入元素名字 int pos=newLine.indexOf(\"name=\\\"\"); String fieldName=newLine.substring(pos+6,newLine.length()-3); i=in.readLine(line,0,128); newLine=new String(line,0,i); StringBuffer fieldValue=new StringBuffer(128); while(i!=-1 &amp;&amp; !newLine.startsWith(boundary))&#123; //最后一行包含换行符 //因此必须检查当前行是否是最后一行 i=in.readLine(line,0,128); if( (i==boundaryLength+2 || i==boundaryLength+4) &amp;&amp;(new String(line,0,i).startsWith(boundary)))&#123; fieldValue.append(newLine.substring(0,newLine.length()-2)); &#125;else fieldValue.append(newLine); newLine=new String(line,0,i); &#125; fields.put(fieldName,fieldValue.toString()); &#125; &#125; i=in.readLine(line,0,128); &#125; &#125;&#125; 1.2 JspSmartUpload上传组件JspSmartUpload是由JspSmart公司开发的，它可以免费下载，下载地址:https://pan.baidu.com/s/10OTcN5GOwNly-Ty9oybwQQ，提取码：4fzf因为要反馈给用户上传成功与否，所以需要将上传功能的执行顺序优先于表单的文本数据执行。 12345678910111213141516171819202122232425&lt;!--上传界面--&gt;&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;上传图片&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=\"upload_pic.jsp\" method=\"post\" enctype=\"multipart/form-data\" name=\"form1\"&gt; &lt;table border=\"1\" align=\"center\" cellpadding=\"1\" cellspacing=\"1\"&gt; &lt;tr&gt; &lt;td height=\"45\" align=\"center\" valign=\"middle\"&gt; 请选择上传的图片 &lt;input type=\"file\" name=\"file\" /&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td align=\"center\"&gt; &lt;input type=\"submit\" name=\"submit\" value=\"上传\" /&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109&lt;!--处理图片 ， 获取上传图图片，然后生成缩略图 --&gt;&lt;%@ page language=\"java\" pageEncoding=\"utf-8\" import=\"java.util.*,java.io.*\"%&gt;&lt;%@ page import=\"com.jspsmart.upload.SmartUpload\"%&gt;&lt;%@ page import=\"javax.servlet.jsp.tagext.TryCatchFinally\"%&gt;&lt;%@ page import=\"javax.imageio.ImageIO\"%&gt;&lt;%@ page import=\"java.awt.image.BufferedImage\"%&gt;&lt;%@ page import=\"javax.servlet.*\"%&gt;&lt;%@ page import=\"javax.servlet.http.*\"%&gt;&lt;%@ page import=\"java.awt.*\" %&gt;&lt;% String path = request.getContextPath(); String basePath = request.getScheme() + \"://\" + request.getServerName() + \":\" + request.getServerPort() + path + \"/\";%&gt;&lt;% SmartUpload mySmartUpload = new SmartUpload();//实例SmartUpload对象 long file_size_max = 4000000; String fileName2;//文件名 String ext;//文件扩展名 String url = \"D:/\";//应保证在WebRoot目录下有此目录的存在 //初始化 mySmartUpload.initialize(pageContext); //只允许上载此类文件 try &#123; //支持上载文件的后缀名 //mySmartUpload.setAllowedFilesList(\"jpg,gif\"); //mySmartUpload.setAllowedFilesList(\"jpg,gif,jpeg,png\"); //不支持指定的后缀 mySmartUpload.setDeniedFilesList(\"exe\"); //上载文件 mySmartUpload.upload();//不指定编码的upload()方法 //mySmartUpload.upload(\"utf-8\");//指定编码的upload()方法 &#125; catch (Exception e) &#123; out.print(\"&lt;script type=\\\"text/javascript\\\"&gt;\"); out.print(\"window.alert(\\\"文件格式不符\\\");\"); out.print(\"window.location=\\\"upload.html;\\\"\"); out.print(\"&lt;/script&gt;\"); &#125; try &#123; com.jspsmart.upload.File myFile = mySmartUpload.getFiles().getFile(0); if (myFile.isMissing()) &#123;//如果没有拿到文件，提示 out.print(\"&lt;script type=\\\"text/javascript\\\"&gt;\"); out.print(\"window.alert(\\\"请先选择要上传的文件\\\");\"); out.print(\"window.location=\\\"upload.html;\\\"\"); out.print(\"&lt;/script&gt;\"); &#125; else &#123; String myFileName = myFile.getFileName();//取得上载的文件的文件名 ext = myFile.getFileExt();//取得后缀名 if (!(ext.length() &gt; 0)) &#123; out.println(\"**************myFileName的文件名是：\" + myFileName); &#125; int file_size = myFile.getSize();//取得文件的大小 String saveUrl = \"\";//文件保存路径 if (file_size &lt; file_size_max) &#123; //更改文件名，取得当前上传时间的毫秒数值 Calendar calendar = Calendar.getInstance(); String fileName = String.valueOf(calendar.getTimeInMillis());//设置新的文件名 saveUrl += fileName + \".\" + ext; myFile.saveAs(saveUrl, mySmartUpload.SAVE_PHYSICAL);//保存文件 //上传完成，开始生成缩略图 java.io.File file = new java.io.File(saveUrl);//读入刚才上传的文件 out.println(\"ext = \" + ext); String newUrl = url + fileName + \"_min.\" + ext;//新的缩略图保存地址 System.out.println(newUrl); BufferedImage image=ImageIO.read(file); int imageWidth=image.getWidth(); //取出图片额宽度 int imageHeight=image.getHeight();//取出图片的高度 int n_w=0; //缩略图的宽度 int n_h=0; //缩略图的高度 System.out.println(\"imageWidth=\"+imageWidth + \";\"+\"imageHeight=\"+imageHeight); float tempDouble; if(imageHeight &gt; imageWidth)&#123; tempDouble = imageHeight /200; &#125;else&#123; tempDouble = imageWidth /200; &#125; n_w = (int) (imageWidth/tempDouble); n_h = (int) (imageHeight/tempDouble); FileOutputStream fos=new FileOutputStream(newUrl); BufferedImage bi=new BufferedImage(n_w,n_h,BufferedImage.TYPE_INT_RGB); Graphics g=bi.getGraphics(); g.drawImage(image,0,0,n_w,n_h,Color.LIGHT_GRAY,null); g.dispose(); ImageIO.write(bi,\"jpg\",fos); &#125; else &#123; out.print(\"&lt;script type=\\\"text/javascript\\\"&gt;\"); out.print(\"window.alert(\\\"上传文件大小不能超过\\\"+(file_size_max/1000)+\\\"K\\\");\"); out.print(\"window.location=\\\"upload.html;\\\"\"); out.print(\"&lt;/script&gt;\"); &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;%&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;处理上传的图片&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 1.3 Cos上传组件 （Cloud Object Storage） Cos组件是O&#39;Reilly公司开发的一款免费组件。 Cos包下载地址：http://www.servlets.com/cos/2.3.1 在Cos组件中MultipartRequest类主要负责文件上传的处理 (1) MultipartRequest有8个构造函数，它们分别是： public MulipartRequest(HttpServletRequest request,String saveDirectory) throws IOException public MultipartRequest(HttpServletRequest request,String saveDirectory,int maxPostSize) throws IOException public MiltipartRequest(HttpServletRequest request,String saveDirectory,int maxPostSize,FileRenamePolicy policy) throws IOException public MultipartRequest(HttpServletRequest request,String saveDirectory,int maxPostSize,String encoding) throws IOException public MultipartRequest(HttpServletRequest request,String saveDirectory,int maxPostSize,String encoding,FileRenamePolicy policy) throws IOException public MultipartRequest(HttpServletRequest request,String saveDirectory,String encoding) throws IOException public MulipartRequest(HttpServletRequest request,String saveDirectory) throws IOException public MulipartRequest(HttpServletRequest request,String saveDirectory,int maxPostSize)throws IOException (2) MultipartRequest类工具有8中方法： public Enumeration getParameters(): 取得请求参数的名称 public String getParameter(String name): 此方法返回参数为name的值 public String[] getParameterValues(String name)：当指定参数具有多个值时，此方法会返回String数组 public Enumeration getFileName()：传回所有文件输入类型的名称 public String getFilesystemNames(String name)： 用此方法得到上传文件的真正的文件名称，这里的name指文件输入类型的名称 public String getContentType(String name)： 此方法得到上传文件的文件类型 public File getFile(String name)：此方法得到一个文件对象，代表存储在服务器上的name值 public String getOriginalFileName(String name)：返回文件在修改政策有效之前的文件名称。 注意：Cos组件在上传大容量文件时，效率比起前面介绍的自编写JavaBean组件和JspSmart上传组件高。 案例： 1234567891011121314151617181920&lt;!--upload.html--&gt;&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;style&gt; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!--enctype的值很重要，upload.jsp处理上传的JSP--&gt; &lt;form action=\"upload.jsp\" enctype=\"multipart/form-data\" name=\"form1\" method=\"post\"&gt; &lt;p&gt;&lt;input type=\"file\" name=\"file1\"&gt;&lt;/p&gt; &lt;p&gt;&lt;input type=\"file\" name=\"file2\"&gt;&lt;/p&gt; &lt;p&gt;&lt;input type=\"file\" name=\"file3\"&gt;&lt;/p&gt; &lt;p&gt;&lt;input type=\"submit\" name=\"Submit\" value=\"上传\"&gt;&lt;/p&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324252627282930313233&lt;%@ page import=\"java.io.File\" %&gt;&lt;%@ page import=\"com.oreilly.servlet.MultipartRequest\" %&gt;&lt;%@ page import=\"java.util.Enumeration\" %&gt;&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;% //文件上传后，保存在d:/JavaWebs String saveDirectory=\"d:\"+ File.separator+\"JavaWebs\"; //每个文化最大500M,最多三个文件，所以... int maxPostSize=3*500*1024*1024; //response的编码为gd2312，同时采用缺省的文件名冲突解决策略，实现上传 MultipartRequest multi=new MultipartRequest(request,saveDirectory,maxPostSize,\"UTF-8\"); //输出反馈信息 Enumeration files=multi.getFileNames(); while (files.hasMoreElements())&#123; System.err.println(\"ccc\"); String name= (String) files.nextElement(); File f=multi.getFile(name); if(f!=null)&#123; String fileName=multi.getFilesystemName(name); String lastFileName=saveDirectory+\"\\\\\"+fileName; out.println(\"上传的文件:\"+lastFileName); out.println(\"&lt;hr&gt;\"); &#125; &#125;%&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 以上内容大部分都是参考一本书叫做《软件开发 JSP》，感谢作者!!!!","categories":[],"tags":[]},{"title":"解决中文乱码","slug":"解决中文乱码","date":"2019-06-28T01:47:18.000Z","updated":"2019-06-28T01:50:29.669Z","comments":true,"path":"2019/06/28/解决中文乱码/","link":"","permalink":"https://CPWS.github.io/2019/06/28/解决中文乱码/","excerpt":"","text":"1.1 熟悉Web应用程序中与编码相关的部分 JSP编译 指定文件的存储编码,很明显。该设置应该位于文件的开头：&lt;%@page pageEncoding=&quot;UTF-8&quot; %&gt; 另外对于一般的class文件，可以在编译的时候指定编码。 JSP输出 指定文件输出到Browser时的使用的编码，该设置也应该设置在文件的开头。&lt;%@page contentType=&quot;text/html;charset=UTF8&quot; %&gt; 该设置与response.setCharacterEncoding(&quot;GBK&quot;);等效 META设置 指定网页使用的编码，该设置对静态网页尤其有用，因为静态网页无法使用采用JSP的设置而且也无法执行response.setCharacterEncoding(&quot;UTF-8&quot;) ；例如：&lt;meta http-equiv=&quot;Content-Type&quot; contentType=&quot;text/html;charset=UTF-8&quot;/&gt; 注意：如果同时采用了JSP输出和meta设置两种编码指定方式，那么JSP指定的优先。因为JSP指定的直接体现在Response中。 Form设置 当浏览器提交表单时，可以指定相应的编码，例如:&lt;form accept-charset=&quot;UTF-8&quot;&gt;&lt;/form&gt;一般不需要设置，浏览器会直接使用网页的编码 1.2 熟悉Web应用程序产生中文乱码的原因 JSP页面被编译成class文件时,如果未指定字符集时,默认使用ISO-8859-1的编码格式，这样中文会出现乱码。 提交表单时如果设定提交方式为Post而没有设置提交的编码的格式，则会以ISO-8859-1方式提交，而接收的JSP却以UTF-8的方式接收，这样也会导致中文乱码。 提交表单时如果设定提交方式为Get而没有设置提交的编码的格式，Tomcat会以GET的默认编码格式ISO8859-1对汉字进行编码，编码后追加到URL，导致接收页面得到的参数为乱码。 1.3 解决中文乱码 设置文件本身的编码格式。这可以在Eclipse或MyEclipse中进行设置。 在JSP页面中指定字符集，通常页面字符集的设置如下： 1234567&lt;%@ page contentType=\"text/html;charset=UTF-8\" %&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=\"Content-Type\" contentType=\"text/html;charset=UTF8\"/&gt; &lt;title&gt;字符集设置联系&lt;/title&gt; &lt;/head&gt;&lt;/html&gt; 数据库连接时指定的字符集。 1String url=\"jdbc:msqyl://localhost:3306/test?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=UTF-8\" 在程序中获取页面数据时使用如下代码 12response.setContentType(\"text/html;charset=UTF-8\");request.setCharacterEncoding(\"UTF-8\"); 注意： 如果需要将中文作为参数传递，需要在传递和接受时进行相应的处理、具体方法如下所示： 在传递参数时对参数编码 : &quot;...RearshRes.jsp?keywords=&quot;+java.net.URLEncoder.encode(keywords) 然后在接收参数页面中使用如下语句接收 keywords=new String(request.getParameter(&quot;keywords&quot;).getBytes(&quot;ISO-8859-1&quot;))","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2019-06-27T05:37:31.802Z","updated":"2019-06-27T05:45:09.482Z","comments":true,"path":"2019/06/27/hello-world/","link":"","permalink":"https://CPWS.github.io/2019/06/27/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Hello HexoCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}
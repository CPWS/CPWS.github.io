{"meta":{"title":"Prossible's Blog","subtitle":null,"description":null,"author":"zhuli","url":"https://CPWS.github.io","root":"/CPWS.github.io/"},"pages":[{"title":"tags","date":"2019-12-05T08:21:04.000Z","updated":"2019-12-05T08:22:35.561Z","comments":true,"path":"tags/index.html","permalink":"https://CPWS.github.io/tags/index.html","excerpt":"","text":""},{"title":"about","date":"2019-12-05T10:37:49.000Z","updated":"2019-12-05T11:00:51.483Z","comments":true,"path":"about/index.html","permalink":"https://CPWS.github.io/about/index.html","excerpt":"","text":"本人准大三学生，本人主学Java方向业余时间学学前端"}],"posts":[{"title":"英语四级作文","slug":"英语四级作文","date":"2019-12-11T06:54:39.000Z","updated":"2019-12-11T11:04:43.509Z","comments":true,"path":"2019/12/11/英语四级作文/","link":"","permalink":"https://CPWS.github.io/2019/12/11/英语四级作文/","excerpt":"","text":"作文1： the importance of reading ability and how to develop it .1234567891011 As the most frequently used way to get access to the original material,reading has always been considered one of the most important parts of language learning.This explains why reading skills should be highly emphasized. Then how to improve our reading skills?First of all,scan the materia before we begin.Whateverthe purpose of our reading is,take a few minutes to look the piece over to check and how the work is structured and presented.Secondly,try not reach for the dictionary when we come to a word wedont&apos;t know,Instead,try to guess the meaning of the word based on the context.Last but not lease,write a few sentences to summarize what we&apos;ve read since it is a way of checking that weunderstand what we&apos;ve reading. Above all,reading has important benefitsand can help us learn language faster and morecompletely,which encourages each language learner to develop their reading skill as suggested. 短语积累: get access to：获得，接近，可以使用 emphasized：重视 作文2：自立 Directions:For this part, you are allowed 30 minutes to write a short essay. You should start your essay with a brief description of the picture and then express your views on self-reliance. You should write at least 120 words but no more than 180words. “It’s not my fault. Bad grades wouldn’t matter if I had been born rich.” 12345678910111213 As is vividly depicted in the picture,a boy is complaining to his parents that if he had been born with a sliver spoon in his mouth,bad grades wouldn&apos;t matter. The picture reflects a serious social problem that nowadays some children are more dependent on their parents.They lack self-reliance. It is widely acknowledged that self-reliance is indispensable to everyone.self-reliance plays an important role in the cultivation of creativity.Relying on others meaning repetition，imitation and few efforts,which may not lead to innovation，an element greatly needed in this era of competition.For another，what is offered by others is not limitless.If children do not depend on themselves,one day when nobody offers them anything anymore,they will fail with reget. In view of the seriousness of the problem,it is high time for children to relize theimportance of self-reliance.As for adults,they should encourage their children to confront challenge by themselves;As for children,they should keep &quot;No pain,no gain&quot; in mind and strive for their dreams independently. 生词积累 vividly：生动地，强烈地 depict：描述，描绘 indispensable:不可或缺的，绝对必要的 cultivation：培养、耕种 repetition：重复 innovation:创新，革新，新方法 strive：努力，奋斗 短语积累 As is vividly depicted in the picture：如图所示 sliver spoon：银汤匙 in the era of competiotion：竞争时代","categories":[{"name":"front-end","slug":"front-end","permalink":"https://CPWS.github.io/categories/front-end/"}],"tags":[{"name":"英语四级作文","slug":"英语四级作文","permalink":"https://CPWS.github.io/tags/英语四级作文/"}]},{"title":"专插本c语言","slug":"专插本c语言","date":"2019-12-02T04:30:19.000Z","updated":"2019-12-10T13:16:12.372Z","comments":true,"path":"2019/12/02/专插本c语言/","link":"","permalink":"https://CPWS.github.io/2019/12/02/专插本c语言/","excerpt":"","text":"最简单的C语言程序1234567#include &lt;stdio.h&gt;int main()&#123; printf(\"世界，你好\\n\"); return 0; &#125; main是主函数的函数名，表示这是一个主函数。 每一个C源程序都必须有且只能有一个主函数（main函数）。 函数调用语句printf()函数的功能是把要输出的内容送到显示器去显示。 printf()函数是一个由系统定义的标准函数，可以在程序中直接调用。 1234567891011#include &lt;stdio.h&gt;#include &lt;math.h&gt;int main()&#123; double x,s; printf(\"input number:\\n\"); scanf(\"%lf\",&amp;x); s=sin(x); printf(\"sin of %lf is %lf\\n\",x,s); return 0;&#125; include称为文件包含命令 扩展名为.h的文件称为头文件 定义两个实数变量，以被后面程序使用显示提示信息。 从键盘中获得一个实数x 求x的正弦，并把它赋值给s 显示程序运算结果 main函数结束。 例题 1234567891011121314151617#include &lt;stdio.h&gt;int max(int a,int b); //函数说明 int main()&#123; //主函数 int x,y,z; //变量说明 int max(int a,int b); //函数说明 printf(\"input two numbers:\\n\"); scanf(\"%d%d\",&amp;x,&amp;y); // 输入x,y值 z=max(x,y); //调用max函数 printf(\"max num = %d\",z); //输出 return 0;&#125;int max(int a,int b)&#123; //定义max函数 if(a&gt;b)return a; //把结果返回主调函数 else return b; &#125; 数据类型、运算符和表达式数据类型 基本类型：整型、字符型、实型（浮点型：（单精度，双精度）），枚举类型。 指针类型 构造类型：数组类型，结构体类型，共用体类型。 空类型 基本数据类型：基本数据类型最主要的特点是。其值不可以再分解为其他类型。也就是说，基本数据类型就是自我说明的。 构造数据类型：构造数据类型是根据已定义的一个或多个数据类型用构造方法来定义的。也就是说，一个构造类型的值可以分解成若干个“成员”或“元素”。每个“成员”都是一个基本数据类型或又是一个构造类型。在c语言中，构造类型有以下几种。 数组类型 结构体类型 共用体（联合）类型 指针类型：指针是一种特殊的，同时又是具有重要作用数据类型。其值用来表示某个变量在内存存储器中的地址。虽然指针变量的取值类似于整形量，但，这两个类型完全不同的量，因此不能混为一谈。 空类型：在调用函数值时，通常应向调用者返回一个函数值。这个返回的函数值是具有一定的数据类型的，应在函数定义及函数说明中给以说明，例如在例题中给出的max函数定义中，函数头为：int max(int a,int b);其中int类型说明符表达该函数的返回值整形量。但是，也有一类函数，调用后并不需要向调用者返回函数值，这种函数可以定义为“空类型”。其类型说明符为void。 常量和变量 对于基本数据类型，按照其值是否可改变又分为常量和变量两种。 在程序运行中，其值不发生改变的量称为常量，其值是可以改变的量称为变量。 它们可以与数据类型结合起来分类。例如：可以分为整型常量，整型变量，浮点常量，浮点变量，字符常量，字符变量，枚举常量，枚举变量。在程序中，常量可以不经说明而直接引用的，而变量则必须先定义后使用。 整形量包括整型常量和整型变量。 在程序执行过程中，其值不可以发生改变的量称之为常量。 符号常量：用标识符表示一个常量。在C语言中，可以用一个标识符来表示一个常量，称之为符号常量。 符号常量在使用之前必须先定义，其一般形式为：#define 符号量 常量 其中#define是一条预处理命令（预处理命令都以“#”开头），称为宏定义命令，其功能是把该标识符定义为其后的常量值。一经定义，以后再程序中所有出现该标识符的地方均带之以常量值。 习惯上符号常量的标识符用大写字母，变量标识符用小写字母，以示区分。 123456789#include &lt;stdio.h&gt;#define PRICE 30;int main()&#123; int num,total; num=10; total=num*PRICE; printf(\"total=%d\\n\",total);&#125; 用标识符表示一个常量，称为符号常量。 符号常量与变量不同的是，它的值在程序运行作用域内不会发生改变，也不能在被赋值。 使用符号常量的好处 含义清楚； 能做到“一改全改”； 变量：其值可以改变的量称为变量。一个变量应该有一个名字，在内存中占据一定的存储单元。变量定义必须放在变量使用之前。一般放在函数体的口头部分。要区分变量名和变量值两个概念。 整型数据 整型常量的表示方式（在程序中是根据前缀来区分各种进制数的。） 整型常量就是整常数。在C语言中，使用的整常量有八进制、十六进制和十进制三种。 十进制正常数：十进制正常数没有前缀。其数码为0~9。（以下是合法的十进制常数：237,-568,65535,1627）。 八进制整常数：八进制正常数必须以0开头，即以0作为八进制数的前缀。数码取值为0~7。八进制数通常是无符号数。（以下是合法的八进制数：015（十进制数13），0101（十进制数65），0177777(十进制数65535)） 十六进制整常数：十六进制整常数的前缀为0X或0x。其数码取值为09，AF或a~f。以下是合法的十六进制整常数（0X2A（十进制数42），0XA0（十进制数160），0XFFFF（十进制数为65535）） 整型常数的后缀：在16位字长的机器上，其本整型的长度也为16位，因此表示的数的范围也是有限的。十进制的无符号整常数的范围的065535，有符号为-32768+32767。八进制的无符号的数的表示范围为00177777.十六进制的无符号的数的表示范围0x00xffff或0x0~0XFFFF。如果使用的数超过了上述范围，就必须使用长整型数来表示。长整型数是用后缀“L”或“l”来表示的。 整型变量 int k=3; 整型变量在内存中是以二进制的方式存储。 补充：内存中的二进制存储(常识：一个字节BYTE=8位bit) 数值是以补码表示的 正数的补码与原码相同； 负数的补码：将该数的绝对值的二进制形式按位取反再加1。 整型变量的分类（注意:这里占多少字节与系统何编辑器规定有关！可以在编辑器中查看） 基本型：类型说明符为int，在内存中占4个字节。 短整量：类型说明符为short或 short int。所占节点和取值范围与基本类型相同。 长整型：类型说明符为long或 long int。在内存中占4个字节。 无符号型：类型说明符为：unsigned。 整型变量的定义 形式：类型说明符 变量名标识符，变量名标识符...; 例如：int a,b,c;(a,b,c为整型变量)、long x,y;(x,y为长整型变量)、unsigned p,q;（p,q为无符号整型变量） 在书写变量定义时，应注意如下几点： 允许在一个类型说明符后，定义多个相同类型的变量。各变量名之间用“,”隔开。类型说明符与变量名之间至少用一个空格隔开。 最后一个变量名之后必须以“;”结尾。 变量定义必须放在变量使用之前。一般放在函数体的开头部分。 12345678910#include &lt;stdio.h&gt;int main()&#123; int a,b,c,d; unsigned u; a=12; b=-24; u=10; c=a+u;d=b+u; printf(\"a+u=%d，b+u=%d\\n\",c,d);&#125; 整型数据的溢出 123456789#include &lt;stdio.h&gt;//整型数据的溢出 int main()&#123; short int a,b; a=32767; b=a+1; printf(\"%d,%d\\n\",a,b); return 0;&#125; 123456789101112//不同数据类型之间的运算int main()&#123; long x,y; int a,b,c,d; x=5; y=6; a=7; b=8; c=x+a; d=y+b; printf(\"c=x+a=%d,d=y+b=%d\\n\",c,d);&#125; 实型数据 实型常量的表示方法 实型也称为浮点型。实型常量也称为实数或者浮点数。在c语言中，实数只采用十进制。它有二中形式：十进制小数形式，指数形式。 十进制数形式：由数码0~9和小数点组成 例如0.02,5.0,5.789,0.13,5.0,300.,-267.8230等均为合法的实数。注意：必须有小说点. 指数形式：由十进制数，加阶码标志e和E以及阶码（只能是整数，可以带符号）组成。 aEm (a为十进制数，n为十进制整数) 标准C允许浮点数使用后缀。后缀为“F”或者“f”即表示该数为浮点数。如356f和356.是等价的。 实型数据在内存中的存放形式 实型数据一般占4个字节（32位）内存空间。按指数形式存储。实数3.14159在内存中的存放形式如下： 符号 小数部分 指数部分 + .314159 1 小数部分占的位（bit）愈多，数的有效数字就愈多，精度俞高 指数部分占的位数愈多，则能表示的数值范围愈大。 实型变量的分类 单精度（float）和双精度（double），长双精度（long double）三类。 单精度值显示7位有效数字。数值范围：3.4E-38~3.4E+38 双精度显示16位有效数字。数字范围：1.7E-308~1.7E+308 实型数据的舍入误差 由于实型变量是由有限的存储单元组成的，因此能提供的有效数字总是有限的。 12345678int main()&#123; float a,b; a=123456.789e5; b=a+20; printf(\"%lf\\n\",a); printf(\"%lf\\n\",b); return 0;&#125; 练习： 1.0/3*3等于多少？ 3/2呢？ 1/3*3呢？ 编程（1）（2）（3） 123456int main()&#123; printf(\"%f\\n\",1.0/3*3); //3.00000 printf(\"%f\\n\",1/3*3); //0.0000 printf(\"%f\\n\",3/2);//0.00000 return 0;&#125; 字符型数据 字符型数据包括字符常量和字符变量 字符常量 字符常量是用单引号括起来的一个字符。 例如’a’,’b’,’=’,’+’,’?’都是合法的字符常量。 在C语言中，字符常量有以下特点: 字符常量只能用单引号括起来，不能用双引号或其他括号。 字符常量只能是单个字符，不能是字符串。 字符可以是字符集中任意字符。但是数字被定义为字符型之后就不能参与数值运算。如’5’和5是不同的。’5’是字符常量，不能参与运算。 字符变量 字符变量：字符变量用来存储字符常量，即单个字符。 字符变量的类型说明符是char。字符变量类型定义格式和书写规则都与整形变量相同。例如 char a,b; 转义字符：转义字符是一种特殊的字符常量。转义字符是以反射线“\\”开头，后跟一个或多个字符。转义字符具有特定的含义，不同于字符原有的意义，古称“转义”字符。例如：在前面各例题printf函数的格式中用到“\\n”就是一个转义字符，其意义就是“回车换行”。转义字符主要用来表示那些用一般字符不便于表示的控制代码。 字符型数据常用的转义字符及其含义 转义字符 转义字符的意义 ASCII代码 \\n 回车换行 10 \\t 横向调到下一制表位置 9 \\b 退格 8 \\r 回车 13 \\f 走纸换页 12 | 反斜线符”” 92 &#39; 单引号符 39 &quot; 双引号 34 \\a 鸣铃 7 \\ddd 1~3位八进制数所代表的字符 \\xhh 1~2位十六进制数所代表的字符 练习 123456int main()&#123; int a,b,c; a=5;b=6;c=7; printf(\" b c\\ted\\rf\\n\"); printf(\"hijk\\tL\\bM\\n\");&#125; 字符数据在内存中的存储形式及使用方法 每个字符变量被分配一个字节的内存空间，因此只能存放一个字符。字符值是以ASCII码的形式存放在变量的内存单元之中的。 如x的十进制ASCII码值是120，y的十进制数ASCII码是121。对字符变量a,b赋值’x’，’7’值： a=’x’;b=’7’; 实际上是在a,b两个单元内存中存放120和55的二进制代码 ‘A’的ASCII值：65；’a’的ASCII值：97；’0’的ASCII值48； 练习：向字符变量赋以整数 123456789101112//-128~127//197int main()&#123; //字符变量 ASCII值 SetConsoleOutputCP(437); char a,b; a=197; b=198; printf(\"%d\\n\",sizeof(char)); printf(\"%c,%c\\n\",a,b); printf(\"%d,%d\\n\",a,b); &#125; 练习2：小写字符换大写字母 123456789int main()&#123; char a,b; a='a'; b='b'; a=a-32; b=b-32; printf(\"a=%c,b=%c\\na=%d,b=%d\",a,b,a,b); return 0; &#125; 练习3：比较char a=33与int b=33; 1234567int main()&#123; char a;int b; a=33; b=33; printf(\"a=%d,b=%d\",a,b); return 0; &#125; 字符串常量 字符串常量是由一对双引号括起来的字符序列。例如：”CHINA”、”C Program”等都是合法的字符串。 字符串常量和字符常量是不同的量。他们之间的主要区别如下：(补充：char占八位而已！) 字符常量由单引号括起来，字符串常量由双引号括起来的。 字符常量只能是单个字符，字符串常量则可以包含一个或多个字符。 可以把一个字符常量赋值给字符串常量，但不能把一个字符串常量赋值给一个字符常量。例如：可以char a=&#39;a&#39; 不能char a=&quot;a&quot; 字符常量占一个字节的内存空间。字符串常量占的内存字节数等于字符串中字节数加1。增加的一个字节中存放字符\\0(ASCII为0)。这是字符串结束的标志。 各类数值型数据之间的混合运算 变量的数据类型是可以转换的。转换的方式有两种，一种是自动转换，一种是强制转换。自动转换发生在不同数据类型的量混合运算时，有编译系统自动完成。自动转换遵循以下规则： 若参与运算的类型不同，则先转换成同一类型，然后进行运算。 转换按数据长度增加的方向进行，以保证精度不降低。如int型和long型运算时，先把int量转换成long型后再进行计算。 所有的浮点运算都是以双精度进行的，即使仅含有float单精度量运算的表达式，也要转换成double型，再做运算。 char型和short型参与运算时，必须转换成int型。 在赋值运算时，赋值号两边量的数据类型不同时，赋值号右边量的类型将转换成左边量的类型。如果右边量的数据类型长度比左边长时，将丢失一部分数据，这样会降低精度，丢失的部分按四舍五入的方式向前舍入。 类型自动转换规格 double&lt;---long&lt;----unsigned&lt;---int &lt;----short char 练习1 123456int main()&#123; float PI=3.14159; double s;int r=5; s=r*r*PI; printf(\"s=%lf\\n\",s);&#125; 练习2 实现四舍五入 12345int main()&#123; float a=4.49; int c= (int)(a+0.5); printf(\"%d\",c);&#125; 强制类型转换 强制类型转换是通过类型转换运算来实现的。 其一般形式类：（类型说明符）(表达式)：其功能是把表达式的运算结果强制转换成类型说明符所表示的类型。 例如 (float) a：把a转换为实型；(int)(x+y)：把x+y结果转换为整型. 在使用强制转换时应注意以下问题： 类型说明符和表达式都必须加括号（单个变量可以不加括号）。 无论是强制转换或是自动转换，都是为了本次的运算的需要而对变量的数据长度进行的临时性转换，而不改变数据说明时对该变量的定义的类型。 练习1 1234int main()&#123; float f=5.75; printf(\"(int)f=%d,f=%f\",(int)f,f);&#125; 算术运算符和算数表达式 加法运算符”+”：加法运算符为双目运算符，即应有两个量参与加法运算。如a+b,a+8等。具有结合性。 减法运算符”-“：减法运算符为双目运算符。但“-”也可以做负值运算符，此时是单目运算符。如-x，-5等具有左结合性。 乘法运算符”*”：双目运算，具有左结合性。 除法运算符”/“：双目运算具有左结合性。参与运算量均为整型时，结果也是整型，舍去小数。如果运算中有一个是实型，则结果为double型。 求余数”%”：双目运算符，具有左结合性。 练习1 1234#include &lt;stdio.h&gt;int main()&#123; printf(\"%f\",3.0/4);&#125; 练习2 12345#include \"stdio.h\"int main()&#123; printf(\"\\n\\n%d,%d\\n\",20/7,-20/7); printf(\"%f,%f\\n\",20.0/7,-20.0/7);&#125; 练习3 1234#include &lt;stdio.h&gt;int main()&#123; printf(\"%d\\n\",100%3);&#125; 运算符的优先级：C语言中，运算符的运算优先级共分为15级。1级最高，15级最低。在表达式中，优先级较高的优先于优先级较低的进行运算。而在一个运算量两侧的运算符优先级相同时，则按运算符的结合性所规定的结合方向处理。 运算符的结合性:C语言中各运算符的结合性分为两种，即左结合性（自左至右）和右结合性（自右至左）。 自增、自减运算符 自增1，自增1运算符：自增1运算符记为&quot;++&quot;，其功能是使变量的值自增1； 自减1，自减1运算符：自减1运算符记为&quot;--&quot;，其功能是使变量的值自减1； 自增1，自减1运算符均为单目运算符，都具有结合性。可以有一下几种形式： ++i：i自增1后再参与其他运算。 –i：i自减1后再参与其他运算。 i++：i参与运算后，在自增1. i–：i参与运算后，在自减1. i++，i–要仔细分析。 练习1 123456789101112#include &lt;stdio.h&gt;int main()&#123; int i=8; printf(\"%d\\n\",++i);//9 printf(\"%d\\n\",--i);//8 printf(\"%d\\n\",i++);//8 printf(\"%d\\n\",i--);//9 printf(\"%d\\n\",-i++);//-8 printf(\"%d\\n\",-i--);//-9 printf(\"%d\\n\",i);//8 return 0;&#125; 练习2 12345678#include &lt;stdio.h&gt;int main()&#123; int i=5,j=5,p,q; p=(i++)+(i++)+(i++); q=(++j)+(++j)+(++j); printf(\"%d,%d,%d,%d\",p,q,i,j); return 0;&#125; 赋值运算符与赋值表达式 简单赋值运算符和表达式：简单赋值运算符记为”=”。由”=”连接的式子称为赋值表达式。其一般形式为：变量=表达式 例如： x=a+b; w=sin(a)+sin(b)； 赋值运算符的功能是计算表达式的值再赋值左边的变量。 赋值运算符具有右结合性。 类型转换 12345678910111213#include &lt;windows.h&gt;#include &lt;stdio.h&gt;int main()&#123; SetConsoleOutputCP(437); int a,b=232; float x,y=8.88; char c1='k',c2; a=y;//8 x=b;//232.0000 a=c1;//107 c2=b; printf(\"%d,%f,%d,%c\",a,x,a,c2);&#125; 复合的赋值运算符 在赋值符=之前加上其他二目运算符即可构成复合赋值符。如+=、-= 复合赋值符能提高编译效率并产生质量较高的目标代码。 逗号运算符和逗号表达式 在C语言中逗号”,”也是一种运算符，称为逗号运算符。其功能是把两个表达式连接起来组成一个表达式，称为逗号表达式。 其一般形式为：表达式1，表达式2 其求值过程是分别求两个表达式的值，并以表达式2的值作为整个逗号表达式的值。 12345678#include &lt;windows.h&gt;#include &lt;stdio.h&gt;int main()&#123; int a=2,b=4,c=6,x,y; y=((x=a+b),(b+c)); printf(\"y=%d,x=%d\",y,x); return 0;&#125; 对于逗号表达式还要说明两点 逗号表达式一般形式中的表达式1和表达式2也可以又是逗号表达式。如(表达式1,(表达式3,表达式2))形成了嵌套情形。因此可以把逗号表达式扩展为以下形式：y=(表达式1,表达式2);，整个逗号表达式的值等于等于表达式n的值。 程序中使用逗号表达式，通常是要分别求逗号表达式内各表达式的值，并不一定要求整个逗号表达式的值。 顺序程序设计 从程序的流程来看，程序可以分为三种基本结构：顺序结构、分支结构、循环结构。 C基本语句介绍 C程序的执行部分是由语句组成的。程序的功能也是由执行语句实现的。 C语句可以分为以下5类： 表达式语句 函数调用语句 控制语句 复合语句 空语句 表达式语句：表达式语句有表达式+分号组成； x=2; 函数调用语句：由函数名和实际参数，加上”;”组成；其一般形式：函数名(实际参数表);printf(&quot;hello world&quot;); 复合语句:{x=y+x;x=2;y=2;} 控制语句:循环语句(while、do..while,for) 空语句：while(1){...} 赋值语句：赋值表达式+分号组成 数据输入输出的概念以及C语言中的实现 所谓输入输出是以计算机为主体而言的。 本章所介绍的是向标准输出设备显示器输出数据的语句。 在C语言中，所有的数据输入/输出都是由库函数完成的。因此都是函数语句。 在使用C语言函数库时，要用到预编译命令#include，将有关“头文件”包含到源文件中。使用标准输入输出库函数时需要用到”stdio.h”文件，因此源文件开头应有以下预编译命令：#include &quot;stdio.h&quot;或#include &lt;stdio.h&gt;，stdio是标准input或output意思。 考虑到printf和scanf函数使用频繁，系统允许在使用这两个函数时不加#include&lt;stdio.h&gt;或#include &quot;stdio.h&quot; putchar函数(字符输出函数) putchar是字符输出函数，其功能是在显示器上输出单个字符。 其一般形式为 putchar(字符变量) 例如：putchar(‘a’);puthchar(x); 对于控制字符则执行控制功能，不在屏幕上显示。 使用本函数之前必须要用文件包含命令#include &quot;stdio.h&quot;或#include &lt;stdio.h&gt; 练习1：输出单个字符 12345678#include &lt;stdio.h&gt;int main()&#123; char a='B',b='o',c='k'; putchar(a);putchar(b);putchar(b);putchar(c);putchar('\\t'); putchar(a);putchar(b); putchar('\\n'); putchar(b);putchar(c);&#125; getChar函数(键盘输入函数) getchar函数的功能是从键盘上输入一个字符。 其一般形式是：getchar(); 通常把输入的字符赋予一个字符变量，构成赋值语句。如char c;c=getchar();; 练习1：从键盘输入一个字符并输出。12345678#include &lt;stdio.h&gt;int main()&#123; char c; printf(\"input a character\\n\"); c=getchar(); putchar(c); return 0;&#125; printf函数（输出格式函数） printf函数称为格式输出函数，其关键字最末一个字母f即可“格式（format）之意”。其功能是按照用户指定的格式，把指定的数据显示到显示器屏幕上。 printf函数调用的一般形式 printf函数一个标准库函数，它的函数原型在头文件”stdio.h”。但作为一个特例，允许使用printf函数而不需要导入”stdio.h”文件 一般形式为：printf(“格式控制字符串”,输出表列); 格式字符串：%d表示按十进制整型输出。%ld按十进制长整型输出。%c表示按字符型输出。 非格式字符串按原样输出。 练习 12345678#include &lt;stdio.h&gt;int main()&#123; int a=88,b=89; printf(\"%d %d\\n\",a,b); printf(\"%d,%d\\n\",a,b); printf(\"%c,%c\\n\",a,b); printf(\"a=%d,b=%d\\n\",a,b);&#125; 练习 123456789101112#include &lt;stdio.h&gt;int main()&#123; int a=15; float b=123.1234567; double c=12345678.1234567; char d='p'; printf(\"a=%d,%5d,%o,%x\\n\",a,a,a,a); printf(\"b=%f,%lf,%5.4lf,%e\\n\",b,b,b,b); printf(\"c=%lf,%f,%8.4lf\\n\",c,c,c); printf(\"d=%c,%8c\\n\",d,d); return 0;&#125; scanf函数（格式输入函数） scanf函数称为格式输入函数，即按用户指定的格式从键盘上把数据输入到指定的变量中。 练习1 输入三角形的三边长，求三角形面积。 1234567891011#include &lt;stdio.h&gt;#include &lt;math.h&gt;int main()&#123; float a,b,c,s,area;//a,b,c为三边长，s为周长，area为面积 scanf(\"%f,%f,%f\",&amp;a,&amp;b,&amp;c); s=1.0/2*(a+b+c); area=sqrt(s*(s-a)*(s-b)*(s-c)); printf(\"a=%7.2f,b=%7.2f,c=%7.2f,s=%7.2f\\n\",a,b,c,s); printf(\"area=%7.2f\\n\",area);&#125; 练习2：求一元二次方程的根 123456789101112131415#include &lt;stdio.h&gt;#include &lt;math.h&gt;int main()&#123; float a,b,c,disc,x1,x2,p,q; printf(\"input number a,b,c!\\n\"); scanf(\"a=%f,b=%f,c=%f\",&amp;a,&amp;b,&amp;c); disc=b*b-4*a*c; p=-b/(2*a); q=sqrt(disc)/(2*a); x1=p+q; x2=p-q; printf(\"\\nx1=%5.2f,x2=%5.2f\",x1,x2); return 0;&#125; 分支结构程序关系运算符和表达式 关系运算符：在程序中经常需要比较两个两的大小关系，以决定程序下一步的工作。比较两个两的运算符称为关系运算符。 C语言运算符的优先级 ()（小括号）、[]（数组下标）、.（结构成员）、-&gt;（指针型结构成员） !（逻辑非）、.（位取反）、-（负号）、++（加1）、--（减1）、&amp;（变量地址） *（指针所指内容）、type（函数说明）、sizeof（长度计算） *（乘）、/（除）、%（取模） +（加）、-（减） &lt;&lt;（左移）、&gt;&gt;（右移） &lt;（小于）、&gt;（大于）、&lt;=（小于等于）、&gt;=（大于等于） ==（等于）、!=（不等于） &amp;（位与） … 优先级从下到上逐渐变高。 在C语言中有以下关系运算符 符号 含义 &lt; 小于 &lt;= 小于或等于 &gt; 大于 &gt;= 大于或等于 == 等于 != 不等于 关系运算符都是双目运算符，结合性均为左结合。关系运算符的优先级低于算数运算符的优先级，高于赋值运算符。 在六个关系运算符中，前四个&lt;、&lt;=、&gt;、&gt;=的优先级相同，高于==和!=，==和!=优先级相同。 关系运算符的一般形式为：表达式 关系运算符 表达式 例如： a+b&gt;c-d; x.3/2;都是合法的关系运算符表达式。 关系运算符也可以出现嵌套的情况；例如 x&gt;(y&gt;z)；a!=(m==n)等都是合法的关系运算符表达式. 关系表达式的值是真还是假，用“1”和“0”表示。 如5&gt;3的值为真是1；（a=1）&gt; （a=3）的值为假，是0； 练习1 123456789#include \"stdio.h\"int main()&#123; char c='k'; int i=1,j=2,k=3; float x=3e+5,y=0.85; printf(\"%d,%d\\n\",'a'+5&lt;c,-i-2*j &gt;= k+1);//1 0 printf(\"%d,%d\\n\",1&lt;j&lt;5,x-5.25&lt;=x+y);//1 1 printf(\"%d,%d\",i+j+k==-2*j,k==j==i+5);// 0 0&#125; 逻辑运算符和表达式 C语言提供了三种逻辑运算符：&amp;&amp;：与运算符；||：或运算符；!非运算符。 与运算符&amp;&amp;和或运算符||均为双目运算符，具有左结合性。非运算符!为单目运算符，具有右结合性。 逻辑运算符和其他运算符的的优先级关系如下： !—-&gt;&amp;&amp; —-&gt; || 与运算符：同时为真即真，有假即假 或运算符：有真即真，全假为假 非运算符：与原来的相反。 逻辑表达式 一般形式： 表达式 逻辑运算符 表达式 其中的表达式可以又是逻辑表达式 ，从而组成了嵌套的情形。 例如（a&amp;&amp;v）&amp;&amp;c 具有左结合性。 练习1： 123456789#include \"stdio.h\"int main()&#123; char c='k'; int i=1,j=2,k=3; float x=3e+5,y=0.85; printf(\"%d,%d\\n\",!x*!y,!!!x);//0 0 printf(\"%d,%d\\n\",x||i&amp;&amp;j-3,i&lt;j&amp;&amp;x&lt;y);//1 0 printf(\"%d,%d\\n\",i==5&amp;&amp;c&amp;&amp;(j=8),x+y||x+j+k);//0 1&#125; if语句 用if语句可以构成分支结构。它根据给定的条件进行判断，以决定执行某个分支程序段。用C语言的if语句有三种基本形式。 第一种形式为基本形式： if(表达式) 语句 其语义是：如果表达式的值为真，则执行其后的语句，否则不执行该语句。其过程为下图： 12345678910111213startID=&gt;start: 开始框inputoutputID=&gt;inputoutput: 输入输出框operationID=&gt;operation: 语句conditionID=&gt;condition: 表达式yes=&gt;operation: 语句endID=&gt;end: 结束框startID-&gt;inputoutputIDinputoutputID-&gt;operationIDoperationID-&gt;conditionIDconditionID(yes,bottom)-&gt;yes-&gt;endIDconditionID(no)-&gt;endID 练习1：输入两个数，并输出最大的值 123456789#include \"stdio.h\"int main()&#123; int a,b,max; printf(\"\\ninput two number:\\n\"); scanf(\"%d,%d\",&amp;a,&amp;b); max=a; if(max&lt;b)max=b; printf(\"max=%d\",max);&#125; 第二种形式为基本形式： 第二种形式：if-else if(表达式) 语句1;else 语句2; 其过程为下图： 1234567891011startID=&gt;start: 开始框inputoutputID=&gt;inputoutput: 输入输出框operationID=&gt;operation: 语句conditionID=&gt;condition: 表达式true=&gt;operation: 语句1error=&gt;operation: 语句2endID=&gt;end: 结束框startID-&gt;inputoutputID-&gt;operationID-&gt;conditionIDconditionID(yes)-&gt;true-&gt;endIDconditionID(no,right)-&gt;error-&gt;endID 练习2：输入两个数，并输出最大的值 123456789101112#include \"stdio.h\"int main()&#123; int a,b,max; printf(\"\\ninput two number:\\n\"); scanf(\"%d,%d\",&amp;a,&amp;b); if(a&gt;b)&#123; max=a; &#125;else&#123; max=b; &#125; printf(\"max=%d\",max);&#125; 第三种形式为if-else-if形式 当出现多个分支时选择当前形式比较合适。 其一般形式： if(表达式1) 语句1;else if(表达式2) 语句2;else 语句3; 流程图如下： 1234567891011121314151617startID=&gt;start: 开始框inputoutputID=&gt;inputoutput: 输入输出框operationID=&gt;operation: 语句conditionID=&gt;condition: 表达式true1=&gt;operation: 语句1true2=&gt;operation: 语句2true3=&gt;operation: 语句3error=&gt;condition: 表达式error2=&gt;condition: 表达式endID=&gt;end: 结束框startID-&gt;inputoutputID-&gt;operationID-&gt;conditionIDconditionID(yes)-&gt;true1-&gt;endIDconditionID(no,right)-&gt;errorerror(yes)-&gt;true2-&gt;endIDerror(no,right)-&gt;error2error2(yes)-&gt;true3-&gt;endID 练习1 123456789101112#include \"stdio.h\"int main()&#123; char c; printf(\"input a character: \"); c=getchar(); if(c&lt;32)printf(\"this is a control character\\n\"); else if(c&gt;='0'&amp;&amp;c&lt;='9')printf(\"this is a digit\\n\"); else if(c&gt;='A'&amp;&amp;c&lt;='Z')printf(\"this is a capital letter\"); else if(c&gt;='a'&amp;&amp;c&lt;='z')printf(\"this is a small letter\\n\"); else printf(\"thi is an other character\\n\"); return 0;&#125; 在使用if语句中还应该注意以下问题： 在三种形式的if语句中，在if关键字之后均为表达式。该表达式通常是逻辑表达式或关系表达式，但也可以是其他表达式，如赋值表达式等，甚至可以是一个变量。 例如： if(a=5)语句; if(b) 语句; 都是允许的。 如果if后面有多个语句，需要用{}括起来。 补充例题1 12345678910111213141516171819202122232425#include &lt;stdio.h&gt;/**** 输入一个分数score * score&lt;60 输出D * ...*/int main()&#123; int score; printf(\"please input a score:\\n\"); scanf(\"%d\",&amp;score); if(score&lt;60)&#123; printf(\"E\"); &#125;else if(score&lt;=75)&#123; printf(\"D\"); &#125;else if(score&lt;=80)&#123; printf(\"C\"); &#125;else if(score&lt;=90)&#123; printf(\"B\"); &#125;else if(score&lt;=100)&#123; printf(\"A\"); &#125;else&#123; printf(\"输入有误\"); &#125; return 0;&#125; 补充例题2 1234567891011121314151617181920212223242526#include &lt;stdio.h&gt;/*** 输入三个数，要求按小到大输出 **/int main()&#123; int a,b,c,t; printf(\"please input three numbers:\\n\"); scanf(\"%d%d%d\",&amp;a,&amp;b,&amp;c); if(a&gt;b)&#123; t=a; a=b; b=t; &#125; if(a&gt;c)&#123; t=a; a=c; c=a; &#125; if(b&gt;c)&#123; t=b; b=c; c=t; &#125; printf(\"从小到大输出三个数：%d,%d,%d\",a,b,c);&#125; if语句的嵌套 当if语句中的执行语句又是if语句时，则构成了if语句的嵌套。 其一般形式为 12345678if(1)&#123; if(2) prntf(\"2\"); else printf(\"3\");&#125;else&#123; if(2) prntf(\"2\"); else printf(\"3\");&#125; 在嵌套内的if语句可能又是if-else型，这将会出现多个if和多个else重叠的情况，这是需要特别注意if和else的配对问题。 else与它最近的if配对。 例题 12345678910111213141516#include &lt;stdio.h&gt;int main()&#123; int a,b; printf(\"please input A,B：\"); scanf(\"%d%d\",&amp;a,&amp;b); if(a!=b)&#123; if(a&gt;b)&#123; printf(\"A&gt;B\\n\"); &#125;else&#123; printf(\"A&lt;B\\n\"); &#125; &#125;else&#123; printf(\"A=B\\n\"); &#125; return 0;&#125; 条件运算符 条件运算符为?和:，他是一个三目运算符，即有三个参与运算的量。 由条件运算符组成条件表达式的一般形式为：表达式1?表达式2：:表达式3； 其求值规则是：如果表达式的值为真，则执行表达式2的值，否知执行表达式3的值。 条件表达式通常运用于赋值语句之中。 使用条件运算符时，还应注意一下几点： 条件运算符的优先级低于关系运算符和算数运算符，但高于赋值运算符。 条件运算符?和:是一对运算符，不能拆开单独使用 条件运算符的结合方向是自右向左。 练习1 1234567#include &lt;stdio.h&gt;int main()&#123; int max,a,b; printf(\"\\n input two numbers： \"); scanf(\"%d,%d\",&amp;a,&amp;b); printf(\"max=%d\",a&gt;b?a:b);&#125; 练习2 1234567891011121314#include &lt;stdio.h&gt;/*****输入一个字符，判断是否是大写字符，如果是，将大写字符转换成* 小写字母；如果不是，不转换。然后输出 ****/int main()&#123; char ch; scanf(\"%c\",&amp;ch); ch=(ch&gt;='A' &amp;&amp; ch&lt;='Z')?ch+32:ch; putchar(ch); &#125; Switch语句 C语言还提供了另一种用于多分支选择的switch语句。其一般形式为 1234567switch(表达式)&#123; case 常量表达式1: 语句1; case 常量表达式2: 语句2; ... case 常量表达式n: 语句n; default 语句n+1;&#125; 其语义是：计算表达式的值。并逐个与其后面的常量表达式的值相比较，当表达式的值与某个常量表达式的值相等时，即执行其后的语句，然后不再进行判断，继续执行后面所有case语句。如表达式的值与所有case的值不相等时，则执行default后面的语句。 练习1 12345678910111213141516#include &lt;stdio.h&gt;int main()&#123; int a; printf(\"input integer numbers: \"); scanf(\"%d\",&amp;a); switch(a)&#123; case 1:printf(\"Monday\\n\"); case 2:printf(\"Tuesay\\n\"); case 3:printf(\"Wednesday\\n\"); case 4:printf(\"Thursdau\\n\"); case 5:printf(\"Friday\\n\"); case 6:printf(\"Saturday\\n\"); case 7:printf(\"Sunday\\n\"); default: printf(\"error!\\n\"); &#125;&#125; 存在一个问题，就是输入3之后，后面的语句也跟着输出。 练习2：对上述问题进行改进 1234567891011121314151617#include &lt;stdio.h&gt;int main()&#123; int a; printf(\"input integer numbers: \"); scanf(\"%d\",&amp;a); switch(a)&#123; case 1:printf(\"Monday\\n\");break; case 2:printf(\"Tuesay\\n\");break; case 3:printf(\"Wednesday\\n\");break; case 4:printf(\"Thursdau\\n\");break; case 5:printf(\"Friday\\n\");break; case 6:printf(\"Saturday\\n\");break; case 7:printf(\"Sunday\\n\");break; default: printf(\"error!\\n\"); &#125;&#125; 在使用swicth时还应该注意以下几点： 在case后的各常量表达式的值不能相同，否则会出现错误； 在case后，允许有多个语句，可以不同{}括起来； 各case和default子句的先后顺序可以变动，而不会影响程序结果； defaule语句可以省略不同； 练习1 1234567891011121314151617181920212223//输入三个整数，输出最大数和最小数 int main()&#123; int a,b,c,min,max; printf(\"input three numbers: \"); scanf(\"%d%d%d\",&amp;a,&amp;b,&amp;c); if(a&gt;b)&#123; max=a; min=b; &#125;else&#123; max=b; min=a; &#125; if(max&lt;c)&#123; max=c; &#125;else&#123; if(min&gt;c)&#123; min=c; &#125; &#125; printf(\"max=%d,min=%d\\n\",max,min); &#125; 练习2 123456789101112131415#include &lt;stdio.h&gt;//模拟计算器int main()&#123; float a,b; char c; printf(\"input expression:a+(+,-,*,/)b\\n\"); scanf(\"%f%c%f\",&amp;a,&amp;c,&amp;b); switch(c)&#123; case '+':printf(\"%f%c%f=%f\\n\",a,c,b,a+b);break; case '-':printf(\"%f%c%f=%f\\n\",a,c,b,a-b);break; case '*':printf(\"%f%c%f=%f\\n\",a,c,b,a*b);break; case '/':printf(\"%f%c%f=%f\\n\",a,c,b,a/b);break; default: printf(\"input error\\n\"); &#125;&#125; 练习3 1234567891011121314#include &lt;stdio.h&gt;//输入一个年份，判断是平年还是闰年int main()&#123; int year; printf(\"input year: \\n\"); scanf(\"%d\",&amp;year); if(year%4==0 &amp;&amp; year%100!=0 || year%400==0)&#123; printf(\"闰年\"); &#125;else&#123; printf(\"平年\"); &#125; return 0;&#125; 练习4：公司对运输公司计算运费 12345678910111213141516171819202122232425262728293031#include &lt;stdio.h&gt;int main()&#123; int s,c;//s-&gt;距离 ;c 表达式常量 double d,p,w,f; printf(\"input s:\\n\"); scanf(\"%d,%lf,%lf\",&amp;s,&amp;p,&amp;w); if(s&gt;=3000)&#123; c=12; &#125;else&#123; c=s/250; printf(\"%d\\n\",c); &#125; switch(c)&#123; case 0:d=0;break; case 1:d=2;break; case 2: case 3:d=5;break; case 4: case 5: case 6: case 7:d=8;break; case 8: case 9: case 10: case 11:d=10;break; case 12:d=15;break; &#125; f=p*w*s*(1-d/100); printf(\"%15.4lf\",f); return 0;&#125; 练习5 :一个整数，它加上一百后是一个完全平方数，再加上168后又是一个整数，请问该数字是什么 1234567891011121314#include &lt;stdio.h&gt;#include &lt;math.h&gt;#define MAXSize 100000int main()&#123; long int i,x,y; for(i=-100;i&lt;MAXSize;i++)&#123; x=sqrt(i+100); y=sqrt(i+268); if((x*x==i+100) &amp;&amp;(y*y==i+268))&#123; printf(\"%ld\\t\",i); &#125; &#125;&#125; 练习6：输入某年某月某日，判断是第几天 解法1 123456789101112131415161718192021222324252627282930313233343536int main()&#123; int year,month,day;//年月日 int sum=0,i,j; printf(\"请分别输入年，月，日：\\n\"); scanf(\"%d,%d,%d\",&amp;year,&amp;month,&amp;day); if(month==1)&#123; sum=sum+day; &#125;else&#123; for(j=1;j&lt;month;j++)&#123; switch(j)&#123; case 1: case 3: case 5: case 7: case 8: case 10: case 12:i=1;break; case 4: case 6: case 9: case 11:i=0;break; case 2: if((year%4==0&amp;&amp;year%100!=0)||(year%400==0))&#123; i=-1; &#125;else&#123; i=-2; &#125; break; default: printf(\"input error\"); &#125; sum = sum + 30+i; &#125; sum =sum+day; &#125; printf(\"%d年%d月%d日是本年第%d天\",year,month,day,sum);&#125; 解法2 12345678910111213141516#include &lt;stdio.h&gt;int main()&#123; int year,month,day;//年月日 int sum=0,i,j; int data[12]=&#123;31,28,31,30,31,30,31,31,30,31,30,31&#125;; printf(\"请分别输入年，月，日：\\n\"); scanf(\"%d,%d,%d\",&amp;year,&amp;month,&amp;day); if((year%4==0 &amp;&amp; year%100!=0)|| (year%400==0))&#123; data[1]=data[i]+1; &#125; for(i=1;i&lt;month;i++)&#123; sum += data[i]; &#125; sum+=day; printf(\"%d年%d月%d日是本年第%d天\",year,month,day,sum);&#125; 循环控制结构程序 什么事循环？ 为什么要使用循环？ 循环结构是程序中一种很重要的结构。其特点是：在给定条件成立时，反复执行某程序段，直到条件不成为止。给定的条件称为循环条件，反复执行的程序段称为循环体。C语言中提供了多种循环语句，可以组成各种不同形式的循环结构。 用goto语句和if语句构成循环体。 用while语句 用do-while语句 用fo语句 goto语句以及goto语句构成循环 goto语句是一种无条件转移语句，与BASIC中的goto语句相似。 goto语句的使用格式为： goto 语句标号; 其中标号是一个有效的标识符，这个标号符加上一个“:”一起出现在函数内某处，执行goto语句后，程序将跳转到该标号处并执行其后的语句，另外标号必须与goto语句同处于一个函数中，但可以不再同一个循环层中。通常goto语句与if语句连用，当满足某一个条件时，程序将跳转到该标号处运行。 但是注意：goto语句通常不用，主要是因为它将使程序层次不清，但在多层嵌套退出时，用goto语句则比较合理。 练习1 用goto和if语句构成循环体，计算1+2+…100的值 123456789101112#include &lt;stdio.h&gt;//计算1+2+...+100 int main()&#123; int i,sum=0; i=1; loop:if(i&lt;=100)&#123; sum=sum+i; i++; goto loop; &#125; printf(\"%d\\n\",sum);&#125; while语句 while语句的一般形式为： while(表达式) 语句; 其中表达式是循环条件，语句是循环体。 while语句的语义是：计算表达式的值，当值为真（非0）时，执行循环体语句。其执行过程如下图所示： 12345678st=&gt;start: Startop=&gt;operation: Your Operationcond=&gt;condition: 表达式e=&gt;endst-&gt;condcond(yes,bottom)-&gt;op-&gt;econd(no)-&gt;e 注意：如果表达式的值一开始就是0，则语句一次也不会被执行。 练习1 计算1+2+3+…100的值 123456789#include &lt;stdio.h&gt;int main()&#123; int sum=0,i=1; while(i&lt;=100)&#123; sum+=i; i++; &#125; printf(\"%d\",sum);&#125; 练习2：传说中的死循环 123456789#include &lt;stdio.h&gt;int main()&#123; int sum=0,i=1; while(i&lt;=100)//&#123; sum+=i; i++; //&#125; printf(\"%d\",sum);&#125; 练习3 统计从键盘输入一行字符的个数 123456789#include &lt;stdio.h&gt;int main()&#123; int n=0; printf(\"input a string:\\n\"); while(getchar()!='\\n')&#123; n++; &#125; printf(\"%d\\n\",n);&#125; 使用while表达式应注意如下几点： while语句中的表达式一般是关系表达式或逻辑表达式，只要表达式的值为真即可继续循环。案例如下： 12345678910111213#include &lt;stdio.h&gt;int main()&#123; int n,a=0; printf(\"\\ninput n: \"); scanf(\"%d\",&amp;n); while(n--)&#123; printf(\"%d\\n\",a++*2); // n = 2 /0/1 //n=1 /2/2 //n=0 &#125; return 0;&#125; 循环体如果包括有一个以上的语句，则必须用{}括起来，组成复合语句。 do-while语句 do-while语句的一般形式： 123do 语句while(表达式); 这个循环与whiile循环的不同在于：它先执行循环中的语句，然后再进行判断表达式的值是否为真，如果为真则继续执行循环，如果为假，则终止循环。因此，do-while循环至少要执行一次循环语句。 do-while的执行流程如下 12345678st=&gt;start: startop=&gt;operation: 循环体语句cond=&gt;condition: 表达式e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;opcond(no,bottom)-&gt;e 练习： 计算1到100之间之和; 123456789#include &lt;stdio.h&gt;int main()&#123; int i=1,sum=0; do&#123; sum+=i; i++; &#125;while(i&lt;=100); printf(\"%d\\n\",sum);&#125; for语句 在C语言中，for语句使用最灵活，它完全可以取代while语句。 其一般形式： 1for(b表达式1;表达式2;表达式3)&#123;&#125; 它的执行过程如下： 先求解表达式1； 再求解表达式2，若其值为真（非0），则执行for语句中指定的内嵌语句，然后再执行表达式3，如果表达式3能够满足表达式2的，则继续执行循环体，直到条件不满足结束循环为止。如果不满足结束循环。 for语句最简单的应用形式也是最简单的理解形式如下： for(循环变量赋初值;循环条件;循环变量增量) 语句; 循环变量赋初值总是一个赋值语句，他用来给循环控制变量赋初值；循环条件是一个关系表达式，它决定什么时候跳出循环体；循环增量。定义循环控制变量每次循环后按什么方式变化。这三个部分之间用;分开。 练习1 计算1-100之间的和 12345678#include &lt;stdio.h&gt;int main()&#123; int i,sum=0; for(i=1;i&lt;=100;i++)&#123; sum+=i; &#125; printf(\"%d\\n\",sum);&#125; 表达式1，表达式2，表达式均可以省略 练习2 123456#include &lt;stdio.h&gt;int main()&#123; char ch; for(;(ch=getchar())!='\\n';) printf(\"%c\\n\",ch);&#125; 循环的嵌套 练习1 1234567891011121314#include &lt;stdio.h&gt;int main()&#123; int i,k,j; for(i=0;i&lt;2;i++) &#123; for(j=0;j&lt;2;j++) &#123; for(k=0;k&lt;2;k++) &#123; printf(\"%d %d %d\\n\",i,j,k); &#125; &#125; &#125;&#125; 练习2 1234567891011121314151617181920#include &lt;stdio.h&gt;/**********输出如下图案： ********************/int main()&#123; int i,j,n; printf(\"input n: \\n\"); scanf(\"%d\",&amp;n); for(i=1;i&lt;=n;i++)&#123; for(j=1;j&lt;=i;j++)&#123; printf(\"*\"); &#125; printf(\"\\n\"); &#125; &#125; 四种循环的比较 四种循环中都可以用来处理同一问题，一般情况下它们可以相互替换。但一般不提倡用goto型循环。 在while循环和do-while循环中，只在while后面的括号内指定循环条件，因此为了使循环正常结束，应在循环体中包含使循环趋于结束的语句。（如i++，或i=i+1等）。 for循环可以在表达式3中包含使循环体趋于结束的操作，甚至可以将循环体中的操作全部放到表达式3中，因此for语句的功能更强，凡是能用while循环完成的，用for循环都能实现。 用while语句和do-while循环时，循环变量初始化的操作应该在while和do-while语句之前完成而for语句可以在表达式1中实现循环变量的初始化。 while循环、do-while循环和for循环，可以使用break跳出循环，用continue语句结束本次循环。而用goto语句和if语句构成的循环，不能用Break和continue语句进行控制。 练习：有1,2,3,4四个数字，能组成多少个互不相同且无重复的三位数； 12345678910111213141516#include &lt;stdio.h&gt;int main()&#123; int i,j,k; int sum; for(i=1;i&lt;=4;i++)&#123; for(j=1;j&lt;=4;j++)&#123; for(k=1;k&lt;=4;k++)&#123; if(i!=j&amp;&amp;i!=k&amp;&amp;j!=k)&#123; sum=i*100+j*10+k; printf(\"%d\\n\",sum); &#125; &#125; &#125; &#125; &#125; break和continue语句 break语句可以用来从循环体内跳出循环体，即提前结束循环，接着执行下面的语句。 一般形式为：break; break语句不能用于循环语句和switch语句之外的任何其他语句中。 注意： break语句对if-else的条件语句不起作用。 在多层循环中，一个break语句只向外跳一层。 练习1 123456789101112#include &lt;stdio.h&gt;int main()&#123; int r; float pi=3.14159,area; for(r=1;r&lt;10;r++)&#123; area=r*r*pi; if(area&gt;100)&#123; break; &#125; printf(\"r=%d,area=%f\\n\",r,area); &#125;&#125; 练习2 1234567891011#include &lt;stdio.h&gt;#include \"conio.h\"int main()&#123; int ch; while(1)&#123; while(ch=getch())&#123; //ch：从控制台读取一个字符，但不显示在屏幕上。 printf(\"%d\\n\",ch); &#125; &#125;&#125; 练习3 123456789101112131415161718#include &lt;stdio.h&gt;#include \"conio.h\"int main()&#123; int i=0;char c; while(1)&#123; c='\\0'; while(c!=13&amp;&amp;c!=27)&#123; c=getch(); printf(\"%c\\n\",c); &#125; if(c==27)&#123; break; &#125; i++; printf(\"The No. is %d\",i); &#125; printf(\"The end\");&#125; continue语句 作为结束本次循环，即跳过循环体中下面尚未执行的语句，接着进行下一次是否执行循环的判断。 一般形式：continue; continue语句与break语句的区别： continue是结束当前循环，进行下一步是否循环的判断。 break则是直接结束当前循环。 练习4 123456789101112131415161718192021#include &lt;stdio.h&gt;#include \"conio.h\"/*********************************************************案例实现：当按下键盘就输出该值，如果按esc则跳出则结束输入，如果按下enter健则不显示...................................**********************************************************/ int main()&#123; char ch; for(;;)&#123; ch=getch(); if(ch==27)&#123; break; &#125; if(ch==13)&#123; continue; &#125; putch(ch);//输出按下的键盘值 &#125; getch(); return 0;&#125; 练习5 把100-200之间不能被3整除的数全部输出 1234567891011#include &lt;stdio.h&gt;#include \"conio.h\"int main()&#123; int i=100; for(i;i&lt;=200;i++)&#123; if(i%3==0)&#123; continue; &#125; printf(\"%d\\n\",i); &#125;&#125; 循环的相关练习 练习1 求π的近似值 12345678910111213141516171819202122232425262728293031323334//求解方式1#include \"stdio.h\"#include \"math.h\"int main()&#123; int s=1; float n=1.0,t=1,pi=0; while(fabs(t)&gt;1e-6)&#123; pi=pi+t; n=n+2; s=-s; t=1.0*s/n; &#125; pi=pi*4; printf(\"%f\",pi);&#125;//求解方式2#include \"stdio.h\"//求π的近似值int main()&#123; int i; float sum=0; for(i=1;1.0/(2*i-1)&gt;1e-6;i++)&#123; if(i%2!=0)&#123; sum=sum+1.0/(2*i-1); &#125;else&#123; sum=sum-1.0/(2*i-1); &#125; &#125; printf(\"%f\",sum*4); return 0;&#125; 练习2 12345678910111213141516171819202122232425262728293031323334//解法1#include &lt;stdio.h&gt;int main()&#123; long int f1,f2; int i; f1=1;f2=1; for(i=0;i&lt;=20;i++)&#123; printf(\"%12ld%12ld\",f1,f2); if(i%2==0) &#123; printf(\"\\n\"); &#125; f1=f1+f2; f2=f1+f2; &#125;&#125;//解法2#include &lt;stdio.h&gt;int Fn(int n)&#123; if(n==1||n==2)&#123; return 1; &#125;else&#123; return Fn(n-1)+Fn(n-2); &#125; &#125;int main()&#123; int i; for(i=1;i&lt;=40;i++)&#123; printf(\"%d\\t\",Fn(i)); &#125;&#125; 练习3//解法1 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;stdio.h&gt;/************************************************ 输入一个数字m，判断m是否为素数************************************************/ int main()&#123; int m,i,j=1; printf(\"input m=\"); scanf(\"%d\",&amp;m); for(i=2;i&lt;m;i++)&#123; if(m%i==0)&#123; j=0; break; &#125; &#125; if(j)&#123; printf(\"%d是一个素数\\n\",m); &#125; else&#123; printf(\"%d不是一个素数\\n\",m); &#125;&#125; //解法2#include &lt;stdio.h&gt;#include &lt;math.h&gt;int main()&#123; int m,i,k; scanf(\"%d\",&amp;m); k=sqrt(m); for(i=2;i&lt;=k;i++)&#123; if(m%i==0)&#123; break; &#125; &#125; if(i&gt;k)&#123; printf(\"%d是一个素数\\n\",m); &#125;else&#123; printf(\"%d不是一个素数\\n\",m); &#125;&#125; 练习4 输出1-100之间的素数 12345678910111213141516#include &lt;stdio.h&gt;#include &lt;math.h&gt;int main()&#123; int i,j; for(j=2;j&lt;=100;j++)&#123; for(i=2;i&lt;sqrt(j);i++)&#123; if(j%i==0)&#123; break; &#125; &#125; if(i&gt;sqrt(j))&#123; printf(\"%d\\n\",j); &#125; &#125;&#125; 练习5 译密码 1234567891011121314151617181920212223242526#include &lt;stdio.h&gt;#include &lt;math.h&gt;int main()&#123; int i; char ch; char chs; while((ch=getchar())!='\\0')&#123; if(ch&gt;='a' &amp;&amp; ch&lt;='z' || ch&gt;='A' &amp;&amp; ch&lt;='Z' )&#123; switch(ch)&#123; case 'x': chs='a';break; case 'y': chs='b';break; case 'z': chs='c';break; case 'X': chs='A';break; case 'Y': chs='B';break; case 'Z': chs='C';break; default:chs=ch+4; &#125; &#125;else&#123; chs=ch; &#125; printf(\"%c\",chs); &#125; &#125; 练习6 1234567891011121314151617181920212223242526272829303132333435#include &lt;stdio.h&gt;#include &lt;math.h&gt;# define N 7/* * *** ***** ******* ***** *** **/int main()&#123; int i,j; for(i=1;i&lt;=N/2+1;i++)&#123; for(j=1;j&lt;=4-i;j++)&#123; printf(\" \"); &#125; for(j=1;j&lt;=(2*i-1);j++)&#123; printf(\"*\"); &#125; printf(\"\\n\"); &#125; for(i=1;i&lt;=3;i++)&#123; for(j=1;j&lt;=i;j++)&#123; printf(\" \"); &#125; for(j=1;j&lt;=N-(2*i);j++)&#123; printf(\"*\"); &#125; printf(\"\\n\"); &#125; return 0;&#125; 数组 有如下几组数据，它们分别该如何存储呢？ 学生的学习成绩; 银行的账单 一行文字 这些数据的特点是： 具有相同的数据类型 使用过程中需要保留原始数据。 C语言中为这些数据，提供了一种构造数据类型，数组。 在程序设计中，为了方便处理，把具有相同类型的若干变量按有序的形式组织起来。这些按序排列的同类数据元素的集合称为数组。 在C语言中，数组是属于构造数据类型。 数组：具有相同类型的数据组成的序列，是有序集合。 数组中的每一个数据称为：数组元素、下标变量。 数组元素：由其所在的位置序号（数组元素的下标）来区分。 用数组名与下标可以用统一的方式来处理数组中的所有元素，从而方便的实现处理一批具有相同性质数据的问题。 注意：数组元素有序不是指元素大小有序。一维数组的定义和引用 在C语言中使用数组必须先进行定义。 一维数组的定义方式： 类型说明符 数组名[常量表达式] 例如：int a[10]; 它表示定义了一个整形数组，数组名为a，此数组有10个元素，10个元素都是整型变量。 需要注意的是： 类型说明符是任意一种基本数据类型或者构造数组类型。对于同一个数组，其所有元素的数据类型都是相同的。 数组名是用户定义的数组标识符。书写规则应符合标识符的书写规则。 方括号中的常量表达式表示数据元素的个数，也称为数组长度。 允许在通一个类型说明中，说明多个数组和多个变量。例如：int a,b,c,k[200],j[10]; a[10]，表示数组a有10个元素，注意下标是从0开始，这10个元素是a[0],a[1]...a[9]。按上面定义，不存在数据元素a[10]； c语言中不允许对数组的大小做动态定义，即数组的大小不依赖于程序运行过程中变量的值。例如下面定义数组是不允许的 123int n;scanf(\"%d\",&amp;n);int a[n]; 一维数组在内存中的存放 一维数组的引用： 数组元素是组成数组的基本单位。数据元素也是一种基本变量，其标识方法为数组名后跟一个下标。下标表示了元素在数组中的顺序号。 数组元素的一般形式为：数组名[下标]（下标可以是整型常量或整型表达式） 例如：a[0] = a[5]+a[7]+a[2*3]、a[i+j]、a[i++]都是合法的数组元素。 一维数组元素的引用的一些注意的事项： 数组元素通常也称为下标变量。必须先定义数组，才能使用下标变量。在C语言中只能逐个使用下标变量，而不能一次性使用整个数组。 定义数组时用到的数组名[常量表达式]和用用数组元素时使用到的数组名[常量表达式]有区别。 一维数组的初始化 给数组赋值的方法除了赋值语句之外，还可以采用初始化赋值和动态赋值的方法。 数组初始化赋值是指在数组定义时给数组元素赋予初值。 数组初始化是在编译阶段进行的。这样将减少运行时间，提高效率。 注意：之前用赋值语句或输入语句也可给数组元素指定初值，是在运行时完成的。 初始化赋值的一般形式为： 类型说明符 数组名[常量表达式]={值,值...,值}; 练习1 123456789#include &lt;stdio.h&gt;int main()&#123; int i,a[5]=&#123;3,4,5&#125;,b[5]; printf(\"\\n array a is:\"); for(i=0;i&lt;5;i++)printf(\"%6d\",a[i]); printf(\"\\n array b is:\"); for(i=0;i&lt;5;i++)printf(\"%6d\",b[i]);&#125; 练习2 输入10个数，并把最大的数输出 12345678910111213#include &lt;stdio.h&gt;int main()&#123; int i,max,a[10]; printf(\"input 10 numbers:\\n\"); for(i=0;i&lt;10;i++) &#123; scanf(\"%d\",&amp;a[i]); &#125; max=a[0]; for(i=1;i&lt;10;i++)&#123; if(max&lt;a[i]) max=a[i]; &#125; printf(\"max=%d\",max);&#125; 练习3： 利用数组来处理、求解Fibonacci数列;把前20个项的值存放在数组中 1234567891011#include &lt;stdio.h&gt;int main()&#123; int a[20],i; a[0]=a[1]=1; for(i=2;i&lt;20;i++)&#123; a[i]=a[i-1]+a[i-2]; &#125; for(i=0;i&lt;20;i++)&#123; printf(\"%d \",a[i]); &#125;&#125; 练习4：冒泡排序 12345678910111213141516171819#include &lt;stdio.h&gt;int main()&#123; int a[10]=&#123;12,26,32,25,11,56,96,48,36,66&#125;; int i,j,t; for(j=0;j&lt;9;j++)&#123; for(i=0;i&lt;9-j;i++)&#123; if(a[i]&gt;a[i+1])&#123; t=a[i]; a[i]=a[i+1]; a[i+1]=t; &#125; &#125; &#125; for(i=0;i&lt;10;i++)&#123; printf(\"%d \",a[i]); &#125; &#125; 二维数组的定义和引用 二维数组的定义 二维数组定义的一般形式为：类型说明符 数组名[常量表达式][常量表达式]; 例如：定义a为3×4的数组，b为5×10的数组如下：float a[3][4],a[5][10] 我们可以将二维数组看成是一种特殊的一维数组：它的元素又是一个一维数组。 二维数组在概念上二维的，但是，实际的硬盘存储器却是连续编址的，也就是说存储器单元是按一维线性排列的。 如何在一维存储器中存放二维数组，可有两种方式：一种是按行排。另一种是按列排列。 二维数组的引用和初始化 数据类型 数组名[常量表达式1][常量表达式2] ={初始化数据}; 我们有4种方法对二维数组初始化： 直接分行给二维数组赋初值 可以将所有数据写在一个花括号内，按数组排列的顺序对各元素赋初值 可以对部分元素赋初值 可以对各行中的某一元素赋初值。 a[][]：第一维长度可以省略，第二维长度不可以省略。 1234567#include &lt;stdio.h&gt;int main()&#123;#if(0) int a[3][4]=&#123;&#123;1&#125;,&#123;5&#125;,&#123;9&#125;&#125;;//这样初始化的是每一行的第一个元素 #endif int a[3][4]=&#123;1,2,3&#125;; &#125; 练习1 计算平均分 12345678910111213141516171819#include &lt;stdio.h&gt;int main()&#123; int i,j,sum=0,average,v[3]; int a[5][3]=&#123;&#123;80,75,92&#125;,&#123;61,65,71&#125;,&#123;59,63,70&#125;,&#123;85,87,90&#125;,&#123;76,77,85&#125;&#125;; for(i=0;i&lt;3;i++)&#123; //表示科目 for(j=0;j&lt;5;j++) // 表示成绩 &#123; sum = sum + a[j][i]; &#125; v[i]=sum/5; sum=0; &#125; average = (v[0]+v[1]+v[2])/3; printf(\"math:%d\\nc language:%d\\ndFoxpro:%d\\n\",v[0],v[1],v[2]); printf(\"total:%d\\n\",average); return 0;&#125; 练习2：将数组的行和列对换 123456789101112131415161718192021#include &lt;stdio.h&gt;int main()&#123; int a[2][3] = &#123;&#123;1,2,3&#125;,&#123;4,5,6&#125;&#125;; int b[3][2]; int i,j; printf(\"output array a:\\n\"); for(i=0;i&lt;2;i++)&#123; for(j=0;j&lt;3;j++)&#123; printf(\"%d\\t\",a[i][j]); b[j][i]=a[i][j]; &#125; printf(\"\\n\"); &#125; printf(\"output array b:\\n\"); for(i=0;i&lt;3;i++)&#123; for(j=0;j&lt;2;j++)&#123; printf(\"%d\\t\",b[i][j]); &#125; printf(\"\\n\"); &#125;&#125; 练习3：输入一个二维数组，并输出其中最大的一个数，并把该数的行和列输出。 1234567891011121314151617181920212223#include &lt;stdio.h&gt;int main()&#123; int a[3][3]; int i,j,column,row,max; printf(\"input number:\\n\"); for(i=0;i&lt;3;i++)&#123; for(j=0;j&lt;3;j++)&#123; scanf(\"%d\",&amp;a[i][j]); &#125; &#125; max=a[0][0]; for(i=0;i&lt;3;i++)&#123; for(j=0;j&lt;3;j++)&#123; if(max&lt;a[i][j])&#123; max=a[i][j]; column=j; row=i; &#125; &#125; &#125; printf(\"column=%d,row=%d,max=%d\",column,row,max);&#125; 练习4：输入3*3数组，只输出指定位置的数组 12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;int main()&#123; int a[3][3]; int i,j; printf(\"input number:\\n\"); for(i=0;i&lt;3;i++)&#123; for(j=0;j&lt;3;j++)&#123; // printf(\"a[%d][%d]=\",i,j); scanf(\"%d\",&amp;a[i][j]); &#125; &#125; for(i=0;i&lt;3;i++)&#123; for(j=0;j&lt;3;j++)&#123; if(j==1 || i==1)&#123; printf(\"%-6d\",a[i][j]); &#125;else&#123; printf(\"%-6c\",' '); &#125; &#125; printf(\"\\n\"); &#125;&#125; 二分法 利用数组进行数据查找 – 二分法 适用情况：在一批有序数据中查找某数。 原理：选定某个数，先与数组的中间数进行比较，如果大于中间数，去掉包括中间之前的数字，在剩下的数据中再次以同样的方法进行查找，直到找到该数为止。如果小于中间数，去掉包括中间数之后的所有的数字，在剩下的数据中再次以同样的方式进行查找，直到找到为止。如果该数与中间数相同，则找到该数。 练习1： 1234567891011121314151617181920212223242526272829303132#include &lt;stdio.h&gt;#define N 10/*************************************************************** 假设在数值a中的数据是按小到大排序排列的 -12 0 6 16 23 56 80 100 110 115 从键盘上输入一个数，判断该数是否在数组中 ，若在，输出序号 ***************************************************************/ int main()&#123; static int a[N]=&#123;-12,0,6,16,23,56,80,100,110,115&#125;; int low,high,mid;//low-&gt;最小数；high-&gt;最大数；mid-&gt;中间数； int n,found;//n-&gt;要查找的数 low=0; high=N-1; printf(\"input n=\"); scanf(\"%d\",&amp;n); while(low&lt;=high)&#123; mid=(low+high)/2; if(n == a[mid])&#123; found=1; break; &#125;else if(n&gt;a[mid])&#123; low=mid+1; &#125;else&#123; high=mid-1; &#125; &#125; if(found==1)&#123; printf(\"The index of %d is %d\",n,mid); &#125;else&#123; printf(\"There is not %d\",n); &#125;&#125; 改进版 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;stdio.h&gt;#define N 10/*************************************************************** 假设在数值a中的数据是按小到大排序排列的 -12 0 6 16 23 56 80 100 110 115 从键盘上输入一个数，判断该数是否在数组中 ，若在，输出序号 ***************************************************************/ int main()&#123; //一个程序在编译运行的时候，普通变量是存放在栈区。 //这个static会使得变量存放在data //我们整个内存主要分为四大区：CODE、DATA、STACK、HEAP static int a[N]=&#123;-12,0,6,16,23,56,80,100,110,115&#125;; int low,high,mid;//low-&gt;最小数；high-&gt;最大数；mid-&gt;中间数； int n,found;//n-&gt;要查找的数 low=0; high=N-1; #if(0) do&#123; //printf(\"input n=\"); scanf(\"%d\",&amp;n); &#125;while(n&lt;a[0] || n&gt;a[N-1]); #endif while(scanf(\"%d\",&amp;n)!=1)&#123; printf(\"非法输入!\\n\"); getchar();//把缓存区的内容消耗掉 &#125; while(low&lt;=high)&#123; mid=(low+high)/2; if(n == a[mid])&#123; found=1; break; &#125;else if(n&gt;a[mid])&#123; low=mid+1; &#125;else&#123; high=mid-1; &#125; &#125; if(found==1)&#123; printf(\"The index of %d is %d\",n,mid); &#125;else&#123; printf(\"There is not %d\",n); &#125;&#125; 衍生：多维数组的定义 有了二维数组的基础，那么多维数组是如何定义的。 定义三维数组：float a[1][1][1]; 多维数组元素在内存中的排列顺序，第一维的下标变化最慢，最右边的下标变化最快。 函数 一个较大程序可以分成若干个程序模块，每一个模块用来实现一个特定的功能。这个模块称之为函数。 在高级语言中用子程序实现模块的功能。子程序有函数来完成。 一个C程序可以由一个主函数和若干个其他的函数构成。 函数的调用关系 由主函数调用其他函数，其他函数也可以相互调用。同一个函数可以被一个或多个函数调用任意多次。 例子： 12345678910111213141516#include &lt;stdio.h&gt;int main()&#123; void printstar();//声明函数 void print_message();//声明函数 printstar();//调用函数 print_message();//调用函数 printstar();//调用函数 return 0;&#125;void printstar()&#123; printf(\"******************************\\n\");&#125; void print_message()&#123; printf(\"hello world!!!\\n\");&#125; 函数定义的一般形式： 定义无参函数的一般形式为： 1234类型说明符 函数名()&#123; 声明部分 语句部分&#125; 类型说明符，指定函数的返回值，即调用函数后所带回的值。 定义有参函数的一般形式： 1234类型说明符 函数名(形式参数列表)&#123; 声明部分 语句部分&#125; 定义空函数的一般形式为 123类型标识符 函数名()&#123;&#125; 函数默认的返回值类型为int； 形式参数和实际参数 形式参数：在定义函数时括号内带有的参数； 实际参数：在主函数或或其他函数调用该函数时传递的参数。 在大多数情况下，主调函数和背调函数之间有数据传递关系。 return后面的括弧中的值作为函数带回的值（称为函数返回值）。 在不同的函数之间传递数据，可以使用的方法: 参数：通过形式参数和实际参数。 返回值：用return语句返回计算结果。 全局变量：外部变量。 案例实现： 1234567891011121314#include &lt;stdio.h&gt;int max(int x,int y);int main()&#123; int a,b,c; scanf(\"%d,%d\",&amp;a,&amp;b); c=max(a,b); printf(\"%d\",c); return 0;&#125; int max(int x,int y)&#123; int d; d = x&gt;y?x:y; return d;&#125; 函数的返回值 通常，希望通过函数调用时使主调函数能得到一个确定的值，这就是函数的返回值。 函数的返回值是通过函数中的return语句获得的。 return后面的值可以是一个表达式。 在C语言中，凡不加类型说明的函数，自动按整型处理。 练习1 123456789101112131415#include &lt;stdio.h&gt;void main()&#123; float max(float x,float y); float a,b,c; scanf(\"%f,%f\",&amp;a,&amp;b); c=max(a,b); printf(\"max is %f\\n\",c);&#125;float max(float x,float y)&#123; float z; z=x&gt;y?x:y; return z;&#125; 函数的调用 函数调用的一般形式：函数名(实参表列); 开发工具 这里使用的是dev-c++; 下载路径：https://bloodshed-dev-c.en.softonic.com/download习题网址 http://c.biancheng.net/view/531.html","categories":[],"tags":[{"name":"c语言","slug":"c语言","permalink":"https://CPWS.github.io/tags/c语言/"}]},{"title":"Lucene","slug":"Lucene","date":"2019-11-30T04:52:24.000Z","updated":"2019-12-05T09:00:14.102Z","comments":true,"path":"2019/11/30/Lucene/","link":"","permalink":"https://CPWS.github.io/2019/11/30/Lucene/","excerpt":"","text":"Lucene&amp;Solr第一天 什么是全文检索 数据分类 结果化数据：有固定的格式和有限长度，比如Oracle或mysql表中的数据。 使用SQL语句查询结构化数据，速度快。 如果数据量大时，可以在数据库中创建索引，但是此时创建的索引是不支持模糊查询，需要创建另外一套索引库。 非结构化数据：没有固定格式也没有有限长度。比如：磁盘上的文件，excel、word、pdf、txt、ppt等 查询非结构化数据：1、目测（顺序扫描法）、IO读取、3、全文检索 对数据源创建索引，在索引上搜索这个过程就是全文检索。（创建索引+查询） 全文检索的应用场景 搜索引擎：百度、搜狗、360 搜搜 站内搜索：淘宝、京东、微博、论坛 怎么实现全文检索 使用lucene实现 Lucene简介 是Apache下的开源用来实现全文检索的工具包，API Lucene实现全文检索的流程 创建索引 获取源文档 什么是源文档？场景1：搜索引擎：指的是互联网上的所有网页。场景2：站内搜索：磁盘上的文件或表中的数据。 获取源文档方式？场景1：搜索引擎：网络爬虫。场景2：站内搜索：IO流、sql查询 构建文档对象（Document） 一个Document对象中放的是：一个网页内容、或一个文件、或表中一条数据。 对内容分词（分析文档） 举例：一个文件包含信息：文件路径、文件名称、文件大小、文件内容。（document） 举例：一个网页包含信息：网络地址URL，网页内容、网页标题。(document) 举例：一条数据包含的信息：一条数据每个列的内容。（document）（有多少个列就有多少个域） 效果：The Spring Framework provides a comprehensive programming and configuration model.； 按空格大小分 处理大小写 停用词 标点符号 结果： spring、framework、provides、comprehensive、programming、configuration、model（每一个对应一个term） 创建索引（存储） 分词后的格式： name:spring name是自定义的域名城，spring是此域中的值；name:spring就是一个词汇item；一个文档中可以有多个域。不同的文档可以有不同的域。 创建索引是对语汇单元索引，通常词语找文档，这种索引结构叫做倒排索引结构。 查询索引 用户查询接口：就是用户输入关键字的位置 创建查询 执行查询 渲染结果 Lucene入门案例 所需要的jar包： 核心的jar：lucene-core-4.10.3.jar、lucene-analyzers-common-4.10.3.jar IO所需要的包：commons-io.jar 创建索引 场景：给磁盘上的文件创建索引 步骤 指定索引库位置 Directory 创建写入索引位置IndexWriter 获取源文档 IO流 写入文档indexWriter.addDocument(doc)； 关闭资源 indexWriter.close(); 使用luke工具查看索引文件 luke安装地址：https://github.com/DmitryKey/luke/releases1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package com.gdaib.lucene;import java.io.File;import java.io.IOException;import java.nio.file.Path;import org.apache.commons.io.FileUtils;import org.apache.lucene.analysis.Analyzer;import org.apache.lucene.analysis.standard.StandardAnalyzer;import org.apache.lucene.document.Document;import org.apache.lucene.document.Field;import org.apache.lucene.document.Field.Store;import org.apache.lucene.document.TextField;import org.apache.lucene.index.IndexWriter;import org.apache.lucene.index.IndexWriterConfig;import org.apache.lucene.store.FSDirectory;import org.apache.lucene.util.Version;public class IndexWriterTest &#123; public static void main(String[] args) throws IOException &#123; //1.指定索引库位置 FSDirectory directory = FSDirectory.open(new File(\"D:\\\\桌面\\\\Java\\\\lucene\\\\indexRepo\")); //指定分词器 Analyzer analyzer=new StandardAnalyzer(); IndexWriterConfig config=new IndexWriterConfig(Version.LATEST,analyzer); //2.创建写入索引对象 IndexWriter indexWriter=new IndexWriter(directory, config); // 3.获取源文档 File srcFile = new File(\"D:\\\\txt\"); File[] listFiles = srcFile.listFiles(); // 4. 把文档写入索引库 for (File file : listFiles) &#123; Document doc=new Document(); //文件路径、 String filePath = file.getPath(); Field pathField=new TextField(\"path\", filePath, Store.YES) ; doc.add(pathField); //文件名称、 String fileName = file.getName(); Field nameField=new TextField(\"name\", fileName, Store.YES) ; doc.add(nameField); //文件大小、 long fileSize=FileUtils.sizeOf(file); Field sizeField=new TextField(\"size\", fileSize+\"\", Store.YES) ; doc.add(sizeField); //文件内容 String fileContent = FileUtils.readFileToString(file); Field contentField=new TextField(\"content\", fileContent+\"\", Store.YES) ; doc.add(contentField); indexWriter.addDocument(doc); &#125;// 5.关闭资源 indexWriter.close(); &#125;&#125; 查询索引 指定索引库位置 创建读取索引对象 创建查询索引对象 执行索引 获取索引结果1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package com.gdaib.lucene;import java.io.File;import java.io.IOException;import java.nio.file.Path;import org.apache.lucene.document.Document;import org.apache.lucene.index.DirectoryReader;import org.apache.lucene.index.IndexReader;import org.apache.lucene.index.Term;import org.apache.lucene.search.IndexSearcher;import org.apache.lucene.search.Query;import org.apache.lucene.search.ScoreDoc;import org.apache.lucene.search.TermQuery;import org.apache.lucene.search.TopDocs;import org.apache.lucene.store.Directory;import org.apache.lucene.store.FSDirectory;public class IndexReaderTest &#123; public static void main(String[] args) throws IOException &#123; //1. 指定索引库的位置 Directory directory = FSDirectory.open(new File(\"D:\\\\桌面\\\\Java\\\\lucene\\\\indexRepo\")); //2.创建读取索引对象 IndexReader indexReader=DirectoryReader.open(directory); //3. 创建查询索引对象 IndexSearcher indexSearcher = new IndexSearcher(indexReader); //4.执行查询方法 query:指定条件，result：查询数据量的限制 Term t=new Term(\"name\",\"spring\"); Query query=new TermQuery(t); //5.获取获取查询结果 TopDocs topDocs = indexSearcher.search(query, 100); System.out.println(\"总记录数：\"+topDocs.totalHits); ScoreDoc[] scoreDocs = topDocs.scoreDocs; for (ScoreDoc scoreDoc : scoreDocs) &#123; int docId = scoreDoc.doc; Document doc = indexSearcher.doc(docId); //获取文档的内容 System.out.println(\"文件名：\"+doc.get(\"name\")); System.out.println(\"文件大小：\"+doc.get(\"size\")); System.out.println(\"文件路径：\"+doc.get(\"path\")); System.out.println(\"文件内容：\"+doc.get(\"content\")); System.out.println(\"***********\"); &#125; //6.关闭资源 indexReader.close(); &#125;&#125; 分词器 Analyzer每个分词器的tokenStream方法12345678910111213141516171819202122232425262728293031323334353637383940414243package com.gdaib.lucene;import java.io.IOException;import org.apache.lucene.analysis.Analyzer;import org.apache.lucene.analysis.TokenStream;import org.apache.lucene.analysis.cjk.CJKAnalyzer;import org.apache.lucene.analysis.cn.smart.SmartChineseAnalyzer;import org.apache.lucene.analysis.standard.StandardAnalyzer;import org.apache.lucene.analysis.tokenattributes.CharTermAttribute;import org.wltea.analyzer.lucene.IKAnalyzer;/*** * StandardAnalyzer：按照空格分词（英文），中文是一个字一个字分隔（Analyzer analyzer=new StandardAnalyzer();） * CJKAnalyzer：Analyzer analyzer = new CJKAnalyzer();//中文两个字两个字 * SmartChineseAnalyzer：中文还算可以，但是英文容易出现缺字母 * IK-Analyzer：第三方分词器 IK-Analyzer 需要导入jar，需要加入两个配置文件 * @author * */public class AnalyzerTest &#123; public static void main(String[] args) throws IOException &#123; //Analyzer analyzer=new StandardAnalyzer(); //Analyzer analyzer = new CJKAnalyzer();//中文两个字两个字 //Analyzer analyzer = new SmartChineseAnalyzer(); //第三方分词器 IK-Analyzer 需要导入jar Analyzer analyzer=new IKAnalyzer(); TokenStream tokenStream = analyzer.tokenStream(null, \"apache场景1：搜索引擎：指的是互联网上的所有网页。场景2：站内搜索：磁盘上的文件或表中的数据。\"); CharTermAttribute charTermAttribute = tokenStream.addAttribute(CharTermAttribute.class); tokenStream.reset(); while(tokenStream.incrementToken()) &#123; System.out.println(charTermAttribute); &#125; &#125;&#125; 分词器的使用时机 需要查询就需要分词器 查询时也需要分词 Lucene&amp;Solr第二天索引库的维护Lucene的查询相关度排序什么是solrsolr的安装和配置Solr后台的使用使用solrj维护索引库","categories":[{"name":"back-end","slug":"back-end","permalink":"https://CPWS.github.io/categories/back-end/"}],"tags":[{"name":"Lucene","slug":"Lucene","permalink":"https://CPWS.github.io/tags/Lucene/"}]},{"title":"Elasticsearch","slug":"Elasticsearch","date":"2019-11-29T11:18:12.000Z","updated":"2019-12-05T08:58:27.489Z","comments":true,"path":"2019/11/29/Elasticsearch/","link":"","permalink":"https://CPWS.github.io/2019/11/29/Elasticsearch/","excerpt":"","text":"","categories":[{"name":"back-end","slug":"back-end","permalink":"https://CPWS.github.io/categories/back-end/"}],"tags":[{"name":"Elasticsearch","slug":"Elasticsearch","permalink":"https://CPWS.github.io/tags/Elasticsearch/"}]},{"title":"solr","slug":"solr","date":"2019-11-29T11:17:57.000Z","updated":"2019-12-05T09:01:17.513Z","comments":true,"path":"2019/11/29/solr/","link":"","permalink":"https://CPWS.github.io/2019/11/29/solr/","excerpt":"","text":"https://www.cs.usfca.edu/galles/visualization/AVLtree.html 全文检索和Solr介绍、Solr环境安装 安装步骤： 下载安装包：https://lucene.apache.org/solr/downloads.html 上传到Linux上 解压文件 tar -zxvf solr -C /usr/local 进入目录./usr/local/solr-7.7.2/server/solr-webapp/webapp 把webapp下的案例文件拷贝到tomcat的webapps下. 修改该文件下的web.xml，添加如下内容： 拷贝相关jar包到tomcat目录下： java操作Solr服务器管理员运维命令以及集群搭建案例实战","categories":[{"name":"back-end","slug":"back-end","permalink":"https://CPWS.github.io/categories/back-end/"}],"tags":[{"name":"solr","slug":"solr","permalink":"https://CPWS.github.io/tags/solr/"}]},{"title":"搜索引擎框架介绍","slug":"搜索引擎框架介绍","date":"2019-11-29T09:04:19.000Z","updated":"2019-12-05T08:57:08.748Z","comments":true,"path":"2019/11/29/搜索引擎框架介绍/","link":"","permalink":"https://CPWS.github.io/2019/11/29/搜索引擎框架介绍/","excerpt":"","text":"9个基于Java的搜索引擎框架 转自：https://blog.csdn.net/y19910825/article/details/78982429 Java全文搜索引擎框架 Lucene 毫无疑问，Lucene是目前最受欢迎的Java全文搜索框架，准确地说，它是一个全文检索引擎的架构，提供了完整的查询引擎和索引引擎，部分文本分析引擎。Lucene为开发人员提供了相当完整的工具包，可以非常方便地实现强大的全文检索功能。下面有几款搜索引擎框架也是基于Lucene实现的。 官方网站：http://lucene.apache.org/开源Java搜索引擎Nutch Nutch 是一个开源Java实现的搜索引擎。它提供了我们运行自己的搜索引擎所需的全部工具。包括全文搜索和Web爬虫。 利用Nutch，你可以做到以下这些功能： 每为这些网页维护一个索引 个月取几十亿网页 对索引文件进行每秒上千次的搜索 提供高质量的搜索结果 最小的成本运作 官方网站：http://nutch.apache.org/分布式搜索引擎Elasticsearch ElasticSearch就是一款基于Lucene框架的分布式搜索引擎，并且也是一款为数不多的基于JSON进行索引的搜索引擎。ElasticSearch特别适合在云计算平台上使用。 官方网站：http://www.elasticsearch.org/实时分布式搜索引擎Solandra Solandra 是一个实时的分布式搜索引擎，基于 Apache Solr 和 Apache Cassandra 构建。 其特性如下： 支持Solr的大多数默认特性 (search, faceting, highlights) 数据复制，分片，缓存及压缩这些都由Cassandra来进行 Multi-master (任意结点都可供读写) 实时性高，写操作完成即可读到 Easily add new SolrCores w/o restart across the cluster 轻松添加及重启结点 官方网站：https://github.com/tjake/SolandraIndexTank IndexTank是一套基于Java的索引-实时全文搜索引擎实现，IndexTank有以下几个特点： 索引更新实时生效 地理位置搜索 支持多种客户端语言,Ruby, Rails, Python, Java, PHP, .NET &amp; more! 支持灵活的排序与评分控制 支持自动完成 支持面搜索（facet search） 支持匹配高亮 支持海量数据扩展（Scalable from a personal blog to hundreds of millions of documents! ） 支持动态数据 官方网站：https://github.com/linkedin/indextank-engine搜索引擎Compass Compass是一个强大的,事务的,高性能的对象/搜索引擎映射(OSEM:object/search engine mapping)与一个Java持久层框架.Compass包括: 搜索引擎抽象层(使用Lucene搜索引荐) OSEM (Object/Search Engine Mapping) 支持 事务管理 类似于Google的简单关键字查询语言 可扩展与模块化的框架 简单的API 官方网站：http://www.compass-project.org/Java全文搜索服务器solr Solr也是基于Java实现的，并且是基于Lucene实现的，Solr的主要特性包括：高效、灵活的缓存功能，垂直搜索功能，高亮显示搜索结果。值得注意的是，Solr还提供一款很棒的Web界面来管理索引的数据。 官方网站：http://lucene.apache.org/solr/Lucene图片搜索 LIRE LIRE是一款基于Java的图片搜索框架，其核心也是基于Lucene的，利用该索引就能够构建一个基于内容的图像检索(content- based image retrieval，CBIR)系统，来搜索相似的图像。图片搜索LIRE 官方网站：http://www.semanticmetadata.net/lire/全文本搜索引擎Egothor Egothor是一个用Java编写的开源而高效的全文本搜索引擎。借助Java的跨平台特性，Egothor能应用于任何环境的应用，既可配置为单独的搜索引擎，又能用于你的应用作为全文检索之用。 官方网站：http://www.egothor.org/cms/","categories":[{"name":"back-end","slug":"back-end","permalink":"https://CPWS.github.io/categories/back-end/"}],"tags":[{"name":"搜索引擎框架介绍","slug":"搜索引擎框架介绍","permalink":"https://CPWS.github.io/tags/搜索引擎框架介绍/"}]},{"title":"fastdsf","slug":"fastdsf","date":"2019-11-27T02:46:56.000Z","updated":"2019-11-27T06:44:50.966Z","comments":true,"path":"2019/11/27/fastdsf/","link":"","permalink":"https://CPWS.github.io/2019/11/27/fastdsf/","excerpt":"","text":"图片服务器的搭建什么是FastDFS FastDFS是用c语言编写的一款开源的分布式文件系统。FastDFS为互联网量身定制，充分考虑了冗余备份、负载均衡、线性扩容等机制，并注重高可用、高性能等指标，使用FastDFS很容易搭建一套高性能的文件服务器集群提供文件上传、下载等服务。 原理图 文件上传流程 原理图 文件下载流程上传文件的文件名 客户端上传文件后存储服务器将文件ID返回给客户端，此文件ID用于以后访问该文件的索引信息。文件索引信息包括：组名，虚拟磁盘路径，数据两级目录，文件名。 组名：文件上传后所在的storage组名称，在文件上传成功后有storage服务器返回，需要客户端自行保存。 虚拟磁盘路径：storage配置的虚拟路径，与磁盘选项store_path*对应。如果配置了store_path0则是M00，如果配置了store_path1则是M01，以此类推。 数据两级目录：storage服务器在每个虚拟磁盘路径下创建的两级目录，用于存储数据文件。 文件名：与文件上传时不同。是由存储服务器根据特定信息生成，文件名包含：源存储服务器IP地址、文件创建时间戳、文件大小、随机数和文件拓展名等信息。 FastDFS搭建 原理图 可以使用一台虚拟机来模拟，只有一个Tracker、一个Storage服务。 配置nginx访问图片。 搭建步骤： 第一步：把fastDFS都上传到linux系统。 第二步：安装FastDFS之前，先安装libevent工具包。yum -y install libevent 第三步：安装libfastcommonV1.0.7工具包。 解压缩； ./make.sh； ./make.sh install； 把/usr/lib64/libfastcommon.so文件向/usr/lib/下复制一份 第四步：安装Tracker服务。 解压缩； ./make.sh； ./make.sh install； 安装后在/usr/bin/目录下有以fdfs开头的文件都是编译出来的。配置文件都放到/etc/fdfs文件夹。 把/root/FastDFS/conf目录下的所有的配置文件都复制到/etc/fdfs下。 配置tracker服务。修改/root/FastDFS/conf/tracker.conf文件。 启动tracker。/usr/bin/fdfs_trackerd /etc/fdfs/tracker.conf 重启使用命令：/usr/bin/fdfs_trackerd /etc/fdfs/tracker.conf restart 第五步：安装storage服务。 如果是在不同的服务器安装，第四步的1~4需要重新执行。 配置storage服务。修改/root/FastDFS/conf/storage.conf文件 启动storage服务。/usr/bin/fdfs_storaged /etc/fdfs/storage.conf 重新启动storage服务。/usr/bin/fdfs_storaged /etc/fdfs/storage.conf restart 第六步：测试服务。 修改配置文件/etc/fdfs/client.conf 测试：/usr/bin/fdfs_test /etc/fdfs/client.conf upload anti-steal.jpg 第七步：搭建nginx提供http服务。 可以使用官方提供的nginx插件。要使用nginx插件需要重新编译。 fastdfs-nginx-module_v1.16.tar.gz 解压插件压缩包 修改/root/fastdfs-nginx-module/src/config文件，把其中的local去掉。 对nginx重新config./configure \\ -prefix=/usr/local/nginx \\ -pid-path=/var/run/nginx/nginx.pid \\ -lock-path=/var/lock/nginx.lock \\ -error-log-path=/var/log/nginx/error.log \\ -http-log-path=/var/log/nginx/access.log \\ -with-http_gzip_static_module \\ -http-client-body-temp-path=/var/temp/nginx/client \\ -http-proxy-temp-path=/var/temp/nginx/proxy \\ -http-fastcgi-temp-path=/var/temp/nginx/fastcgi \\ -http-uwsgi-temp-path=/var/temp/nginx/uwsgi \\ -http-scgi-temp-path=/var/temp/nginx/scgi \\ -add-module=/root/fastdfs-nginx-module/src make make install 把/root/fastdfs-nginx-module/src/mod_fastdfs.conf文件复制到/etc/fdfs目录下。编辑： tracker_server=192.168.166.131:22122 nginx的配置：在nginx的配置文件中添加一个Server： 12345678910server &#123; listen 80; server_name 192.168.166.131; location /group1/M00/&#123; #root /home/FastDFS/fdfs_storage/data; ngx_fastdfs_module; &#125;&#125; 将libfdfsclient.so拷贝至/usr/lib下，cp /usr/lib64/libfdfsclient.so /usr/lib/ 启动nginx 图片服务的使用 官方提供一个jar包 使用方法： 把FastDFS提供的jar包添加到工程中 初始化全局配置。加载一个配置文件。 创建一个TrackerClient对象。 创建一个TrackerServer对象。 声明一个StorageServer对象，null。 获得StorageClient对象。 直接调用StorageClient对象方法上传文件即可。 12345678910111213141516171819@Test public void testUpload() throws Exception &#123; // 1、把FastDFS提供的jar包添加到工程中 // 2、初始化全局配置。加载一个配置文件。 ClientGlobal.init(\"D:\\\\workspaces-itcast\\\\JaveEE18\\\\taotao-manager\\\\taotao-manager-web\\\\src\\\\main\\\\resources\\\\properties\\\\client.conf\"); // 3、创建一个TrackerClient对象。 TrackerClient trackerClient = new TrackerClient(); // 4、创建一个TrackerServer对象。 TrackerServer trackerServer = trackerClient.getConnection(); // 5、声明一个StorageServer对象，null。 StorageServer storageServer = null; // 6、获得StorageClient对象。 StorageClient storageClient = new StorageClient(trackerServer, storageServer); // 7、直接调用StorageClient对象方法上传文件即可。 String[] strings = storageClient.upload_file(\"D:\\\\Documents\\\\Pictures\\\\images\\\\2f2eb938943d.jpg\", \"jpg\", null); for (String string : strings) &#123; System.out.println(string); &#125; &#125; Client.conf 1tracker_server=192.168.25.133:22122 使用工具类上传图片 使用工具类123456@Test public void testFastDfsClient() throws Exception &#123; FastDFSClient client = new FastDFSClient(\"D:\\\\workspaces-itcast\\\\JaveEE18\\\\taotao-manager\\\\taotao-manager-web\\\\src\\\\main\\\\resources\\\\properties\\\\client.conf\"); String uploadFile = client.uploadFile(\"D:\\\\Documents\\\\Pictures\\\\images\\\\200811281555127886.jpg\", \"jpg\"); System.out.println(uploadFile); &#125;","categories":[],"tags":[{"name":"fastdsf","slug":"fastdsf","permalink":"https://CPWS.github.io/tags/fastdsf/"}]},{"title":"nginx","slug":"nginx","date":"2019-11-27T02:46:39.000Z","updated":"2019-12-05T09:01:03.736Z","comments":true,"path":"2019/11/27/nginx/","link":"","permalink":"https://CPWS.github.io/2019/11/27/nginx/","excerpt":"","text":"什么是nginx 是一个使用c语言开发的高性能的http服务器及反向代理服务器。 Nginx是一款高性能的http 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器。由俄罗斯的程序设计师Igor Sysoev所开发，官方测试nginx能够支支撑5万并发链接，并且cpu、内存等资源消耗却非常低，运行非常稳定。 Nginx的应用场景 http服务器。Nginx是一个http服务可以独立提供http服务。可以做网页静态服务器。 虚拟主机。可以实现在一台服务器虚拟出多个网站。例如个人网站使用的虚拟主机。 反向代理，负载均衡。当网站的访问量达到一定程度后，单台服务器不能满足用户的请求时，需要用多台服务器集群可以使用nginx做反向代理。并且多台服务器可以平均分担负载，不会因为某台服务器负载高宕机而某台服务器闲置的情况。 Nginx的安装 Nginx一般推荐安装到linux系统，而且要安装c语言的编译环境gcc。 下载地址: 进入http://nginx.org/en/download.html下载nginx1.8.0版本（当前最新稳定版本）。 安装步骤： 先安装nginx依赖的包： nginx是C语言开发，建议在linux上运行，本教程使用Centos6.5作为安装环境。 第一步：gcc：安装nginx需要先将官网下载的源码进行编译，编译依赖gcc环境，如果没有gcc环境，需要安装gcc：yum install gcc-c++； 第二步：PCRE：PCRE(Perl Compatible Regular Expressions)是一个Perl库，包括 perl 兼容的正则表达式库。nginx的http模块使用pcre来解析正则表达式，所以需要在linux上安装pcre库。yum install -y pcre pcre-devel；注：pcre-devel是使用pcre开发的一个二次开发库。nginx也需要此库； 第三步：Zlib：zlib库提供了很多种压缩和解压缩的方式，nginx使用zlib对http包的内容进行gzip，所以需要在linux上安装zlib库。yum install -y zlib zlib-devel； 第四步：openssl;OpenSSL 是一个强大的安全套接字层密码库，囊括主要的密码算法、常用的密钥和证书封装管理功能及SSL协议，并提供丰富的应用程序供测试或其它目的使用;nginx不仅支持http协议，还支持https（即在ssl协议上传输http），所以需要在linux安装openssl库;yum install -y openssl openssl-devel; 安装完依赖包之后，nginx的安装步骤： 第一步：把nginx的源码上传到linux系统。可以通过finalshell工具，该工具的下载链接在最下方。 第二步：把压缩包解压缩。 第三步：进行configure。./configure \\ -prefix=/usr/local/nginx \\ -pid-path=/var/run/nginx/nginx.pid \\ -lock-path=/var/lock/nginx.lock \\ -error-log-path=/var/log/nginx/error.log \\ -http-log-path=/var/log/nginx/access.log \\ -with-http_gzip_static_module \\ -http-client-body-temp-path=/var/temp/nginx/client \\ -http-proxy-temp-path=/var/temp/nginx/proxy \\ -http-fastcgi-temp-path=/var/temp/nginx/fastcgi \\ -http-uwsgi-temp-path=/var/temp/nginx/uwsgi \\ -http-scgi-temp-path=/var/temp/nginx/scgi 注意：上边将临时文件目录指定为/var/temp/nginx，需要在/var下创建temp及nginx目录 第四步：make 第五步：make install Nginx的启动、停止 启动：进入nginx的sbin目录，./nginx就可以启动。 如果访问不到，首先查看防火墙是否关闭。 service iptables status 关闭nginx： 可以使用kill命令，但是不推荐使用。 推荐使用：./nginx -s stop 刷新配置：./nginx -s reload Nginx的配置 在/usr/local/nginx/conf目录下nginx.conf文件是nginx的配置文件。 使用nginx配置虚拟机 在nginx.conf文件中添加一个Service节点，修改端口号就可以 12345678910111213server &#123; listen 81; server_name localhost; #charset koi8-r; #access_log logs/host.access.log main; location / &#123; root html81; index index.html index.htm; &#125; &#125; 通过域名区分虚拟机 域名介绍 可以通过修改host文件指定域名的ip地址。 Host文件的位置：C:\\Windows\\System32\\drivers\\etc 配置基于域名的虚拟主机 需要修改nginx.conf配置文件。 12345678910111213server &#123; listen 80; server_name test3.taotao.com; #charset koi8-r; #access_log logs/host.access.log main; location / &#123; root html-test3; index index.html index.htm; &#125; &#125; 修改配置后需要重新加载配置文件。 Nginx的反向代理 什么是反向代理 正向代理 反向代理 反向代理服务器是引用在服务端。决定哪台服务器提供服务。 反向代理的模拟 反向代理:应该有一个nginx服务器有多个应用服务器（可以是tomcat）、可以使用一台虚拟机，安装一个nginx，多个tomcat，来模拟。 Nginx的配置文件： 123456789101112131415161718upstream tomcats&#123; server 192.168.25.148:8080; server 192.168.25.148:8081; &#125; server &#123; listen 80; server_name tomcat.taotao.com; #charset koi8-r; #access_log logs/host.access.log main; location / &#123; proxy_pass http://tomcats; index index.html index.htm; &#125; &#125; nginx负载均衡 只需要在upstream的server后面添加一个weight即可代表权重。权重越高，分配请求的数量就越多。默认权重是1 链接 finalshell下载链接：http://www.hostbuf.com/","categories":[{"name":"back-end","slug":"back-end","permalink":"https://CPWS.github.io/categories/back-end/"}],"tags":[{"name":"nginx","slug":"nginx","permalink":"https://CPWS.github.io/tags/nginx/"}]},{"title":"redis","slug":"redis","date":"2019-11-21T07:52:33.000Z","updated":"2019-12-05T09:01:09.357Z","comments":true,"path":"2019/11/21/redis/","link":"","permalink":"https://CPWS.github.io/2019/11/21/redis/","excerpt":"","text":"Redis简介 Redis是完全开源免费的，遵守BSD协议，是一个高性能的key-value数据库. Redis是一个开源的使用C语言编写的、支持网络、可基于内存亦可持久化的日志型、key-value数据库，并提供多种语言的API。 redis的作者，叫Salvatore Sanfilippo，来自意大利的西西里岛，现在居住在卡塔尼亚。目前供职于Pivotal公司。他使用的网名是antirez。 NOSQL介绍： 泛指非关系型数据库：数据与数据之间没有关联关系 SQL： 关系型数据库：表与表之间有关联关系。 NoSQL数据库的四大分类 键值存储数据库：主要会使用哈希表；一个key对应一个value值，例如redis，MongoDb 列存储数据库：HBase 文档型数据库:MongoDb 图形数据库：Neo4J 总结NoSQL数据库在以下的这几种情况下比较适用： 数据模型比较简单； 需要灵活性更强的IT系统； 对数据库性能要求比较高； 不需要高度的数据库一致性； 对于给定的key，比较容易映射复杂值的情况; Linux安装 官方网站：http://redis.io 安装步骤 安装gcc：yum -y install gcc automake autoconf libtool make 到官网上下载redis 把下载好的redis上传到Linux上 解压压缩文件 tar zxvf 压缩文件名 然后进入redis文件夹，进行编译:make或make MALLOC=libc，如下图代表成功 make PREFIX=/usr/local/redis install：（安装编译后的文件）安装到指定目录。 注意: PREFIX必须大写，同时会自动为我们创建redis目录，并将结果安装到此目录。 到此redis安装完成。 Redis启动 启动Redis服务 进入对应的安装目录：/usr/local/redis 执行命令：./bin/redis-server 启动Redis客户端 进入对应的安装目录：/usr/local/redis 执行命令：./bin/redis-cli 启动redis客户端命令： redis-cli -h IP地址 -p 端口 退出客户端命令: Ctrl+C 测试是否服务端启动 启动redis客户端，打开终端并输入命令redis-cli。该命令连接到本地的redis服务。 使用PING检测是否连接成功。 Redis配置文件详解redis.conf Redis的配置文件位于Redis安装目录下，文件名为redis.conf(Windows名为redis.windows.conf)。 到redis-4.0.14目录下的redis复制到/usr/local/redis:cp redis.conf /usr/local/redis 你可以通过CONFIG命令查看或设置配置项。 语法：Redis CONFIG命令语法格式如下： reids 127.0.0.1:6379&gt;CONFIG GET CONFIG_SETTING_NAME redis配置文件详解 daemonize no：Redis 默认不是以守护进程的方式运行，可以通过该配置项修改，使用 yes 启用守护进程（Windows 不支持守护线程的配置为 no ）。 pidfile /var/run/redis.pid：当 Redis 以守护进程方式运行时，Redis 默认会把 pid 写入 /var/run/redis.pid 文件，可以通过 pidfile 指定。 port 6379：指定 Redis 监听端口，默认端口为 6379，作者在自己的一篇博文中解释了为什么选用 6379 作为默认端口，因为 6379 在手机按键上 MERZ 对应的号码，而 MERZ 取自意大利歌女 Alessia Merz 的名字。 bind命令：绑定主机地址.bind 127.0.0.1。 timeout 300：当客户端闲置多长时间后关闭连接，如果指定为 0，表示关闭该功能 loglevel notice：指定日志记录级别，Redis 总共支持四个级别：debug、verbose、notice、warning，默认为 notice。 logfile stdout：日志记录方式，默认为标准输出，如果配置 Redis 为守护进程方式运行，而这里又配置为日志记录方式为标准输出，则日志将会发送给 /dev/null。 databases 16：设置数据库的数量，默认数据库为0，可以使用SELECT 命令在连接上指定数据库id。 save &lt;seconds&gt; &lt;changes&gt;：指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合。 redis默认配置文件中提供如下三个： save 900 1 save 300 10 save 60 10000 分别表示 900 秒（15 分钟）内有 1 个更改，300 秒（5 分钟）内有 10 个更改以及 60 秒内有 10000 个更改。 rdbcompression yes:指定存储至本地数据库时是否压缩数据，默认为 yes，Redis 采用 LZF 压缩，如果为了节省 CPU 时间，可以关闭该选项，但会导致数据库文件变的巨大. dbfilename dump.rdb：指定本地数据库文件名，默认值为 dump.rdb。 dir ./：指定本地数据库存放目录。 slaveof &lt;masterip&gt; &lt;masterport&gt;：设置当本机为 slave 服务时，设置 master 服务的 IP 地址及端口，在 Redis 启动时，它会自动从 master 进行数据同步。 masterauth &lt;master-password&gt;：当 master 服务设置了密码保护时，slave 服务连接 master 的密码。 requirepass foobared：设置 Redis 连接密码，如果配置了连接密码，客户端在连接 Redis 时需要通过 AUTH &lt;password&gt; 命令提供密码，默认关闭。 maxclients 128：设置同一时间最大客户端连接数，默认无限制，Redis 可以同时打开的客户端连接数为 Redis 进程可以打开的最大文件描述符数，如果设置 maxclients 0，表示不作限制。当客户端连接数到达限制时，Redis 会关闭新的连接并向客户端返回 max number of clients reached 错误信息。 maxmemory &lt;bytes&gt;：指定 Redis 最大内存限制，Redis 在启动时会把数据加载到内存中，达到最大内存后，Redis 会先尝试清除已到期或即将到期的 Key，当此方法处理 后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。Redis 新的 vm 机制，会把 Key 存放内存，Value 会存放在 swap 区。 appendonly no：指定是否在每次更新操作后进行日志记录，Redis 在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时导致一段时间内的数据丢失。因为 redis 本身同步数据文件是按上面 save 条件来同步的，所以有的数据会在一段时间内只存在于内存中。默认为 no。 appendfilename appendonly.aof：指定更新日志文件名，默认为 appendonly.aof。 appendfsync everysec：指定更新日志条件，公有三个可选值。no：表示等操作系统进行数据缓存同步到磁盘（快）；always：表示每次更新操作后手动调用 fsync() 将数据写到磁盘（慢，安全）；表示每秒同步一次（折中，默认值）； vm-enabled no：指定是否启用虚拟内存机制，默认值为 no，简单的介绍一下，VM 机制将数据分页存放，由 Redis 将访问量较少的页即冷数据 swap 到磁盘上，访问多的页面由磁盘自动换出到内存中（在后面的文章我会仔细分析 Redis 的 VM 机制）。 vm-swap-file /tmp/redis.swap：虚拟内存文件路径，默认值为 /tmp/redis.swap，不可多个 Redis 实例共享。 vm-max-memory 0：将所有大于 vm-max-memory 的数据存入虚拟内存，无论 vm-max-memory 设置多小，所有索引数据都是内存存储的(Redis 的索引数据 就是 keys)，也就是说，当 vm-max-memory 设置为 0 的时候，其实是所有 value 都存在于磁盘。默认值为 0。 vm-page-size 32：Redis swap 文件分成了很多的 page，一个对象可以保存在多个 page 上面，但一个 page 上不能被多个对象共享，vm-page-size 是要根据存储的 数据大小来设定的，作者建议如果存储很多小对象，page 大小最好设置为 32 或者 64bytes；如果存储很大大对象，则可以使用更大的 page，如果不确定，就使用默认值。 vm-pages 134217728：设置 swap 文件中的 page 数量，由于页表（一种表示页面空闲或使用的 bitmap）是在放在内存中的，，在磁盘上每 8 个 pages 将消耗 1byte 的内存。 vm-max-threads 4：设置访问swap文件的线程数,最好不要超过机器的核数,如果设置为0,那么所有对swap文件的操作都是串行的，可能会造成比较长时间的延迟。默认值为4。 glueoutputbuf yes：设置在向客户端应答时，是否把较小的包合并为一个包发送，默认为开启。 hash-max-zipmap-entries 64、hash-max-zipmap-value 512：指定在超过一定的数量或者最大的元素超过某一临界值时，采用一种特殊的哈希算法。 activerehashing yes：指定是否激活重置哈希，默认为开启（后面在介绍 Redis 的哈希算法时具体介绍） include /path/to/local.conf：指定包含其它的配置文件，可以在同一主机上多个Redis实例之间使用同一份配置文件，而同时各个实例又拥有自己的特定配置文件。 Redis缺点：占用很大的内存空间，在redis中有两种解决方案 一是为数据设置超时时间。 二是采用LRU算法动态将不同的数据删除。 设定内存空间，建议内存不要超过1G 256-512M 自定义配置redis 进入对应的安装目录：/usr/local/redis，修改redis.conf配置文件：vim redis.conf Redis配置默认必须修改 daemonize no 修改为 daemonize yes bind 127.0.0.1 注释掉 requirepass 设置密码 重新启动redis服务：./bin/redis-server ./redis-conf 查看状态：ps -ef | grep -i redis 重启启动redis客户端：注意此时是带有密码。 远程服务执上行命令：redis-cli -h host -p port -a password、redis-cli -h IP地址 -p 端口 -a 密码。 key *：查看所有的key值。 set key：指定key-value值。 get key：获取key对应的值。 Redis关闭 第一种方式：（断电、非正常关闭。容易丢失数据） 查询PID：ps -ef | grep -i redis。 kill -9 PID。 第二种方式：（正常关闭，数据保存） ./bin/redis-cli shutdown：关闭redis服务，通过客户端进行shutdown 如果redis设置了密码，需要现在客户端通过密码登录，再进行shutdown即可关闭服务端。 Redis基本命令 Redis命令用于在Redis服务上执行操作。 要在Redis服务上执行命令需要一个Redis客户端。 Redis客户端在我们之前下载的Redis的安装包中。 Redis 键(key) Redis健命令的基本语法：COMMAND KEY_NAME DEL key：该命令用于在key存在时删除key。 DUMP key：序列化给定key，并返回被序列化的值。 EXISTS key：判断指定的key是否存在。 EXPIRE key seconds：为给定key设置过期时间，以秒计。 TTL key：以秒为单位返回key的剩余的过期时间。 PTTL key：以秒为单位返回key的剩余的过期时间（毫秒）。 EXPIRE key second：为给定的key设置过期时间（以秒计）。 PEXPIRE key miilsecond：为给定的key设置过期时间（以毫秒计）。 presist key：将key永久有效 key pattern：查找所有的key。* , ? rename key newkey：修改指定key的名称 move key db：将指定key移到指定数据库。 key：返回指定key所存储的数据类型 … 剩余的查看https://www.runoob.com/redis/redis-keys.html 应用场景 expire key seconds： 限时的优惠活动信息。 网站数据缓存（对于一些需要定时更新的数据，例如：积分排行版） 手机验证码 限时网站访客访问频率（例如：1分钟最多访问10次） Redis中key的命名规范 key的命名建议： Redis单个key存入512M大小 key可以不要太长，尽量不要超过1024字节，这不仅消耗内存，而且会降低查找的效率。 key也不要太短，太短的话，key的可读性会降低 在一个项目中，key最好使用统一的命名模式，例如user:123:password key的名称区分大小写 String类型简介 String是redis最基本的类型，一个key对应一个value. String是二进制完全。意思是redis的string可以包含任何数据。比如jpg图片或者是序列化对象. String类型是redis最基本的数据类型，一个键最大能存储512MB。 二进制安全是指，在传输数据时，保证二进制数据的信息完全，也就是不被篡改、破译等，如果被攻击，能给即时检测出来。 二进制完全特点 编码、解码发生在客户端完成，执行效率高。 不需要频繁的编解码，不会出现乱码。 String类型的常用指令 赋值语法：SAET KEY_Name VALUE。用于给指定的key设置值，如果在key已经存储值，SET就覆写旧值，且无视类型。 取值语法：GET KEY_NAME，如果key不存在，则返回nil。如果key存储的值不是字符串类型，返回一个错误。 SETNX key value：如果key不存在时设置key的值。 getrange key start end：返回 key 中字符串值的子字符 GETBIT key offset：对 key 所储存的字符串值，获取指定偏移量上的位(bit)。 GETSET key value： 将给定 key 的值设为 value ，并返回 key 的旧值(old value)。 MGET key1 [key2..]：获取所有(一个或多个)给定 key 的值。 strlen key：返回key所存储的字符串值的长度。 删除语法：del key_name：删除指定的key，如果存在，返回值数字类型。 自增/自减 incr key_name、DECR Key_Name；incrby key_name 数字/decrby ley_name 数字：自增数字/自减数字 set key value：解决分布式锁方案之一 应用场景 String通常用于保存当个字符串或json字符串数据。 因String是二进制安全，通常可以利用它存储图片。 计数器。 Incr是原子性操作。 哈希(Hash) 简介： hash 是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象。Redis 中每个 hash 可以存储 232 - 1 键值对（40多亿）。 常用命令 hset key field value：将哈希表中的key中的字段field的值设为value。 hmset key field value：将多个值同时存储。 hget key field：获取存储在哈希表中指定字段的值。 hmget key field1,field2：获取key所有给定字段的值。 hmgetall key：返回Hash表所有的字段和值。 hkeys key：获取所有哈希表中的字段。 hlen key：获取哈希表字段的数量。 删除语法: hdel key field[field]：删除指定key中的指定一个或多个属性。 hincrby key field increment：将key中的field增加increment。 hsetex key age：当不存在时设置值。 hexists key field：查看hash表中，指定字段是否存在。 HINCRBYFLOAT key field increment：为哈希表 key 中的指定字段的浮点数值加上增increment 。 hkeys key：获取所有哈希表中的字段。 hvals key:获取哈希表中所有值。 应用场景:(存储一个用户信息对象数据) 常用于存储一个对象。 为什么不使用string存储一个对象。 Java连接Redis 在官方网站列一些Java客户端访问，有：Jedis/Redisson/Jredis/JDBC-Redis等，其中官方推荐使用的是Jedis和Redisson。常用Jedis。 Jedis的使用步骤: 在Java工程中导入jar包 使用Jedis jedis=new Jedis(&quot;192.168.166.132&quot;, 6379);与redis建立连接，第一个参数为ip地址，第二个参数为端口号。 使用jedis.auth(&quot;123456&quot;);输入连接密码进行连接。 进行相关操作。注意：jedis中的方法与redis中的指令基本相同。 关闭连接对象。 注意：此处还要释放Linux对外开放的端口号：6379； 修改防火墙：vim /etc/syscofnig/iptables 修改完之后重启防火墙：service iptables restart 案例实现： 123456789public static void main(String[] args) &#123; String host=\"192.168.166.132\"; int port=6379; //连接redis服务器 Jedis jedis=new Jedis(host, port); //连接redis密码 jedis.auth(\"123456\"); System.out.println(jedis.ping());&#125; 12345678910111213141516/*** * 测试字符串string * Redis中有哪些命令，jedis就有哪些方法 */@Testpublic void t1() &#123; //连接redis服务器 Jedis jedis=new Jedis(\"192.168.166.132\", 6379); //连接redis密码 jedis.auth(\"123456\"); jedis.set(\"strName\", \"字符串的名称\"); String strName = jedis.get(\"strName\"); System.out.println(\"redis中的数据：\"+strName); //关闭redis jedis.close();&#125; 12345678910111213141516171819202122232425/*** * redis作用：为了减轻数据库（Mysql）的访问压力 * 需求：判断某key是否存在，如果存在，就从Redis中查询，如果不存在就查询数据库，且将查询结果存入到redis; */@Testpublic void t2() &#123; //连接redis服务器 Jedis jedis=new Jedis(\"192.168.166.132\", 6379); //连接redis密码 jedis.auth(\"123456\"); String key=\"applicationName\";//key的名称 if(jedis.exists(key)) &#123; //存在，直接获取 String result = jedis.get(key); System.out.println(result); &#125;else &#123; //在数据库中查询 String result=\"微信开发会议达人\"; jedis.set(key, result); System.out.println(\"Mysql数据库中查询得到：\"+result); &#125; jedis.close();&#125; Jedis工具类 Jedis连接池优化操作 123456789101112131415public static void main(String[] args) &#123; //Jedis连接池 //1.连接池Redis POOL 基本配置信息 JedisPoolConfig poolConfig=new JedisPoolConfig(); poolConfig.setMaxTotal(5);//设置最大连接数 poolConfig.setMaxIdle(1);//设置最大空闲数 //... //2. 连接池 JedisPool pool=new JedisPool(poolConfig, \"192.168.166.132\",6379); Jedis jedis=pool.getResource(); jedis.auth(\"123456\"); System.out.println(jedis.ping()); jedis.close(); &#125; Jedis工具类 1234567891011121314151617181920212223242526272829303132333435363738394041/*** * 获取redis连接工具类 * @author 1huangzewei * */public class RedisPoolUtil &#123; //Jedis连接池对象 private static JedisPool pool; //连接redis的IP地址 private static String host=\"192.168.166.132\"; //连接redis的IP地址的所在端口 private static int port=6379; //连接redis服务端的密码 private static String pwd=\"123456\"; static &#123; //Jedis连接池 //1.连接池Redis POOL 基本配置信息 JedisPoolConfig poolConfig=new JedisPoolConfig(); poolConfig.setMaxTotal(5);//设置最大连接数 poolConfig.setMaxIdle(1);//设置最大空闲数 //...其他配置 //2. 连接池 pool=new JedisPool(poolConfig, host,port); &#125; /*** * 获取连接对象 * @return Jedis */ public static Jedis getJedis() &#123; Jedis jedis = pool.getResource(); jedis.auth(pwd); return jedis; &#125; /** * 释放资源 * @param jedis */ public static void close(Jedis jedis) &#123; jedis.close(); &#125;&#125; Jedis-hash类型读取 案例一 123456789101112131415161718192021222324/*** * Jedis完成对hash类型操作 * 需求：hash存储一个对象 * 判断redis中是否存在该key，如果存在，直接返回，如果不存在，数据库查询，并将结果存储在redis */@Testpublic void t4() &#123; Jedis jedis=RedisPoolUtil.getJedis(); String key=\"users\"; if(jedis.exists(key)) &#123; Map&lt;String, String&gt; map = jedis.hgetAll(key); System.out.println(\"从redis中查询的数据\"); System.out.println(map.get(\"id\")+\"\\t\"+map.get(\"name\")); System.out.println(map.get(\"age\")+\"\\t\"+map.get(\"remark\")); &#125;else &#123; System.out.println(\"从数据库中查询结果并且赋值到redis\"); //查询数据库并返回结果 jedis.hset(key,\"id\",\"1\"); jedis.hset(key,\"name\",\"迪丽热巴\"); jedis.hset(key, \"age\",\"27\"); jedis.hset(key, \"remark\",\"这是一位女明星\"); &#125; RedisPoolUtil.close(jedis);&#125; 案例二：对案例一进行优化 123456789101112131415161718192021222324252627/*** * 对上面方法进行优化 */@Testpublic void t5() &#123; //Users selectById(String id); Jedis jedis=RedisPoolUtil.getJedis(); int id=1; String key=User.getKeyName()+id;//user:1 if(jedis.exists(key)) &#123; //从redis中取出对象 Map&lt;String, String&gt; hash = jedis.hgetAll(key); User u=new User(Integer.parseInt(hash.get(\"id\")),hash.get(\"name\"),Integer.parseInt(hash.get(\"age\")),hash.get(\"remark\")); System.out.println(\"redis中查询的结果：\"+u); &#125;else &#123; //查询数据库并返回结果 User u=new User(id,\"迪丽热巴\",27,\"这是一位女明星\"); Map&lt;String,String&gt; map=new HashMap&lt;String, String&gt;(); map.put(\"id\", id+\"\"); map.put(\"name\",u.getName()); map.put(\"age\",u.getAge()+\"\"); map.put(\"remark\",u.getRemark()); jedis.hmset(key, map); System.out.println(\"从数据库中查询结果并且赋值到redis的对象为：\"+u); &#125; RedisPoolUtil.close(jedis);&#125; - SpringData整合redis 步骤 导入jar包 12345678910111213141516171819202122232425&lt;!-- Jedis客户端需要依赖的jar Redis --&gt;&lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;2.6.2&lt;/version&gt;&lt;/dependency&gt; &lt;!-- springdata整个redis --&gt;&lt;!-- https://mvnrepository.com/artifact/org.springframework.data/spring-data-redis --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.data&lt;/groupId&gt; &lt;artifactId&gt;spring-data-redis&lt;/artifactId&gt; &lt;version&gt;1.4.2.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/commons-logging/commons-logging --&gt;&lt;dependency&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; 编写配置文件：spring_redis.xml 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd\"&gt; &lt;!-- 注解扫描 --&gt; &lt;context:component-scan base-package=\"com.gdaib.service.impl\"&gt;&lt;/context:component-scan&gt; &lt;!-- 配置一个连接池信息 --&gt; &lt;bean id=\"jedisPoolConfig\" class=\"redis.clients.jedis.JedisPoolConfig\"&gt; &lt;!-- 最大连接数 --&gt; &lt;property name=\"maxTotal\" value=\"50\"&gt;&lt;/property&gt; &lt;!-- 最大空闲数 --&gt; &lt;property name=\"maxIdle\" value=\"5\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- Spring整合Jedis(redis) --&gt; &lt;bean id=\"jedisConnectionFactory\" class=\"org.springframework.data.redis.connection.jedis.JedisConnectionFactory\"&gt; &lt;!-- 指定服务器地址 --&gt; &lt;property name=\"hostName\" value=\"192.168.166.132\"&gt;&lt;/property&gt; &lt;!-- 指定服务器端口号 --&gt; &lt;property name=\"port\" value=\"6379\"&gt;&lt;/property&gt; &lt;!-- 指定密码 --&gt; &lt;property name=\"password\" value=\"123456\"&gt;&lt;/property&gt; &lt;!-- 自定义连接池配置 --&gt; &lt;property name=\"poolConfig\" ref=\"jedisPoolConfig\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- RedisTemplate --&gt; &lt;bean id=\"redisTemplate\" class=\"org.springframework.data.redis.core.RedisTemplate\"&gt; &lt;property name=\"connectionFactory\" ref=\"jedisConnectionFactory\"&gt;&lt;/property&gt; &lt;!-- key进行序列化设置，默认JDK改为String --&gt; &lt;property name=\"keySerializer\"&gt; &lt;bean class=\"org.springframework.data.redis.serializer.StringRedisSerializer\"&gt;&lt;/bean&gt; &lt;/property&gt; &lt;!-- value JDK默认为String --&gt; &lt;property name=\"valueSerializer\"&gt; &lt;bean class=\"org.springframework.data.redis.serializer.StringRedisSerializer\"&gt;&lt;/bean&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 编写业务逻辑接口：UserService 123456public interface UserService &#123; /** * string 存和取测试 */ public String getString(String key);&#125; 编写该接口的实现类：UserServiceImpl.java 1234567891011121314151617181920212223242526272829303132333435@Servicepublic class UserServiceImpl implements UserService&#123; @Autowired private RedisTemplate&lt;String, String&gt; redisTemplate; /*** * string类型测试 * 通过某个key得到值 * 如果key在redis中不存在，到数据库查询 * 如果存在，就到redis中查询 */ @Override public String getString(String key) &#123; ValueOperations&lt;String, String&gt; string = redisTemplate.opsForValue(); //先赋值后设置失效日期 //redisTemplate.opsForValue().set(\"java1803\", \"这是一个测试数据\"); //redisTemplate.expire(key, 2, TimeUnit.HOURS); redisTemplate.opsForValue().set(\"java1803\", \"这是一个测试数据\", 2, TimeUnit.SECONDS); //判断redis中是否存在key if(redisTemplate.hasKey(key)) &#123; //在redis中取出并返回 System.out.println(\"在redis中取出并返回\"); return string.get(key); &#125;else &#123; //查询数据库 String result=\"RedisTemplate模板练习\"; string.set(key,result); System.out.println(\"Mysql数据库中取出并返回\"); return result; &#125; &#125;&#125; 编写测试类 RedisTemplateTest.java 123456789101112/*** * 测试string RedisTemplate */@Testpublic void t1() &#123; ApplicationContext ctx=new ClassPathXmlApplicationContext(\"spring_redis.xml\"); UserService userService = ctx.getBean(UserService.class); String key=\"java1803\"; String result = userService.getString(key); System.out.println(result); &#125; Redis客户端工具： https://redisdesktop.com/download http://www.pc6.com/softview/SoftView_450180.html 序列化：修改配置文件：123456789&lt;!-- key进行序列化设置，默认JDK改为String --&gt;&lt;property name=\"keySerializer\"&gt; &lt;bean class=\"org.springframework.data.redis.serializer.StringRedisSerializer\"&gt;&lt;/bean&gt;&lt;/property&gt;&lt;!-- value JDK默认为String --&gt;&lt;property name=\"valueSerializer\"&gt; &lt;bean class=\"org.springframework.data.redis.serializer.StringRedisSerializer\"&gt;&lt;/bean&gt;&lt;/property&gt;&lt;/bean&gt; 案例作业限制登录功能：用户在两个小时内仅允许输入错误密码3次。如果超过次数，限制其登录5小时。 登录页面login.jsp（要求每次登录失败时，都给相应提示） 后台建个用户登录表。输入用户名和密码 如果用户在2分钟内输入密码错误3次，如果超过3次，给其提示：连续输错密码超过三次。限制其登录1小时 用户在2分钟内，仅允许输入错误密码5次、如果超过次数，限制其登录1小时。 （12306） hash基本指令 案例 业务逻辑 UserServiceImpl.java 123456789public interface UserService &#123; /*** * hash 存储测试 * @param u */ public void add(User u); public User selectById(int id);&#125; 1234567891011121314151617181920212223242526272829303132333435363738@Servicepublic class UserServiceImpl implements UserService&#123; @Autowired private RedisTemplate&lt;String, String&gt; redisTemplate; //模板的简化 @Resource(name=\"redisTemplate\") HashOperations&lt;String, String,User&gt; hash; //存储 往redis中存储hash数据 public void add(User u) &#123; hash.put(\"user\", u.getId()+\"\", u); &#125; /** * 根据用户主键id查询对象 * @return */ public User selectById(int id) &#123; //先判断Redis中key是否存在，如果存在，从Redis中取出，并且返回 Boolean bol=false; try &#123; bol = hash.hasKey(\"user\",id+\"\"); &#125;catch(Exception e) &#123; e.printStackTrace(); bol=false; &#125; if(bol) &#123; User u = (User) redisTemplate.opsForHash().get(\"user\", id+\"\"); System.out.println(\"redis数据库中查询的数据\"); return u; &#125;else &#123; //hash存储类型 com.gdaib.pojo.User u=new com.gdaib.pojo.User(id,\"哈哈呵呵\",25,\"这是一个女明星！\"); System.out.println(\"mysql中查询的数据\"); hash.put(\"user\", u.getId()+\"\", u); return u; &#125; //如果不存在，从数据库中查询，取出付给Redis，返回 &#125;&#125; 测试代码 1234567891011121314151617181920212223242526272829public class RedisTemplateTest &#123; /*** * 测试hash */ @Test public void t2() &#123; ApplicationContext ctx=new ClassPathXmlApplicationContext(\"spring_redis.xml\"); UserService userService = ctx.getBean(UserService.class); //hash存储类型 com.gdaib.pojo.User u=new com.gdaib.pojo.User(2,\"欧阳娜娜\",20,\"这是一个女明星！\"); userService.add(u); System.out.println(\"---------hash数据存储成功hash---------\"); &#125; /*** * 测试hash */ @Test public void t3() &#123; ApplicationContext ctx=new ClassPathXmlApplicationContext(\"spring_redis.xml\"); UserService userService = ctx.getBean(UserService.class); int id=7; User u = userService.selectById(id); System.out.println(u); &#125;&#125; 修改默认的序列化设置12345678 &lt;!-- RedisTemplate --&gt;&lt;bean id=\"redisTemplate\" class=\"org.springframework.data.redis.core.RedisTemplate\"&gt;&lt;property name=\"connectionFactory\" ref=\"jedisConnectionFactory\"&gt;&lt;/property&gt;&lt;!-- hash key序列化设置，默认jdk改为hash --&gt;&lt;property name=\"hashKeySerializer\"&gt; &lt;bean class=\"org.springframework.data.redis.serializer.StringRedisSerializer\"&gt;&lt;/bean&gt;&lt;/property&gt;&lt;/bean&gt; List基本命令 Redis列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。 一个列表最多可以包含 2^32 - 1 个元素 (4294967295, 每个列表超过40亿个元素)。 类似于JAVA语言的LinkedList. 命令 赋值语法： LPUSH key value1 [value2]：讲一个或多个值插入到列表头部（从左侧添加）。 RPUSH key value1 [value2]：在列表中添加一个或多个值（从右侧添加）。 LPUSHX key value：将一个值插入到已经存在的列表头部。如果列表不存在，操作无效。 RPUSHX key value：一个值插入到已经存在的列表的尾部（最右边）。如果列表不存在，操作无效。 取值语法： LLEN key：取得列表长度。 Lindex key index：通过索引取得列表中的元素。 LRANGE key start stop：获取列表指定范围的元素。（0代表一个元素，1代表第二个元素，-1代表最后元素，-2代表倒数第二个） 删除语法： LPOP key：溢出并获取列表的第一个元素（从左侧删除）。 RPOP key：移除列表的最后一个元素，返回值为移除值。 BLPOP key1 [key2] timeout：移除并获取列表的第一个元素，如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。（如果超时返回nil） BRPOP key1 [key2 ] timeout：移出并获取列表的最后一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。 LTRIM key start stop：对一个列表进行修剪（trim），就是说，让列表只保留指定区间内的元素，不在指定区域内的元素都将被删除。 修改语法 LSET key index value：通过索引设置列表元素的值。 LINSERT key BEFORE|AFTER world value2:在列表指定元素前或后插入元素。 高级语法 RPOPLPUSH source destination：移除列表最后一元素，并将该元素添加到另一个列表并返回。 BRPOPLPUISH source destination timeout：从列表中弹出一个值，将弹出的元素插入到另一个列表中并返回他；如果列表中没有元素会阻塞列表直到等待超时或者发现可弹出元素为止。 LREM key count value：移除列表元素 应用场景 对数据量大的集合数据删减（列表展示、关注列表、粉丝列表、留言评价等…分页、热点新闻（TOP5）等） 任务队列 Set类型 Redis 的 Set 是 String 类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。 Redis 中集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。 集合中最大的成员数为 232 - 1 (4294967295, 每个集合可存储40多亿个成员)。 底层是hashtable和intset。 命令 赋值语法 SADD key member1 [member2]：向集合中添加一个或多个成员。 取值语法 SCARD key：获取集合的成员数。 SMEMBERS key：返回集合中的所有成员。 SISMENBER key member：判断member元素是否是集合key的成员（开发中：验证是否存在判断） SRANDMENBER key [count]：返回集合中一个或多个随机数。 SSCAN key cursor [MATCH pattern] [COUNT count]：迭代集合中的元素。 删除语法 SREM key member1 [member2]：移除集合中一个或多个元素。 SPOP key[count]：移除并返回集合中的一个随机元素。 SMOVE source destination member：将member元素从source集合移动到destination集合。 差集语法 SDIFF key1 [key2]：返回给定集合的差集（左侧） SDIFFSTORE destination key1 [key2]：返回给定所有集合的差集并存储在destination中。 交集语法 SINTER key1 [key2]：返回给定所有集合的交集（共有的数据）。 SINTERSTORE key1 [key2]：返回给定所有集合的交集并存储在destination中。 并集语法 SUNION key1 [key2]：返回所有给定集合的并集。 SUNIONSTORE destination key1 [key2]：返回所有给定集合的并集并存储在destination中。 应用场景 常应用于：对两个集合间的数据【计算】进行并集、交集、差集运算。 非常方便实现如共同关注、共同爱好、二度好友等， 利用唯一性，还可以统计访问网站的所有独立IP。 Zset类型 Redis 有序集合和集合一样也是string类型元素的集合,且不允许重复的成员。 不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。 有序集合的成员是唯一的,但分数(score)却可以重复。 集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。 集合中最大的成员数为 232 - 1 (4294967295, 每个集合可存储40多亿个成员)。 底层是hashtable和intset。 命令 赋值语法 ZADD key source member1 [source2 member2]：向有序集合中添加一个或多个成员，或者更新已存在成员的分数。 取值语法 ZCARD key：获取有序集合元素的成员数。 ZCOUNT key min max：计算在有序集合中指定区间分数的成员数。 ZRANK key member：返回有序集合中指定成员（索引）。 ZRANGE key start stop [WITHSCORES]：通过索引区间返回有序集合成员指定区间内的成员（低到高）。 ZREVRANGE key start stop[WITHSCORES]：返回有序集合中指定区间内的成员，通过索引，分数从高到低。 ZREVRANGEBYSCORE key max min [WITHSCORES]：返回有序集中指定分数区间内的成员，分数从高到低排序。 ZREVRANK key member：返回有序集合中指定成员的排名，有序集成员按分数值递减(从大到小)排序。 ZSCORE key member：返回有序集中，成员的分数值。 ZSCAN key cursor [MATCH pattern] [COUNT count]:迭代有序集合中的元素（包括元素成员和元素分值）。 ZLEXCOUNT key min max：在有序集合中计算指定字典区间内成员数量。 ZRANGEBYLEX key min max [LIMIT offset count]：通过字典区间返回有序集合的成员。 ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT]：通过分数返回有序集合指定区间内的成员。 删除语法 del key：移除集合 ZREM key member [member2]：移除有序集合中的一个或多个成员。 ZREMRANGEBYLEX key min max：移除有序集合中给定的字典区间的所有成员。 ZREMRANGEBYRANK key start stop：移除有序集合中给定的排名区间的所有成员(第一名为0)（低到高）。 ZREMRANGEBYSCORE key min max：移除有序集合中给定的分数区间的所有成员。 并集语法 ZUNIONSTORE destination numkeys key [key ...]：计算给定的一个或多个有序集的并集，并存储在新的 key 中 交集语法 ZINTERSTORE destination numkeys key [key ...]：计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合 key 中。 增量语法 ZINCRBY key increment member ：有序集合中对指定成员的分数加上增量 increment。 应用场景 常应用于：排行榜。 HyperLogLog类型 Redis 在 2.8.9 版本添加了 HyperLogLog 结构。 Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定 的、并且是很小的。 在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基 数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。 但是，因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。 什么是基数 比如数据集 {1, 3, 5, 7, 5, 7, 8}， 那么这个数据集的基数集为 {1, 3, 5 ,7, 8}, 基数(不重复元素)为5。 基数估计就是在误差可接受的范围内，快速计算基数。 命令 赋值语法 PFADD key element [element ...]：添加指定元素到 HyperLogLog 中。 取值语法 PFCOUNT key [key ...]：返回给定 HyperLogLog 的基数估算值。 合并语法 PFMERGE destkey sourcekey [sourcekey ...]：将多个HyperLogLog合并为一个HyperLogLog。 Redis发布订阅 简介： Redis发布订阅（pub/sub）是一种消息通信模式：发布者（pub）发布信息，订阅者（sub）接收信息。 Redis客户端可以订阅任意数量的频道。 Redis 发布订阅命令 订阅频道 SUBSCRIBE channel [channel ...]：订阅给定的一个或多个频道的信息。 PSUBSCRIBE pattern [pattern ...]：订阅一个或多个符合给定模式的频道。 发布频道 PUBLISH channel message：将信息发送到指定的频道。 退订频道 UNSUBSCRIBE [channel [channel ...]]：指退订给定的频道。 PUNSUBSCRIBE [pattern [pattern ...]]：退订所有给定模式的频道。 其他 PUBSUB subcommand [argument [argument ...]]：查看订阅与发布系统状态。 应用场景 构建实时消息系统，比如普通的即时聊天，群聊等功能。 Redis多数据库名称 简介 Redis下，数据库是由一个整数索引标识，而不是由一个数据库名称。默认情况下，一个客户端连接到数据库0。 Redis配置文件中下面的参数来控制数据库总数。database 16(从0开始,1,2,3...15) 命令 select 数据库：数据库切换。 move key名称 数据库：将当前key移动另一库。 flushdb：清除当前数据库所有的key。 flushall：清除整个Redis的数据库所有key。 Redis事务 简介 Redis 事务可以一次执行多个命令， 并且带有以下三个重要的保证： 批量操作在发送 EXEC 命令前被放入队列缓存。 收到 EXEC 命令后进入事务执行，事务中任意命令执行失败，其余的命令依然被执行。. 在事务执行过程，其他客户端提交的命令请求不会插入到事务执行命令序列中。 一个事务从开始到执行会经历以下三个阶段： 开始事务 命令入队 执行事务 Redis脚本 简介： Redis脚本使用Lua解释器来执行脚本。Redis2.6版本通过内嵌支持Lua环境。执行脚本的命令为EVAL。 命令 Redis连接 redis连接命令主要用于连接redis服务 Redis连接命令 AUTH password：检验密码是否正确 ECHO message：打印字符串。 PING：查看服务是否运行。 QUIT：关闭当前连接。 SELECT index：切换到指定的数据库。 Redis持久化 简介 数据存放于： 内存：高效、断电内存会丢失。 硬盘：读写速度慢于内存，断电数据不会丢失。 持久化方案 RDB AOF Redis缓存与数据库一致性 解决方案 实现同步 异步队列 主从复制 采用UDF自定义函数的方式(触发器) Lua实现 定时更新 缓存穿透 缓存雪崩 缓存击穿 Redis高级 高可用（一致都能用）0：通常描述一个系统经过专门的设计，从而减少停工时间，而保持其服务的高度可用性。 该并发：高并发式是互联网分布式系统架构设计中必须考虑的因素之一，他通常是指，通过设计保证系统能够同时并行处理很多请求。 高并发相关常用的一些指标有响应时间，吞吐量，每秒查询率（QPS）,并发用户数等。 响应时间：系统对请求做出响应的时间。例如系统处理一个HTTP请求需要200ms，这个200ms就是系统的响应时间。 吞吐量：单位时间内处理的请求数量。 QPS：每秒响应请求数。在互联网领域中，这个指标和吞吐量区分的没有这么明显。 并发用户数：同时承载正常使用系统功能的用户数量。 提升系统的并发能力 垂直扩展 水平扩展 Redis主从复制 应用场景:多读少写 Redis Cluster集群 简介： 为什么使用redis-cluster？ 为了大流量访问下提供稳定的业务，集群化是存储的必然形态。 未来的发展趋势肯定是云计算和大数据紧密结合。 只有分布式架构满足需求。 Redis集群的搭建方案 Twitter开发的twemproxy 豌豆荚开发的codis redis官方的redis-cluster redis-cluster特点 redis cluster容错性 Redis Cluster集群搭建 简介： 集群中至少应该有奇数个节点，所以搭建集群最少需要3台主机(master)。同时每个节点至少有一个备份节点（slaver），所以下面最少需要6台机器，才能完成Redis-Cluster集群（主节点，备节点由redis-cluster集群确定） 真集群：准备6台机器 假集群：一台服务器存在6个redis服务。 搭建流程 创建Redis节点安装目录，mkdir /usr/local/redis_cluster //指定目录下 创建redis_cluster 在redis_cluster目录下，创建7001-7006个文件夹下，mkdir 7001 7002 7003 7004 7005 7006 并将redis-conf分别拷贝到7001-7006文件夹下：cp /root/redis-4.0.1/redis.conf ./7001 分别修改如下配置文件，修改如下内容： 同时protected-mode是为了禁止公网访问redis cache，加强了redis的安全性。 没有bind IP 没有设置访问密码 由于Linux上的redis处于安全保护模式，这就让你无法从虚拟机外部去轻松建立连接。 如果外部访问：redis.conf中设置保护模式：protected-mode yes bind 127.0.0.1// 注释掉 port 7000 //绑定端口，必须修改，以此来区分Redis实例 daemonize yes//后台运行 pidfile /var/run/redis-7001.pid//修改pid进行文件名，以端口号命名 cluster-enabled yes//启用集群 cluster-config-file nodes-7000.conf //配置每个节点的配置文件，同样以端口为名称 cluster-node-timeout 15000 //配置集群的超时时间，可改可不改 appendonly yes://启动AOF增量持久化策略 appendfsync always//发生改变就记录日志 把redis/src/的文件拷贝到7001-7006目录下 cp -r ./src /usr/local/redis_cluster/7001 分别启动redis-server 创建集群 Redis官方提供了redis-trib.rb这个工具，就在解压目录下的src目录中（为了方便操作），将其文件复制到/usr//local/bin目录下，可直接访问此命令:cd redis-4.0.1/、cd src、cp redis-trib.rb /usr/local/bin/ 可以直接在命令中执行：ip:port格式redis-trib.rb create --replicas 1 127.0.0.1:7001 ... 如果出现下面此错误：则需要安装ruby，这个工具是用ruby实现的。 安装ruby yum -y install ruby ruby-devel rubygems rpm-build gem install redis 如下错误原因，centos默认支持ruby到2.0.0，可gem安装redis需要最低是2.2.2 解决办法是：先安装rvm，再把ruby升级 安装rvm （出现错误时查看以下一个点） gpg --keyserver hkp://keys.gnupg.net --recv-keys 409B6B1796C275462A1703113804BB82D39DC0E3 curl -sSL https://get.rvm.io | bash -s stable find / -name rvm -print source /usr/local/rvm/scripts/rvm rvm list known//查看rvm库中已知的ruby版本。 安装一个ruby版本 rvm install 2.4.4 rvm use 2.4.4//使用一个ruby版本 rvm use 2.4.4 --default//设置默认版本 ruby --version//查看ruby版本 gem install redis//安装redis 重新执行redis-trib.rb create --replicas 1 127.0.0.1:7001 ...创建集群，结果如下： 最终结果 创建成功。 Linux CentOS下通过ruby搭建redis集群 通过下载安装包 ruby-2.3.1.tar.gz redis-3.3.0.gem 通过wget命令 wget https://cache.ruby-lang.org/pub/ruby/2.3/ruby-2.3.1.tar.gz wget http://rubygems.org/downloads/redis-3.3.0.gem 1跟2都会先出现 zlib包不存在以及openssl不存在的问题，zlib可以通过如下方式解决 yum -y install zlib-devel 进入ruby源码文件夹,安装ruby自身提供的zlib包 cd ruby-2.3.1/ext/zlib ruby ./extconf.rb make make install 通过yum install 默认安装的ruby版本低于2.2，无法创建redis集群，可以安装了之后再通过rvm工具升级，还不如直接使用rvm 通过ruby的版本管理工具rvm 4.1:curl -L get.rvm.io | bash -s stable yum install -y crul（如果发现curl没有安装，则执行这个之后再执行4.1） 如果遇到CURLE_SSL_CONNECT_ERROR return status(35)的错误，执行yum -y update nss，再重新执行4.1 此时打印信息 通过以上信息，需要try to install GPG v2再 fetch the public key 因此执行 command curl -sSL https://rvm.io/mpapis.asc | gpg2 --import - 再执行 4.1 find / -name rvm -print source /usr/local/rvm/scripts/rvm rvm list known Redis cluster集群验证 Redis集群测试 为方便测试，可将redis-cli客户端命令放到/usr/local/bin目录下 cd /root/redis-4.0.14/src //进入该目录 cp redis-cli /usr/local/bin 在某台机器上（或）连接集群的7001端口的节点上： redis-cli -h 127.0.0.1 -c -p 7001 查看集群信息 info replication 查看主从关系 输入命令 cluster nodes 主从复制：主做增删改，从做查询功能 外部使用(针对centos6) 开启端口权限，依次开放端口7001 7002…7006 vi /etc/sysconfig/iptables 重启防火墙 service iptables restart","categories":[{"name":"back-end","slug":"back-end","permalink":"https://CPWS.github.io/categories/back-end/"}],"tags":[{"name":"redis","slug":"redis","permalink":"https://CPWS.github.io/tags/redis/"}]},{"title":"数据库系统概述","slug":"数据库系统概述","date":"2019-11-17T11:50:32.000Z","updated":"2019-12-05T08:57:00.081Z","comments":true,"path":"2019/11/17/数据库系统概述/","link":"","permalink":"https://CPWS.github.io/2019/11/17/数据库系统概述/","excerpt":"","text":"第一章 绪论数据库系统概述 数据库地位 数据库是管理数据的最新技术。 数据库技术是信息系统的核心和基础。 四个基本概念 数据(data) 数据是数据库中存储的基本对象 数据的定义：描述事物的符号记录成为数据。 数据的语义：数据的含义成为数据的语义，数据与其语义是不可分的。 记录是计算机中表示和存储数据的一种格式或一种方法。 数据库(DataBase，DB) 数据库，顾名思义，就是存储数据的仓库。只不过这个仓库是在计算机存储设备上，而且数据是按照一定的的格式存放的。 数据库的定义：数据库是长期存储在计算机中的、有组织的、可共享的大量的数据的集合。 数据库中的数据按照一定的额数据模型组织，描述和存储，具有较小的冗余度，较高的数据独立性和易扩展性，并可为多用户共享。 概括的讲，数据库数据具有永久存储、有组织和可共享三个基本特点。 数据库管理系统(DataBase Management System，DBMS) 了解了数据和数据库的基本概念，下一个问题就是如何科学的组织和存储数据，如何高效的获取和恢复数据。完成这个任务的是一个软件–数据库管理系统。 数据库管理系统是位于用户与操作系统之间的一层数据管理软件。数据库管理系统与操作系统一样是计算机的基础软件，也是一个大型复杂的软件系统。 数据库管理的功能:数据定义功能(DDL)、数据组织，存储和管理、数据库的操纵功能、数据库的事务管理和运行管理、数据库的建立和维护功能、其他功能。 数据库系统(DataBase System,DBS) 数据库系统是由数据库、数据库管理系统、应用程序和数据库管理员(DataBase Administrator,DBA)组成的存储、管理、处理和维护数据的系统。 其中，数据库提供数据的存储功能，数据库管理系统提供数据的组织、存取、管理和维护等基础功能，数据库应用系统根据应用需求使用数据库，数据库管理员负责全面管理数据库系统。 在一般不引起混杂的情况下，人们常常把数据库系统简称数据库。 数据库管理技术的产生和发展 数据库技术是应数据管理任务的需要而产生的。 数据管理：数据管理是指对数据进行分类、组织、编码、存储、检索和维护，它是数据处理的中心问题。 数据处理：数据处理是指对各种数据进行收集、存储、加工和传播的一系列的活动的总和。 在应用需求的推动下，在计算机硬件、软件基础上，数据管理技术经历了人工管理、文件系统、数据库技术三个阶段。这三个阶段的特点如下表所示： 人工管理阶段 20世纪50年代中期以前，计算机主要用于科学计算。当时的硬件条件是，外存只有纸带、卡片和磁带、没有磁盘等直接存储的设备；软件条件是，没有操作系统，没有管理数据的专门软件;数据处理方式是批处理。 人工管理数据具有如下特点: 数据不保存 应用程序管理数据 数据不共享 数据不具备独立性","categories":[{"name":"back-end","slug":"back-end","permalink":"https://CPWS.github.io/categories/back-end/"}],"tags":[{"name":"数据库系统概述","slug":"数据库系统概述","permalink":"https://CPWS.github.io/tags/数据库系统概述/"}]},{"title":"HttpClient","slug":"HttpClient","date":"2019-11-16T08:24:20.000Z","updated":"2019-12-05T08:59:33.804Z","comments":true,"path":"2019/11/16/HttpClient/","link":"","permalink":"https://CPWS.github.io/2019/11/16/HttpClient/","excerpt":"","text":"HttpCLient使用步骤模拟浏览器调用服务层请求数据. Get请求 实现步骤 第一步：把HttpClient使用的jar包添加到工程中。 第二步：创建一个HttpClient的测试类 第三步：创建测试方法。 第四步：创建一个HttpClient对象 第五步：创建一个HttpGet对象，需要制定一个请求的url 第六步：执行请求。 第七步：接收返回结果。HttpEntity对象。 第八步：取响应的内容。 第九步：关闭HttpGet、HttpClient。 测试代码 1234567891011121314151617181920@Testpublic void testHttpGet() throws Exception &#123; // 第一步：把HttpClient使用的jar包添加到工程中。 // 第二步：创建一个HttpClient的测试类 // 第三步：创建测试方法。 // 第四步：创建一个HttpClient对象 CloseableHttpClient httpClient = HttpClients.createDefault(); // 第五步：创建一个HttpGet对象，需要制定一个请求的url HttpGet get = new HttpGet(\"http://www.itheima.com\"); // 第六步：执行请求。 CloseableHttpResponse response = httpClient.execute(get); // 第七步：接收返回结果。HttpEntity对象。 HttpEntity entity = response.getEntity(); // 第八步：取响应的内容。 String html = EntityUtils.toString(entity); System.out.println(html); // 第九步：关闭response、HttpClient。 response.close(); httpClient.close();&#125; Post请求 实现步骤 第一步：创建一个httpClient对象 第二步：创建一个HttpPost对象。需要指定一个url 第三步：创建一个list模拟表单，list中每个元素是一个NameValuePair对象 第四步：需要把表单包装到Entity对象中。StringEntity 第五步：执行请求。 第六步：接收返回结果 第七步：关闭流。 测试代码123456789101112131415161718192021222324@Testpublic void testHttpPost() throws Exception &#123; // 第一步：创建一个httpClient对象 CloseableHttpClient httpClient = HttpClients.createDefault(); // 第二步：创建一个HttpPost对象。需要指定一个url HttpPost post = new HttpPost(\"http://localhost:8082/posttest.html\"); // 第三步：创建一个list模拟表单，list中每个元素是一个NameValuePair对象 List&lt;NameValuePair&gt; formList = new ArrayList&lt;&gt;(); formList.add(new BasicNameValuePair(\"name\", \"张三\")); formList.add(new BasicNameValuePair(\"pass\", \"1243\")); // 第四步：需要把表单包装到Entity对象中。StringEntity StringEntity entity = new UrlEncodedFormEntity(formList, \"utf-8\"); post.setEntity(entity); // 第五步：执行请求。 CloseableHttpResponse response = httpClient.execute(post); // 第六步：接收返回结果 HttpEntity httpEntity = response.getEntity(); String result = EntityUtils.toString(httpEntity); System.out.println(result); // 第七步：关闭流。 response.close(); httpClient.close();&#125;","categories":[{"name":"back-end","slug":"back-end","permalink":"https://CPWS.github.io/categories/back-end/"}],"tags":[{"name":"HttpClient","slug":"HttpClient","permalink":"https://CPWS.github.io/tags/HttpClient/"}]},{"title":"Java框架下载路径","slug":"Java框架下载路径","date":"2019-11-01T11:50:29.000Z","updated":"2019-12-05T08:59:49.398Z","comments":true,"path":"2019/11/01/Java框架下载路径/","link":"","permalink":"https://CPWS.github.io/2019/11/01/Java框架下载路径/","excerpt":"","text":"Struts框架下载路径 https://struts.apache.org/download.cgi#struts2520 学习视频：https://www.bilibili.com/video/av31846422/Hibernate框架下载路径 http://hibernate.org/orm/releases/ 学习视频：https://www.bilibili.com/video/av31842997/Mybatis框架下载路径 https://github.com/mybatis/mybatis-3/releasesSpring与Mybatis整合的jar包https://blog.csdn.net/qiangqiang816/article/details/81541188Spring框架下载路径 https://repo.spring.io/release/org/springframework/spring/SpringMVC框架下载路径 https://repo.spring.io/release/org/springframework/spring/ SSM学习视频：https://www.bilibili.com/video/av41334365/maven仓库路径 https://mvnrepository.com/Commons-io,Commons-fileupload http://commons.apache.org/proper/commons-io/ http://commons.apache.org/proper/commons-fileupload/ redis安装 官方网站：http://redis.io 开发工具连接 https://pan.baidu.com/s/1A9VWHJMzow_zD0Pkp0d7jw H97F项目实战 917-web学生校园在线点餐系统源码ssm实现java+mysql项目源代码 https://pan.baidu.com/s/1mt9pDdOjoqTty-x-Dqm-FA 提取码：rd37 smm项目链接：https://pan.baidu.com/s/185P0EwiVzr5M_d182PPmkA 提取码：pvjc springmvc+Mybatis链接：https://pan.baidu.com/s/1CYIpdJhHzZjlSOOHBuak1g 提取码：4gp2 lucene+solr lucene+solr视频教程（四套）： https://pan.baidu.com/s/10so9BJhlNj_bbRX7IBO2Pw：提取码: 74ew elasticsearch elasticsearch教程（三套）： 链接：https://pan.baidu.com/s/1t0VLlWaZxLM5SHlnqVl15g:提取码：q4fg","categories":[{"name":"back-end","slug":"back-end","permalink":"https://CPWS.github.io/categories/back-end/"}],"tags":[{"name":"Java框架下载路径","slug":"Java框架下载路径","permalink":"https://CPWS.github.io/tags/Java框架下载路径/"}]},{"title":"SSM框架整合-配置文件","slug":"SSM框架整合-配置文件","date":"2019-11-01T11:49:43.000Z","updated":"2019-12-05T09:02:06.880Z","comments":true,"path":"2019/11/01/SSM框架整合-配置文件/","link":"","permalink":"https://CPWS.github.io/2019/11/01/SSM框架整合-配置文件/","excerpt":"","text":"Web.xml配置文件12345678910111213141516171819202122232425262728293031323334353637&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://java.sun.com/xml/ns/javaee\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd\" version=\"3.0\"&gt; &lt;!-- 配置上下文参数 --&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- SpringMVC前端控制器 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!-- 字符编码过滤器 --&gt; &lt;filter&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt; Spring框架的常用配置12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd\" default-autowire=\"byName\"&gt; &lt;!-- 扫描注解 --&gt; &lt;context:component-scan base-package=\"com.gdaib.service.impl\"&gt;&lt;/context:component-scan&gt; &lt;!-- 加载属性文件 --&gt; &lt;context:property-placeholder location=\"classpath:db.properties\"/&gt; &lt;!-- 数据源 --&gt; &lt;bean id=\"dataSource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\"&gt; &lt;property name=\"driverClassName\" value=\"$&#123;jdbc.driver&#125;\"&gt;&lt;/property&gt; &lt;property name=\"url\" value=\"$&#123;jdbc.url&#125;\"&gt;&lt;/property&gt; &lt;property name=\"username\" value=\"$&#123;jdbc.username&#125;\"&gt;&lt;/property&gt; &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- SqlSessionFactory --&gt; &lt;bean id=\"factory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt; &lt;property name=\"typeAliasesPackage\" value=\"com.gdaib.pojo\" &gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 扫描器 --&gt; &lt;bean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\"&gt; &lt;property name=\"basePackage\" value=\"com.gdaib.mapper\"&gt;&lt;/property&gt; &lt;property name=\"sqlSessionFactoryBeanName\" value=\"factory\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 事务管理器 --&gt; &lt;bean id=\"txManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 声明式事务 --&gt; &lt;tx:advice id=\"txAdvice\" transaction-manager=\"txManager\"&gt; &lt;tx:attributes&gt; &lt;tx:method name=\"ins*\"/&gt; &lt;tx:method name=\"del*\"/&gt; &lt;tx:method name=\"upd*\"/&gt; &lt;tx:method name=\"*\" read-only=\"true\"/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!-- 配置AOP --&gt; &lt;aop:config&gt; &lt;aop:pointcut expression=\"execution(* com.gdaib.service.impl.*.*(..))\" id=\"mypoint\"/&gt; &lt;aop:advisor advice-ref=\"txAdvice\" pointcut-ref=\"mypoint\"/&gt; &lt;/aop:config&gt;&lt;/beans&gt; SpringMVC的常用配置12345678910111213141516171819202122232425&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd\"&gt; &lt;!-- 扫描注解 --&gt; &lt;context:component-scan base-package=\"com.gdaib.controller\"&gt;&lt;/context:component-scan&gt; &lt;!-- 注解确定， 注册HandlerMapping和HandlerAdapter--&gt; &lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt; &lt;!-- 设置静态 --&gt; &lt;mvc:resources location=\"/js/\" mapping=\"/js/**\"&gt;&lt;/mvc:resources&gt; &lt;mvc:resources location=\"/css/\" mapping=\"/css/**\"&gt;&lt;/mvc:resources&gt; &lt;mvc:resources location=\"/images/\" mapping=\"/images/**\"&gt;&lt;/mvc:resources&gt; &lt;!-- 视图解析器 --&gt; &lt;bean id=\"viewResource\" class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;property name=\"prefix\" value=\"/\"&gt;&lt;/property&gt; &lt;property name=\"suffix\" value=\"*.jsp\"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 资源文件常用配置1234jdbc.driver=com.mysql.cj.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/ssm?serverTimezone=UTC&amp;characterEncoding=utf8jdbc.password=123456jdbc.username=root","categories":[{"name":"back-end","slug":"back-end","permalink":"https://CPWS.github.io/categories/back-end/"}],"tags":[{"name":"SSM框架整合-配置文件","slug":"SSM框架整合-配置文件","permalink":"https://CPWS.github.io/tags/SSM框架整合-配置文件/"}]},{"title":"maven","slug":"maven","date":"2019-10-31T10:59:50.000Z","updated":"2019-12-05T09:00:48.613Z","comments":true,"path":"2019/10/31/maven/","link":"","permalink":"https://CPWS.github.io/2019/10/31/maven/","excerpt":"","text":"搭建maven项目时setting.xml的设置 镜像包添加 123456789&lt;mirrors&gt; &lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt;&lt;/mirrors&gt; 本地仓库配置： 1&lt;localRepository&gt;&lt;localRepository/&gt; JDK版本的配置 123456789101112&lt;profile&gt; &lt;id&gt;jdk-1.8&lt;/id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;jdk&gt;1.8&lt;/jdk&gt; &lt;/activation&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;maven.compiler.compilerVersion&gt;1.8&lt;/maven.compiler.compilerVersion&gt; &lt;/properties&gt; &lt;/profile&gt; Tomcat的配置 12345678910111213&lt;plugin&gt; &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt; &lt;artifactId&gt;tomcat-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.1&lt;/version&gt; &lt;configuration&gt; &lt;path&gt;/&lt;/path&gt; &lt;port&gt;8080&lt;/port&gt; &lt;uriEncoding&gt;UTF-8&lt;/uriEncoding&gt; &lt;url&gt;http://localhost:8080/manager/html&lt;/url&gt; &lt;server&gt;tomcat6&lt;/server&gt; &lt;/configuration&gt;&lt;/plugin&gt;","categories":[{"name":"back-end","slug":"back-end","permalink":"https://CPWS.github.io/categories/back-end/"}],"tags":[{"name":"maven","slug":"maven","permalink":"https://CPWS.github.io/tags/maven/"}]},{"title":"springmvc","slug":"springmvc","date":"2019-10-31T10:59:40.000Z","updated":"2019-12-05T09:01:42.609Z","comments":true,"path":"2019/10/31/springmvc/","link":"","permalink":"https://CPWS.github.io/2019/10/31/springmvc/","excerpt":"","text":"SpringMVC简介 SpringMVC中重要组件： DispatcherServlet：前端控制器，接收所有请求（如果配置/则不包含jsp） HandlerMapping：解析请求格式，判断希望要执行哪个具体的方法。 HandlerAdapter：负责调用具体的方法。 ViewResolver：视图解析器。解析结果，准备跳转到具体的物理视图。 SpringMVC运行原理图。 Spring容器和Springmvc容器的关系 代码 Spring容器和Springmvc容器的关系是父子容器 Springmvc容器中能够调用Spring容器的所有内容 图示 SpringMVC环境搭建 导入jar包 在web.xml中配置前端控制器:DispatcherServlet 如果不配置&lt;init-param&gt;，则会在/WEB-INF/找配置文件 123456789101112131415161718&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://java.sun.com/xml/ns/javaee\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd\" version=\"3.0\"&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 修改配置文件路径和名称 --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 自启动 --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 新建Springmvc.xml配置文件，引入xmlns:mvc属性命名空间。 123456789101112131415161718192021&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd\"&gt; &lt;!-- 注解扫描器 --&gt; &lt;context:component-scan base-package=\"com.gdaib.controller\"&gt;&lt;/context:component-scan&gt; &lt;!-- 配置注解驱动 --&gt;&lt;!-- 相当于配置如下两个属性 --&gt; &lt;!-- org.springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMapping --&gt; &lt;!-- org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter --&gt; &lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt; &lt;!-- 静态资源 --&gt; &lt;!-- 第一个参数：不拦截某个目录，第二个参数访问的路径,**代表该目录下的所有文件 --&gt; &lt;mvc:resources location=\"/js/\" mapping=\"/js/**\"&gt;&lt;/mvc:resources&gt;&lt;/beans&gt; 编写控制器类 123456789101112131415161718package com.gdaib.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;@Controllerpublic class DemoController &#123; @RequestMapping(\"demo\") public String demo() &#123; System.out.println(\"执行demo\"); return \"main.jsp\"; &#125; @RequestMapping(\"demo2\") public String demo2() &#123; System.out.println(\"指定demo2\"); return \"main.jsp\"; &#125;&#125; 字符编码过滤器 在web.xml中配置Filter12345678910111213&lt;!-- 解决中文乱码 --&gt;&lt;filter&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 传参 把内容写到方法（HandlerMethod）参数中， SpringMVC中只要有这个内容，注入内容 基本数据类型参数，默认保证参数名称和参数名称一样 123456@RequestMapping(\"demo\")public String demo(String name,int age) &#123; System.out.println(\"执行demo\"); System.out.println(name + \"|\" + age); return \"main.jsp\";&#125; 如果请求名和参数名不对应应使用@RequestParam()赋值 123456@RequestMapping(\"demo\")public String demo(@RequestParam(value=\"name\")String name,@RequestParam(value=\"age\")int age) &#123; System.out.println(\"执行demo\"); System.out.println(name + \"|\" + age); return \"main.jsp\";&#125; 如果方法参数是基本数据类型（不是封装类），可以为其设置默认值 123456//如果参数为空时，为他们设置默认值@RequestMapping(\"page\")public String page(@RequestParam(defaultValue = \"2\")int pageSize,@RequestParam(defaultValue = \"1\")int pageNumber) &#123; System.out.println(pageSize+\" \"+pageNumber); return \"main.jsp\";&#125; 如果强制要求必须有某个参数 12345@RequestMapping(\"demo2\")public String demo2(@RequestParam(required = true)String name) &#123; System.out.println(\"必须传递name参数：\"+name); return \"main.js\";&#125; HandlerMethod中参数是对象类型，请求参数名和对象中属性一致（get/set） 1234@RequestMapping(\"demo4\")public String demo4(People peo) &#123; return \"main.js\";&#125; 请求参数中包含多个同名参数的获取方法 复选框传递的参数就是多个同名参数 12345@RequestMapping(\"demo5\")public String demo5(String name,int age,@RequestParam(\"hover\")List&lt;String&gt; hover) &#123; System.out.println(name + \" \"+age+\" \"+hover); return \"main.jsp\";&#125; 请求参数中对象.属性格式 JSP代码 12&lt;input type=\"text\" name=\"peo.name\"/&gt;&lt;input type=\"text\" name=\"peo.age\"/&gt; 新建一个类 1234567891011121314151617public class Demo &#123; private People peo; public People getPeo() &#123; return peo; &#125; public void setPeo(People peo) &#123; this.peo = peo; &#125; @Override public String toString() &#123; return \"Demo [peo=\" + peo + \"]\"; &#125; &#125; 控制器 12345@RequestMapping(\"demo06\")public String demo6(Demo demo) &#123; System.out.println(demo); return \"main.jsp\";&#125; 在请求参数中传递集合对象类型对象 JSP页面 1234&lt;input type=\"text\" name=\"peo[0].name\"/&gt;&lt;input type=\"text\" name=\"peo[0].age\"/&gt;&lt;input type=\"text\" name=\"peo[1].name\"/&gt;&lt;input type=\"text\" name=\"peo[1].age\"/&gt; 新建一个类 12345678910111213141516public class Demo &#123; private List&lt;People&gt; peo; public List&lt;People&gt; getPeo() &#123; return peo; &#125; public void setPeo(List&lt;People&gt; peo) &#123; this.peo = peo; &#125; @Override public String toString() &#123; return \"Demo [peo=\" + peo + \"]\"; &#125;&#125; 控制器类 12345@RequestMapping(\"demo06\")public String demo6(Demo demo) &#123; System.out.println(demo); return \"main.jsp\";&#125; restful风格 简化jsp中参数编写格式 在JSP中设定特定的格式 1&lt;a href=\"demo08/1232/abcd\"&gt;跳转&lt;/a&gt; 在控制器中 在@RequestMapping中一定要和请求格式对应 {名称}中名称自定义 @PathVariable获取@RequestMapping中内容，默认按照方法参数名称去寻找。 123456//restful@RequestMapping(\"demo08/&#123;id1&#125;/&#123;name1&#125;\")public String demo8(@PathVariable(\"id1\") int id,@PathVariable(value = \"name1\")String name) &#123; System.out.println(id+\" \"+name); return \"/main.jsp\";&#125; 跳转方式 默认的跳转方式：请求转发。 设置返回字符串的内容 添加 redirect:资源路径 ————&gt; 重定向 添加 forward:资源路径/省略 ————&gt; 转发 视图解析器 Springmvc会提供默认解析器 程序员自定义解析器 12345&lt;!-- 配置视图解析器 --&gt;&lt;bean id=\"\" class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;property name=\"prefix\" value=\"/\"&gt;&lt;/property&gt; &lt;property name=\"suffix\" value=\".jsp\"&gt;&lt;/property&gt;&lt;/bean&gt; 如果希望不执行自定义解析器，在方法返回值前面添加forward或者redirect 12345@RequestMapping(\"demo07\")public String demo7(int id,String name) &#123; System.out.println(id+\" \"+name); return \"forward:main.jsp\";&#125; @ResponseBody 在方法上只有@RequestMapping时，无论方法返回值是什么都认为需要跳转。 在方法上添加@ResponseBody 如果返回值满足key-value形式（对象或map） 把相应响应头设置为application/json;charset=utf-8 把转换后的内容以输出流的形式响应给客户端。 如果返回值不满足key-value，例如返回值为String 把响应头设置为text/html 把方法返回值以流的形式输出。 如果返回值包含中文，出现中文乱码 produces表示响应头中Content-Type值 SSM三大框架整合 JSP九大内置对象和四大作用域 九大内置对象 名称 类型 含义 获取方式 request HttpServletRequest 封装所有请求信息 方法参数 response HttpServletResponse 封装所有响应信息 方法参数 session HttpSession 封装所有会话信息 req.getSession() application ServletContext 所有信息 getServletContext()req.getServletContext() out PrintWriter 输出对象 response.getWriter() exception Exception 异常对象 … page Object 当前页面对象 … pageContext PageContext 获取其他对象 config ServletConfig 配置信息 … 四大作用域 page：在当前页面不会重新实例化. request：在一次请求中同一个对象，下次请求重新实例化一个request对象。 session：一次会话；只要客户端Cookie传递的Jsessionid不变，Session不会重新实例化（不超过默认时间） 实际有效时间：浏览器关闭；cookie失效 application：只要toncat启动时才实例化，关闭时销毁该对象。 SpringMVC作用域传值的几种方式 使用原生Servlet:在HandlerMethod方法参数中添加作用域. 12345678910@Controllerpublic class DemoController &#123; @RequestMapping(\"demo\") public String demo1(HttpServletRequest req,HttpSession session) &#123; req.setAttribute(\"req\", \"req的值\"); session.setAttribute(\"session\",\"session的值\"); req.getServletContext().setAttribute(\"application\", \"application的值\"); return \"/main.jsp\"; &#125;&#125; 使用Map集合 把map中内容放在request作用域中 Spring会把map集合通过BindingAwareModelMap进行实例 12345@RequestMapping(\"demo02\")public String demo2(Map&lt;String,Object&gt; map) &#123; map.put(\"map\", \"map的值\"); return \"/main.jsp\"; &#125; 使用SpringMVC中Model接口 把内容放入到request作用域中. 12345@RequestMapping(\"demo03\")public String demo3(Model model) &#123; model.addAttribute(\"map\", \"map的值\"); return \"/main.jsp\"; &#125; 使用SpringMVC中的ModelAndView 1234567@RequestMapping(\"demo04\")public ModelAndView demo4() &#123; //参数，跳转视图 ModelAndView mav=new ModelAndView(\"/main.jsp\"); mav.addObject(\"mav\",\"mav的值\"); return mav;&#125; 文件下载 访问资源时响应头如果没有设置Content-Disposition，浏览器默认按照inline值进行处理 inline：能显示就显示，不能显示就下载。 只需要修改响应头中Content-Disposition=&quot;attachment;filename=文件名&quot; attachment 下载：以附件形式下载。 filename=值就是下载时显示的下载文件名。 实现步骤： 导入apache的两个jar包。commoms-io.jar，commons-fileupload.jar 在jsp页面中添加下载路径，设置要下载文件。 编写控制器类。Content-Disposition 文件上传 基于apache的commons.fileupload.jar完成文件上传。 MultiPartResolver作用： 把客户端上传的文件转换成MultiPartFile封装类 通过MultiFile封装类获取文件类。 表单数据类型分类 在&lt;form&gt;的enctype属性控制表单类型 默认值application/x-www-form-urlencoded，普通表单数据。（少量文件信息） text/plain:大文字量时使用的类型，邮件，论文 multipart/form-data ：表单文件内容为二进制流。 实现步骤： 导入SpringMVC和Commons-fileupload、Commons-io几个jar 编写JSP页面 12345&lt;form action=\"upload\" enctype=\"multipart/form-data\" method=\"post\"&gt; 姓名：&lt;input type=\"text\" name=\"name\"/&gt;&lt;br&gt; 文件：&lt;input type=\"file\" name=\"file\"/&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"提交\"&gt;&lt;/form&gt; 写配置文件 12345678910&lt;!-- MultipartResolver解析器 --&gt;&lt;bean id=\"multipartResolver\" class=\"org.springframework.web.multipart.commons.CommonsMultipartResolver\"&gt;&lt;/bean&gt;&lt;!-- 异常时跳转到特定页面 --&gt;&lt;bean id=\"exceptionResolver\" class=\"org.springframework.web.servlet.handler.SimpleMappingExceptionResolver\"&gt;&lt;property name=\"exceptionMappings\"&gt; &lt;props&gt; &lt;prop key=\"异常类型\"&gt;/error.jsp&lt;/prop&gt; &lt;/props&gt;&lt;/property&gt;&lt;/bean&gt; 编写控制器类 123456789@RequestMapping(\"upload\")public String upload(MultipartFile file,String name) throws IOException &#123; System.out.println(name); String fileName=file.getOriginalFilename(); String suffix = fileName.substring(fileName.lastIndexOf(\".\")); String uuid = UUID.randomUUID().toString(); FileUtils.copyInputStreamToFile(file.getInputStream(), new File(\"D:/\"+uuid+suffix)); return \"/main.jsp\";&#125; 自定义拦截器 跟过滤器比较像的技术 发送请求时被拦截器拦截。在控制器的前后添加额外功能。 跟AOP区分开，AOP在特定方法前后扩充（对ServiceImpl） 拦截器，请求的拦截，针对点是控制器的方法（对Controller） SpringMVC 实现自定义拦截器的步骤 新建类实现HandlerInterceptor接口 1234567891011121314151617181920212223242526272829303132333435363738394041package com.gdaib.interceptor;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import org.springframework.web.servlet.HandlerInterceptor;import org.springframework.web.servlet.ModelAndView;public class DemoInterceptor implements HandlerInterceptor&#123; //记录在执行过程中出现的异常 //可以把异常记录到日志中 //jsp执行完成后执行 @Override public void afterCompletion(HttpServletRequest arg0, HttpServletResponse arg1, Object arg2, Exception arg3) throws Exception &#123; // TODO Auto-generated method stub System.out.println(\"afterCompletion\"); &#125; //控制器执行完成，进入到jsp页面之前执行 //日志记录功能 //敏感词语过滤 @Override public void postHandle(HttpServletRequest arg0, HttpServletResponse arg1, Object arg2, ModelAndView arg3) throws Exception &#123; // TODO Auto-generated method stub System.out.println(\"postHandle\"); &#125; //在进入控制器之前拦截 //如果返回false，阻止进入控制器 //控制代码 @Override public boolean preHandle(HttpServletRequest arg0, HttpServletResponse arg1, Object arg2) throws Exception &#123; // TODO Auto-generated method stub System.out.println(\"preHandler\"); return false; &#125; &#125; 在Springmvc配置文件中进行配置 12345678910 &lt;!-- 拦截器 --&gt;&lt;mvc:interceptors&gt; &lt;!-- 拦截所有 --&gt; &lt;bean class=\"com.gdaib.interceptor.DemoInterceptor\"&gt;&lt;/bean&gt; &lt;!-- 只拦截请求路径为demo1 --&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path=\"/demo1\"/&gt; &lt;bean class=\"com.gdaib.interceptor.DemoInterceptor\"&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt; 拦截器栈 多个拦截器同时生效时，组成了拦截器栈 先进后出 执行顺序和springmvc配置文件的配置顺序有关 设置先配置拦截器A，再配置拦截器B，执行顺序为： PreHandler(A) –&gt; PreHandler(B) –&gt; controller –&gt; PostHandler(B) –&gt; PostHandler(A) –&gt; afterCompletion(B) –&gt; afterCompletion(A) 登录验证 使用springmvc拦截器实现登录验证 把页面放入到web-inf中 放入到web-inf中后必须通过控制器转发到页面 springmvc拦截器拦截的是控制器，不能拦截jsp 通过拦截器拦截全部控制器，需要在拦截器内部放行login控制器 SpringMVC运行原理 文字解释 如果在web.xml中设置DispatcherServlet的&lt;url-pattern&gt;为\\时，当用户发起请求，请求一个控制器时，会执行DispatcherServlet。由DispatchServlet调用HandlerMapping。具体调用哪个实现类需要根据项目环境，如果使用注解方式调用DefaultAnnotationHandlerMapping解析URL，解析后调用HandlerAdapter组件的AnnotationMethodHandlerAdapter调用Controller中的HandlerMethod，当HandlerMethod执行完后会返回View,会被ViewResolver进行视图解析，解析后执行对应的jsp文件，最终把运行结果响应给客户端.","categories":[{"name":"back-end","slug":"back-end","permalink":"https://CPWS.github.io/categories/back-end/"}],"tags":[{"name":"springmvc","slug":"springmvc","permalink":"https://CPWS.github.io/tags/springmvc/"}]},{"title":"hibernate5","slug":"hibernate5","date":"2019-10-26T10:33:42.000Z","updated":"2019-12-05T08:59:38.715Z","comments":true,"path":"2019/10/26/hibernate5/","link":"","permalink":"https://CPWS.github.io/2019/10/26/hibernate5/","excerpt":"","text":"ORM和Hibernate对象/关系数据库映射（ORM） ORM可以称为面向对象编程语言和数据库之间的桥梁。 ORM：全称是：Object/Relation Mapping，即对象/关系数据库映射. 采用ORM框架之后，应用程序不再访问底层数据库，而是以面向对象的方法来操作持久化对象，而ORM框架则将这些面向对象的操作转换成底层的SQL操作。基本的映射方式 ORM基本映射有如下几条映射关系 数据表映射类 数据表的行映射对象（即实例） 数据表的列（字段）映射对象的属性 流行的ORM框架简介 目前流行的ORM框架有如下产品： JPA：JPA的最大优势在于它是官方标准，因此具有通用性。如果应用程序面向JPA编程，那么应用程序可以在各种ORM框架之间自由的切换：Hibernate?、TopLike?、OpenJPA?随你喜欢。 Hibernate：目前最流行的开源ORM框架，已经被选作JBoss持久层的解决方案。 Mybatis(Ibatis)：Apache软件基金的子项目。与其称它为一种ORM框架，不如称它是一种SQL Mapping框架。不支持纯粹的面向对象操作。对一些数据库访问灵活的地方,Mybatis更加灵活，它允许开发人员直接编写SQL语句。 TopLink：Oracle公司的产品。现在主要作为JPA实现。ClassFish服务器的JPA实现就是TopLink。 Hibernate概述 Hibernate能在众多的ORM框架中脱颖而出，因为Hibernate与其他框架相比有如下优势： 开源和免费的License，方便需要时研究源代码，改写源代码，进行功能限定。 轻量级封装，避免引入过多复杂的问题，调试容易，减轻程序员负担。 有可扩展性，API开放。功能不够用的时候，自己编码进行扩展。 开发者活跃，产品有稳定的发展保障。 Hibernate入门 hibernate的用法非常简单，只要在Java项目中导入Hibernate框架，就可以以面向对象的方式操作关系数据库。 hibernate的下载和安装 下载地址：www.hibernate.org、www.jboss.org 下载步骤： 登录http://hibernate.org/orm/站点，下载压缩包。 解压缩刚下载的压缩包。该文件夹下包含如下文件结构： documentation：该路径下存放Hibernate的相关文档，包括Hibernate的参考文档和API文档等。 lib：该路径下存放了Hibernate5.2的核心类库，以及编译和运行所以来的第三方类库。其中lib路径下的required子目录下保存了运行Hibernate5.2的核心类库，以及必须的第三方类库。 project：该路径下存放了Hibernate各种相关项目的源代码。 lgpl.txt、logo等杂项文件。 将解压缩路径中lib目录下的required子目录下的jar包添加到应以的类加载路径中–即可通过添加环境变量的方式来添加，也可以通过ant或IDE工具来管理应用程序的类加载路径。 如果直接在控制台编译使用了HibernateAPI类，则需要将Hibernate和兴JAR包以及必须的依赖jar包添加到CLASSPath路径中。如果是使用Ant或者Eclipse等IDE工具，则无需修改环境变量。 经过以上步骤，就可以在应用中使用Hibernate框架的功能了。 除此之外，hibernate的底层还是基于JDBC驱动的，所以在应用程序中使用Hibernate进行持久操作同样少不了JDBC驱动。如果底层是使用Mysql，则还需要将mysql的驱动包导入到classpath中。 Hibernate的数据库操作 前面已经介绍，在所有的ORM框架中还有一个重要的媒介：PO(持久化对象)。持久化对象的作用是完成持久化操作，简单的说，通过该对象可以对数据执行查询、修改、删除的操作–以面向对象的方式操作数据库。 Hibernate里的PO非常简单的，前面说过的Hibernate是低侵入性的设计，完全采用普通的Java对象作为持久化对象使用。看下面的pojo(普通的、传统的Java对象)类. 1234567891011121314151617181920212223242526272829package org.crazyit.app.domain;public class News &#123; //消息类的标识属性 private Integer id; //消息标题 private String title; //消息内容 private String content; //各属性的getter和setter方法 public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getTitle() &#123; return title; &#125; public void setTitle(String title) &#123; this.title = title; &#125; public String getContent() &#123; return content; &#125; public void setContent(String content) &#123; this.content = content; &#125; &#125; 照着上面定义好了之后，该类目前还不具备持久化操作的能力，为了使其具备持久化的能力，还要为其添加一些注解的。下面为News类增加注解。 12345678910111213141516171819202122232425262728293031323334353637383940package org.crazyit.app.domain;import javax.persistence.Entity;import javax.persistence.GeneratedValue;import javax.persistence.GenerationType;import javax.persistence.Id;import javax.persistence.Table;@Entity@Table(name = \"news_inf\")public class News &#123; //消息类的标识属性 @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Integer id; //消息标题 private String title; //消息内容 private String content; //各属性的getter和setter方法 public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getTitle() &#123; return title; &#125; public void setTitle(String title) &#123; this.title = title; &#125; public String getContent() &#123; return content; &#125; public void setContent(String content) &#123; this.content = content; &#125; &#125; 关于上面的注解的简单解释 @Entity:该注解声明该类是一个Hibernate的持久化类。 @Table：指定该类映射的表。此处指定该类映射到news_inf表。 @Id:用于指定该类的标识属性。所谓标识属性，就是可以唯一标识该对象的属性，标识属性通常映射到数据表的主键列。 @GeneratedValue用于指定主键的生成策略，其中strategy属性制定了主键的生成策略为IDENTITY策略，也就是采用自动增长的主键生成策略。 从上面的注解信息可以看出：PO = POJO + 持久化注解。 除了写完了PO之后，Hibernate还需要添加一些配置信息，例如使用那个数据库，使用那个JDBC操作，使用数据库的用户名和密码等，这些配置信息对所有的持久化类都是通用的。 Hibernate的配置信息既可以使用*.properties属性文件配置，也可以使用xml配置文件进行配置。 12345678910111213141516171819202122232425262728293031323334&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE hibernate-configuration PUBLIC \"-//Hibernate/Hibernate Configuration DTD 3.0//EN\" \"http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd\"&gt;&lt;hibernate-configuration&gt; &lt;session-factory&gt; &lt;!-- 指定两节数据库的相关信息 --&gt; &lt;property name=\"hibernate.connection.driver_class\"&gt;com.mysql.cj.jdbc.Driver&lt;/property&gt; &lt;property name=\"hibernate.connection.password\"&gt;123456&lt;/property&gt; &lt;property name=\"hibernate.connection.url\"&gt;jdbc:mysql://localhost:3306/hibernate?useSSL=true&amp;amp;characterEncoding=utf8&amp;amp;serverTimezone=UTC&lt;/property&gt; &lt;property name=\"hibernate.connection.username\"&gt;root&lt;/property&gt; &lt;!-- HIBERNATE的相关配置 --&gt; &lt;!-- 指定连接池最大的连接数 --&gt; &lt;property name=\"hibernate.c3p0.max_size\"&gt;20&lt;/property&gt; &lt;!-- 指定连接池最小的连接数 --&gt; &lt;property name=\"hibernate.c3p0.min_size\"&gt;1&lt;/property&gt; &lt;!-- 指定连接池里连接的超时时长 --&gt; &lt;property name=\"hibernate.c3p0.timeout\"&gt;5000&lt;/property&gt; &lt;!-- 指定连接池最大缓存多个多少个Statement对象 --&gt; &lt;property name=\"hibernate.c3p0.max_statements\"&gt;100&lt;/property&gt; &lt;property name=\"hibernate.c3p0.idle_test_period\"&gt;3000&lt;/property&gt; &lt;property name=\"hibernate.c3p0.acquire_increment\"&gt;2&lt;/property&gt; &lt;!-- 指定数据库方言 --&gt; &lt;property name=\"hibernate.dialect\"&gt;org.hibernate.dialect.MySQL5InnoDBDialect&lt;/property&gt; &lt;!-- 根据需要自动创建数据库表 --&gt; &lt;property name=\"hibernate.hbm2ddl.auto\"&gt;update&lt;/property&gt;&lt;!-- ① --&gt; &lt;!-- 显示Hibernate持久操作所生成的SQL --&gt; &lt;property name=\"show_sql\"&gt;true&lt;/property&gt; &lt;!-- 将SQL格式化后输出 --&gt; &lt;property name=\"format_sql\"&gt;true&lt;/property&gt; &lt;!-- 罗列所有持久化类的类名 --&gt; &lt;mapping class=\"org.crazyit.app.domain.News\"/&gt; &lt;/session-factory&gt;&lt;/hibernate-configuration&gt; Hibernate配置文件的默认文件名为hibernate.cfg.xml，当程序调用Configuration对象的configuration()方法时，Hibernate将自动加载该配置文件。 由于上面的程序需要使用C3p0数据库连接池，因为还需要将Options目录下的c3p0目录下的配置文件导入到系统的类加载器路径下。 上面配置文件①号粗体代码制定了hbm2ddl.auto属性，该属性指定是否需要Hibernate根据持久化类自动创建数据库表。属性值为true,表明Hibernate会根据持久类的映射关系来自动创建数据库表。 &lt;mapper../&gt;元素指定持久化类名。如果有多个持久化类名，只要在此处罗列多个&lt;mapper../&gt;元素即可。 测试代码，实现数据库添加 1234567891011121314151617181920212223242526272829303132333435package lee;import org.crazyit.app.domain.News;import org.hibernate.Session;import org.hibernate.SessionFactory;import org.hibernate.Transaction;import org.hibernate.cfg.Configuration;public class NewsManager &#123; public static void main(String[] args) &#123; /*** * 实例化Configuration * 不带参数的configuration()方法默认加载hibernate.cfg.xml文件 * 如果传入abc.xml作为参数，则不会加载hibernate.cfg.xml配置文件，只会加载abc.xml配置文件 */ Configuration cfg=new Configuration().configure(); //以Configuration为实例创建SqlSessionFactory SessionFactory sf = cfg.buildSessionFactory(); //创建session Session sess = sf.openSession(); //开启事务 Transaction tx = sess.beginTransaction(); //创建消息对象 News n=new News(); n.setTitle(\"疯狂Java联盟成立了\"); n.setContent(\"疯狂Java联盟成立了，网站地址：http://crazyit.org/\"); //保存信息 sess.save(n); //提交事务 tx.commit(); //关闭 sess.close(); sf.close(); &#125;&#125; 从以上也可以看出，这是完全面向对象化的操作方式。 运行结果 总结：为了使用Hibernate进行持久化操作，通常有如下操作步骤： 开发持久化类：POJO+持久化注解组成 获取Configuration对象 获取SessionFactory 获取Session，打开事务 用面向对象的方式操作数据库 关闭事务，关闭Session 随着PO与Session的关联关系，PO有如下三种状态： 瞬时：如果PO从未与Session发生关联，该POJO实例处于瞬时状态。 持久化：如果PO与Session关联起来，且该实例对应到数据库记录，则该实例处于持久化状态。 脱管：如果PO曾与Session关联过，但因为Session的关闭等原因，PO脱离了Session的管理，这种状态称为脱管状态。 对比Hibernate和JDBC两种操作数据库的方式，不难发现Hibernate有如下两个显著特征： 不需要编写SQL语句，而是允许采用OO方式来访问数据库。 在JDBC访问过程中大量的checked异常被包装成hibernate的Runtime异常,从而不再要求程序处理任何的异常。 在Eclipse中使用Hibernate 实现步骤如下： 首先创建一个Java Project,且命名为HibernateDemo01 右击项目创建一个lib文件夹，将Hibernate所依赖的第三方jar、Mysql驱动包、JAXB包、Activction包和C3P0存入到该目录下。 选中所有的jar，右击build path–&gt;add Path 操作完以上步骤之后，就可以按上面的步骤搭建Hibernate环境 注意Hibernate.cfg.xml文件通常存放在src目录下. Hibernate的体系结构 通过前面的介绍可以知道：Hibernate Session，只有处于Session管理下POJO才具有持久化的功能。 应用程序的数据访问层既可以通过JPA（Java Persistence API）执行ORM操作，也可以通过Hibernate原生API来操作ORM。JPA和Hibernate的关系就是ORM的规范与ORM规范的实现。JPA相当于ORM的规范,Hibernate相当于规范的实现。 深入Hibernate配置文件创建Configuration对象 随着hibernate所使用的配置文件的不同，创建Configuration对象的方式也不相同。通常有如下几种配置Hibernate的方式： 使用Hibernate.properties文件作为配置文件 使用Hibernate.cfg.xml文件作为配置文件 不使用任何配置文件，以编码的方式创建Configuration对象 Configuration实例的唯一作用就是创建SessionFactory实例。所有它被设计为启动期间对象，一旦SessionFactory创建完成，Configuration就被丢弃了。 使用hibernate.properties作为配置文件. 此处给出了使用hibernate.properties文件创建Configuration的方法 12//调用addAnnotatedClass()添加持久化类Configuration c=new Configuration().addAnnotatedClass(Item.class).addAnnotatedClass(Bid.class); 查看hibernate.properties配置文件发现，该文件没有提供添加Hibernate持久化类的方式。因此使用它作为配置文件时，必须调用addAnnotatedClass()或addpackage()方法，使用这些方法添加持久化类。 使用Hibernate.cfg.xml文件作为配置文件 因为在该配置文件中添加了持久化类，因此无需通过编程的方式添加持久化类。采用这种配置文件的方式创建Configuration实例可以通过如下的代码实现： 12//configure方法将负责加载hibernate.cfg.xml配置文件Configuration cfg=new Configuration().configure(); 不使用任何配置文件，以编码的方式创建Configuration对象 这是一种极端的方式，通常不会通过这种创建Configuration实例。Configuration提供了如下常用方法： Configuration addAnnotatedClass(Class annotatedClass)：用于为Configuration对象添加一个持久化类。 Configuration addPackage(String packageName)：用于为Configuration对象添加指定包下的所欲持久化类。 Configuration setProperties(Properties properties)：用于为Configuration添加一系列属性，这一些属性通过Properties实例传入。 Configuration setProperty(String propertyName,String value)：用于为Configuration对象设置一个单独的属性。 由于通过如上4个方法，可以无需使用任何配置文件，直接通过编程的方式创建Configuration实例。 1234567891011121314151617181920212223242526272829303132333435363738394041public class NewsManager &#123; public static void main(String[] args) &#123; //实例化Configuration，不需要加载任何的配置文件 Configuration cfg=new Configuration() //通过addAnnotatedClass()方法添加持久化类 .addAnnotatedClass(org.crazyit.app.domain.News.class) //通过setProperties设置连接属性 .setProperty(\"hibernate.connection.driver_class\",\"com.mysql.cj.jdbc.Driver\") .setProperty(\"hibernate.connection.url\",\"jdbc:mysql://localhost:3306/hibernate?useSSL=true&amp;amp;characterEncoding=utf8&amp;amp;serverTimezone=UTC\") .setProperty(\"hibernate.connection.username\",\"root\") .setProperty(\"hibernate.connection.password\", \"123456\") .setProperty(\"hibernate.c3p0.max_size\", \"20\") .setProperty(\"hibernate.c3p0.min_size\", \"1\") .setProperty(\"hibernate.c3p0.timeout\", \"5000\") .setProperty(\"hibernate.c3p0.max_statements\", \"100\") .setProperty(\"hibernate.c3p0.idle_test_period\", \"3000\") .setProperty(\"hibernate.c3p0.acquire_increment\", \"2\") .setProperty(\"hibernate.dialect\", \"org.hibernate.dialect.MySQL5InnoDBDialect\") .setProperty(\"hibernate.hbm2ddl.auto\", \"update\"); //以Configuration为实例创建SqlSessionFactory SessionFactory sf = cfg.buildSessionFactory(); //创建session Session sess = sf.openSession(); //开启事务 Transaction tx = sess.beginTransaction(); //创建消息对象 News n=new News(); n.setTitle(\"疯狂Java联盟成立了\"); n.setContent(\"疯狂Java联盟成立了，网站地址：http://crazyit.org/\"); //保存信息 sess.save(n); //提交事务 tx.commit(); //关闭 sess.close(); sf.close(); &#125;&#125; hibernate.properties文件与hibernate.cfg.xml文件 在实际开发中，通常会使用hibernate.cfg.xml作为配置文件. 查看hibernate.properties配置文件 配置属性 hibernate.dialect org.hibernate.dialect.MySQLDialect 查看hibernate.cfg.xml配置文件，配置属性 &lt;property name=&quot;hibernate.dialect&quot;&gt;org.hibernate.dialect.MySQL5InnoDBDialect&lt;/property&gt; 上面两个文件，虽然两者的配置风格不同，但是其实质完全一样。JDBC连接属性 Hibernate需要进行数据库访问，因此必须设置连接数据库的相关属性.所有的hibernate属性的名字和语义都在org.hibernate.cfg.Environment中定义. 下面是关于JDBC连接配置中重要的设置 hibernate.connection.driver_class：设置连接数据库的驱动。 hibernate.connection.url:设置所需连接数据库服务的URL hibernate.connection.username：设置连接数据库的用户名 hibernate.connection.password：设置连接数据库的密码 hibernate.dialect：设置连接数据库所使用方言 hibernate.connection.pool_size：设置Hibernate数据库连接池最大的连接数 下面是配置C3P0连接池的配置阶段12345678910&lt;!-- 指定连接池最大的连接数 --&gt;&lt;property name=\"hibernate.c3p0.max_size\"&gt;20&lt;/property&gt; &lt;!-- 指定连接池最小的连接数 --&gt;&lt;property name=\"hibernate.c3p0.min_size\"&gt;1&lt;/property&gt;&lt;!-- 指定连接池里连接的超时时长 --&gt;&lt;property name=\"hibernate.c3p0.timeout\"&gt;5000&lt;/property&gt;&lt;!-- 指定连接池最大缓存多个多少个Statement对象 --&gt;&lt;property name=\"hibernate.c3p0.max_statements\"&gt;100&lt;/property&gt;&lt;property name=\"hibernate.c3p0.idle_test_period\"&gt;3000&lt;/property&gt;&lt;property name=\"hibernate.c3p0.acquire_increment\"&gt;2&lt;/property&gt; 数据库方言 数据库方言：告诉Hibernate底层应该使用哪种数据库。JNDI数据源的连接属性 如果无须Hibernate自己管理属性，而是直接访问容器管理数据源，Hibernate可以使用JNDI数据源的相关配置。 下面是连接JNDI(Java Naming Directory Interface：Java命名目录接口)数据源的主要配置属性： hibernate.connection.datasource：指定JDNI数据源的名字 hibernate.jndi.url：指定JDNI提供者的url，该属性是可选的。如果JNDI与Hibernate持久化访问的代码处于同一个应用中，则无须指定该属性。 hibernate.jndi.class：指定JDNI InitialContextFactory的实现类，该属性也是可选的。如果JNDI与Hibernate持久化访问的代码处于同一个应用中，则无须指定该属性。 hibernate.connection.username：指定连接数据库的用户名，该属性是可选的。 hibernate.connection.password：指定连接数据库的密码，该属性是可选的。 即时使用JNDI数据源，也一样需要指定连接数据库的方言。 下面配置Hibernate连接Tomcat中数据源的配置片段：123&lt;property name=\"hibernate.connection.datasource\"&gt;java:comp/env/jdbc/dstest&lt;/property&gt;&lt;!--指定数据库方言--&gt;&lt;property name=\"hibernate.dialect\"&gt;org.hibernate.dialect.MySQL5InnoDBDialect&lt;/property&gt; Hibernate事务属性 Hibernate关于事务管理的属性有如下几个： hibernate.transaction.factory_class; jta.UserTransaction hibernate.transaction.manager_lookup_class hibernate.transaction.flush_before_completion hibernate.transaction.auto_close_session 二级缓存相关属性 Hibernate中的SessionFactory持有一个可选的二级缓存，通过这个二级缓存可以提高持久化的访问性能。 Hibernate关于二级缓存的属性有如下几个: hibernate.cache.use_second_level_cache hibernate.cache.region.factory_class hibernate.cache.region_prefix hibernate.cache.use_minimal_puts hibernate.cache.use_query_cache hibernate.cache.query_cache_factory hibernate.cache.use_structured_entries 外连接抓取属性 @ManyToOne、@OneToMany、@ManyToMany、@OneToOne其他常用的配置属性 除了上面介绍的必要属性之外，Hibernate常用的配置属性还有如下几个：123456789101112131415&lt;!-- 其他常用配置 --&gt;&lt;!-- 显示Hibernate持久操作所生成的SQL --&gt;&lt;property name=\"show_sql\"&gt;true&lt;/property&gt;&lt;!-- 将SQL格式化后输出 --&gt;&lt;property name=\"format_sql\"&gt;true&lt;/property&gt;&lt;!-- 添加调试 --&gt;&lt;property name=\"hibernate.use_sql_comments\"&gt;&lt;/property&gt;&lt;!-- 指定JDBC抓取数量的大小 --&gt;&lt;property name=\"hibernate.jdbc.fetch_size\"&gt;&lt;/property&gt;&lt;!-- 指定Hibernate使用JDBC2的批量更新的大小 --&gt;&lt;property name=\"hibernate.jdbc.batch_size\"&gt;&lt;/property&gt;&lt;!-- 设置为是否自动提交 --&gt;&lt;property name=\"hibernate.connection.autocommit\"&gt;&lt;/property&gt;&lt;!-- 根据需要自动创建数据库表 --&gt;&lt;property name=\"hibernate.hbm2ddl.auto\"&gt;update&lt;/property&gt;&lt;!-- ① --&gt; 当然Hibernate配置文件中的配置属性还有很多，可以参考hibernate官方参考文档。 深入理解持久化对象","categories":[{"name":"back-end","slug":"back-end","permalink":"https://CPWS.github.io/categories/back-end/"}],"tags":[{"name":"hibernate5","slug":"hibernate5","permalink":"https://CPWS.github.io/tags/hibernate5/"}]},{"title":"spring4","slug":"spring4","date":"2019-10-23T11:39:01.000Z","updated":"2019-12-05T09:01:30.674Z","comments":true,"path":"2019/10/23/spring4/","link":"","permalink":"https://CPWS.github.io/2019/10/23/spring4/","excerpt":"","text":"Spring框架简介 主要发明者：Rod Johnson 轮子理论推崇者： 轮子理论：不用重复发明轮子。 IT行业：直接使用写好的代码。 Spring框架宗旨：不重新发明技术，让原有技术使用起来更加方便。 Spring的极大核心功能 Ioc/DI：控制反转/依赖注入 Aop：面向切面编程 声明式事务 Spring框架的runtime test:Spring框架提供的测试功能 Core Container容器：核心容器。Spring启动基本的条件 Beans：Spring负责创建类对象并管理对象。 Core：核心类库。 Context：上下文参数，获取外部资源或者管理注解。 SpEl：expression.jar AOP:实现aop功能需要依赖 Aspects：切面AOP依赖的包 Data Access/Integration：spring封装数据访问层相关内容 jdbc：spring对jdbc封装后的代码。 ORM：封装持久层框架的代码；如Hibernate transaction：对应spring-tx.jar 声明式事务 WEB：需要spring完成Web相关功能时需要 例如：由tomcat加载spring配置文件需要有spring-web包 Spring框架中重要概念： 容器(container)：spring当做一个大容器 BeanFactory接口：老版本。 新版本中ApplicationContext接口BeanFactory子接口。BeanFactory的功能在ApplicationContext中都有。 从Spring3开始把Spring框架的功能拆分成多个.jar SpringIoc简介： 中文名称：控制反转 英文名称：（Inversion of Control） Ioc是什么？ Ioc完成的事情是原先由程序主动通过new实例化对象事情，转交给Spring负责。 控制反转中的控制指的是：控制类的对象。 控制反转中的反转指的是：转交给Spring负责。 Ioc最大的作用：解耦。 程序员不需要去管理对象。解除了对象管理和程序员之间的耦合。 Spring环境搭建 导入jar包 四个核心包+日志包 在src下新建applicationContext.xml 文件名称和路径自定义 记住Spring容器applicationContext，applicationContext配置的信息最终存储到了applicationContext容器中。 Spring配置文件是基于schema Schema文件扩展名.xsd 把Schema理解成Dtd的升级版 比dtd具备更好的扩展性。 每次引入一个xsd配置文件就是一个namespace（xmlns） 配置文件中只需要导入schema即可。 通过&lt;/bean&gt;创建对象。 对象是在加载配置文件时被加载。 1234567891011&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!-- id：表示获取到对象标识 class：创建哪个类的对象 --&gt; &lt;bean id=\"peo\" class=\"com.gdaib.pojo.People\"&gt;&lt;/bean&gt;&lt;/beans&gt; 编写测试方法 getBean(“&lt;bean/&gt;属性的id值”,创建的对象类型)。 getBeanDefinitionNames()：获取bean属性管理的所有对象。 1234567ApplicationContext ac=new ClassPathXmlApplicationContext(\"applicationContext.xml\");People people = ac.getBean(\"peo\",People.class);System.out.println(people);String[] names = ac.getBeanDefinitionNames();for (String string : names) &#123; System.out.println(string);&#125; Spring创建对象的三种方式： 通过构造方法创建 无参构造创建：默认情况 有参构造创建：需要明确配置 需要在类提供有参构造方法 在applicationContext.xml中设置调用哪个构造方法创建对象。 如果设定的条件匹配多个构造方法，执行最后的构造方法。 index：参数的索引，从0开始。 name：参数名。 type：参数类型。 value指定参数的参数值。 123456789101112131415161718&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!-- id：表示获取到对象标识 class：创建哪个类的对象 --&gt; &lt;bean id=\"peo\" class=\"com.gdaib.pojo.People\"&gt; &lt;!-- ref引用另一个bean；value基本数据类型或String等 --&gt; &lt;!-- &lt;constructor-arg index=\"0\" value=\"123\"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg index=\"1\" value=\"张三\"&gt;&lt;/constructor-arg&gt; --&gt; &lt;constructor-arg index=\"0\" name=\"id\" type=\"int\" value=\"321\"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg index=\"1\" name=\"name\" type=\"java.lang.String\" value=\"李四\"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt;&lt;/beans&gt; 实例工厂 工厂设计模式：帮助创建类对象，一个工厂可以生产多个对象。 实例工厂：需要先创建工厂，才能生产对象。 实现步骤： 需要有一个实例工厂模式 1234567package com.gdaib.pojo;public class PeopleFactory2 &#123; public People newInstance() &#123; return new People(1,\"测试\"); &#125;&#125; 在applicationContext.xml配置并创建bean对象。 123&lt;!-- 实例工厂 --&gt;&lt;bean id=\"factory\" class=\"com.gdaib.pojo.PeopleFactory2\"&gt;&lt;/bean&gt;&lt;bean id=\"peo1\" factory-bean=\"factory\" factory-method=\"newInstance\"&gt;&lt;/bean&gt; 静态工厂 不需要创建工厂，快速创建对象 实现步骤： 编写一个静态工厂（在方法上加上一个static） 1234567package com.gdaib.pojo;public class PeopleFactory2 &#123; public static People newInstance() &#123; return new People(1,\"测试\"); &#125;&#125; 在applicationContext.xml进行配置 12&lt;!-- 静态工厂 --&gt;&lt;bean id=\"peo2\" class=\"com.gdaib.pojo.PeopleFactory2\" factory-method=\"newInstance\"&gt;&lt;/bean&gt; 如何给Bean的属性赋值（注入） 通过构造方法设置值 设置注入(setter方法) 如果属性是基本数据类型或String类型 1234&lt;bean id=\"peo\" class=\"com.gdaib.pojo.People\"&gt; &lt;property name=\"id\" value=\"555\"&gt;&lt;/property&gt; &lt;property name=\"name\" value=\"张三\"&gt;&lt;/property&gt;&lt;/bean&gt; 等效于 1234&lt;bean id=\"peo\" class=\"com.gdaib.pojo.People\"&gt; &lt;property name=\"id\"&gt;&lt;value&gt;345&lt;/value&gt;&lt;/property&gt; &lt;property name=\"name\"&gt;&lt;value&gt;lisi&lt;/value&gt;&lt;/property&gt;&lt;/bean&gt; 如果属性是Set&lt;?&gt;时 1234567891011121314151617&lt;bean id=\"peo\" class=\"com.gdaib.pojo.People\"&gt; &lt;property name=\"id\"&gt; &lt;value&gt;567&lt;/value&gt; &lt;/property&gt; &lt;property name=\"name\"&gt; &lt;value&gt;lisi&lt;/value&gt; &lt;/property&gt; &lt;property name=\"sets\"&gt; &lt;set&gt; &lt;value&gt;1&lt;/value&gt; &lt;value&gt;2&lt;/value&gt; &lt;value&gt;3&lt;/value&gt; &lt;value&gt;4&lt;/value&gt; &lt;/set&gt; &lt;/property&gt;&lt;/bean&gt; 如果对象是List&lt;?&gt;集合 12345678910111213141516&lt;bean id=\"peo\" class=\"com.gdaib.pojo.People\"&gt; &lt;property name=\"id\"&gt; &lt;value&gt;567&lt;/value&gt; &lt;/property&gt; &lt;property name=\"name\"&gt; &lt;value&gt;lisi&lt;/value&gt; &lt;/property&gt; &lt;property name=\"lists\"&gt; &lt;list&gt; &lt;value&gt;1&lt;/value&gt; &lt;value&gt;2&lt;/value&gt; &lt;value&gt;3&lt;/value&gt; &lt;value&gt;4&lt;/value&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt; 如果list集合中只有一个值 1&lt;property name=\"list\" value=\"1\"&gt;&lt;/property&gt; 如果属性是数组时 12345678910111213141516&lt;bean id=\"peo\" class=\"com.gdaib.pojo.People\"&gt; &lt;property name=\"id\"&gt; &lt;value&gt;567&lt;/value&gt; &lt;/property&gt; &lt;property name=\"name\"&gt; &lt;value&gt;lisi&lt;/value&gt; &lt;/property&gt; &lt;property name=\"strs\"&gt; &lt;array&gt; &lt;value&gt;1&lt;/value&gt; &lt;value&gt;2&lt;/value&gt; &lt;value&gt;3&lt;/value&gt; &lt;value&gt;4&lt;/value&gt; &lt;/array&gt; &lt;/property&gt;&lt;/bean&gt; 如果数组中只有一个值 1&lt;property name=\"strs\" value=\"1\"&gt;&lt;/property&gt; 如果属性是map 123456&lt;property name=\"maps\"&gt; &lt;map&gt; &lt;entry key=\"1\" value=\"2\"&gt;&lt;/entry&gt; &lt;entry key=\"3\" value=\"4\"&gt;&lt;/entry&gt; &lt;/map&gt;&lt;/property&gt; 如果属性是Properties时 123456&lt;property name=\"demo\"&gt; &lt;props&gt; &lt;prop key=\"key1\"&gt;value1&lt;/prop&gt; &lt;prop key=\"key2\"&gt;value2&lt;/prop&gt; &lt;/props&gt;&lt;/property&gt; DI DI：中文名称：依赖注入 DI: 英文名称：Dependency Injection DI是什么？ DI和IOC是一样的 当一个类(A)中需要依赖另一个类(B)对象时，把B赋值给A的过程就叫注入。 代码体现12345678&lt;bean id=\"peo\" class=\"com.gdaib.pojo.People\"&gt; &lt;property name=\"desk\" ref=\"desk\"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;bean id=\"desk\" class=\"com.gdaib.pojo.Desk\"&gt; &lt;property name=\"id\" value=\"1\"&gt;&lt;/property&gt; &lt;property name=\"price\" value=\"12.3\"&gt;&lt;/property&gt;&lt;/bean&gt; 使用Spring简化Mybatis 导入jar包：导入Mybatis所有的jar包和spring基本包，spring-jdbc,spring-tx,spring-aop,spring整合mybatis的包等。 编写spring配置文件：applicationContext.xml 123456789101112131415161718192021222324252627282930313233&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!-- 数据源封装类 数据源：获取数据库连接 spring-jdbc.jar --&gt; &lt;bean id=\"dataSource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\"&gt; &lt;property name=\"driverClassName\" value=\"com.mysql.cj.jdbc.Driver\"&gt;&lt;/property&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/ssm?serverTimezone=UTC&amp;amp;characterEncoding=UTF8\"&gt;&lt;/property&gt; &lt;property name=\"username\" value=\"root\"&gt;&lt;/property&gt; &lt;property name=\"password\" value=\"123456\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 依赖注入 创建SqlSessionFactory对象--&gt; &lt;bean id=\"factory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt; &lt;!-- 数据库连接信息来源与DataSource --&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 扫描器 相当Mybatis中Mappers标签下的package标签，扫描com.gdaib.mapper包后会给对应接口创建对象 --&gt; &lt;bean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\"&gt; &lt;!-- 指定要扫描哪个包 --&gt; &lt;property name=\"basePackage\" value=\"com.gdaib.mapper\"&gt;&lt;/property&gt; &lt;!-- 和factory产生关系 --&gt; &lt;property name=\"sqlSessionFactory\" ref=\"factory\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 由spring来管理实现类 --&gt; &lt;bean id=\"airportService\" class=\"com.gdaib.pojo.impl.AirportServiceImpl\"&gt; &lt;property name=\"airportMapper\" ref=\"airportMapper\"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 编写代码 正常编写pojo 编写Mapper包下时必须使用接口绑定方案或者注解方法(必须有接口) 正常编写Service接口和Service接口的实现类 需要在Service实现类中声明Mapper接口对象，并生成getter和setter方法。 spring无法管理Servlet AOP AOP：中文名称：面向切面编程 AOP: 英文名称：Aspect Oriented Programming 正常程序执行流程都是纵向执行流程。 又叫面向切面编程，在原有纵向执行流程中添加横切面。 不需要修改原有程序代码（体现出程序高扩展性） 高扩展性 原有功能相当于释放了部分逻辑，让职责更加明确。 面向切面编程是什么？ 在程序原有纵向执行流程中，针对某一个某一些方法添加通知，形成横切面的过程就叫做面向切面编程。 常用概念 原有功能：切点：pointcut 前置通知：在切点之前执行的功能：before advice 后置通知：在切点之后执行的功能：after advice 如果切点执行过程中出现异常，会触发异常通知。throwable advice 所有功能的总称叫做切面 织入：把切面嵌入到原有功能的过程叫做织入。 Spring提供了2中AOP方式 Schema-based 每个通知都需要实现接口或类。 配置spring文件时在&lt;aop:config&gt;配置 AspectJ 每个通知不需要实现类或接口 配置spring配置文件是在&lt;aop:config&gt;的字标签&lt;aop:aspect&gt;中配置。 schema-based实现步骤： 导入jar包 新建通知类：前置通知类和后置通知类 arg0：切点方法对象 Method对象 arg1：切点方法参数 arg2：切点在哪个对象中 12345678910111213141516package com.gdaib.advise;import java.lang.reflect.Method;import org.springframework.aop.MethodBeforeAdvice;public class MyBeforeAdvice implements MethodBeforeAdvice&#123; @Override public void before(Method arg0, Object[] arg1, Object arg2) throws Throwable &#123; System.out.println(\"前置通知\"); &#125;&#125; arg0:切点方法返回值 arg1：切点方法对象 arg2：切点方法参数 arg4：切点方法所在类的对象 1234567891011121314package com.gdaib.advise;import java.lang.reflect.Method;import org.springframework.aop.AfterReturningAdvice;public class MyAfterAdvice implements AfterReturningAdvice&#123; @Override public void afterReturning(Object arg0, Method arg1, Object[] arg2, Object arg3) throws Throwable &#123; // TODO Auto-generated method stub System.out.println(\"执行后置通知\"); &#125;&#125; 配置spring配置文件 引入aop命名空间 配置通知类&lt;bean/&gt; 配置通知 &lt;aop:advisor&gt; *：通配符，匹配任意方法名，任意类名，任意一级包名 (..)：如果希望匹配任意方法参数 1234567891011121314151617181920212223&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd\"&gt; &lt;!-- 配置通知类对象 --&gt; &lt;bean id=\"mybefore\" class=\"com.gdaib.advise.MyBeforeAdvice\"&gt;&lt;/bean&gt; &lt;bean id=\"myafter\" class=\"com.gdaib.advise.MyAfterAdvice\"&gt;&lt;/bean&gt; &lt;!-- 添加切面功能 Schema-based--&gt; &lt;aop:config&gt; &lt;!-- 配置切点 --&gt; &lt;aop:pointcut expression=\"execution(* com.gdaib.test.Demo.demo2())\" id=\"mypoint\"/&gt; &lt;!-- 添加前置通知 --&gt; &lt;aop:advisor advice-ref=\"mybefore\" pointcut-ref=\"mypoint\"/&gt; &lt;!-- 添加后置通知 --&gt; &lt;aop:advisor advice-ref=\"myafter\" pointcut-ref=\"mypoint\"/&gt; &lt;/aop:config&gt; &lt;!-- 配置demo,测试时使用 --&gt; &lt;bean id=\"demo\" class=\"com.gdaib.test.Demo\"&gt;&lt;/bean&gt;&lt;/beans&gt; 测试 123456789101112public class Demo &#123; public void demo1() &#123; System.out.println(\"demo1\"); &#125; public void demo2() &#123; System.out.println(\"demo2\"); &#125; public void demo3() &#123; System.out.println(\"demo3\"); &#125; &#125; 123456789101112public class Test &#123; public static void main(String[] args) &#123; //AOP 扩展 //IOC 解耦 ApplicationContext ac=new ClassPathXmlApplicationContext(\"applicationContext.xml\"); Demo demo=ac.getBean(\"demo\",Demo.class); demo.demo1(); demo.demo2(); demo.demo3(); &#125;&#125; 运行结果 配置异常通知的步骤：（AspectJ） 只有当切点报异常才能出发异常通知. 在spring中有AspectJ方式提供了异常通知的方法。 如果希望通过Schema-based实现需要按照特定的要求自己编写方法 实现步骤： 新建一个类，在类中写任意名称的方法 123456public class Myexception implements ThrowsAdvice&#123; public void myexcetion(Exception e) &#123; System.out.println(\"异常捕获通知:\"+e.getMessage()); &#125;&#125; 在spring配置文件中配置 &lt;aop:aspect&gt;的ref属性表示：方法在哪个类中 &lt;aop:xxx&gt;表示什么通知 method:表示调用哪个方法 throwing：异常对象名，必须和通知方法中参数名相同（可以不再通知方法中添加任何参数） 12345678&lt;bean id=\"my\" class=\"com.gdaib.advise.Myexception\"&gt;&lt;/bean&gt;&lt;aop:config&gt; &lt;aop:aspect ref=\"my\"&gt; &lt;aop:pointcut expression=\"execution(* com.gdaib.test.Demo.demo1())\" id=\"mypoint\"/&gt; &lt;aop:after-throwing method=\"myexcetion\" pointcut-ref=\"mypoint\" throwing=\"e\"/&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt;&lt;bean id=\"demo\" class=\"com.gdaib.test.Demo\"&gt;&lt;/bean&gt; 使用Schema-base方式实现异常通知 新建一个类实现ThrowAdvice接口 必须自己写方法，且必须叫afterThrowing 有两种参数方式,必须一个或四个 throwing值必须和方法参数名一致. 12345678910package com.gdaib.advise;import org.springframework.aop.ThrowsAdvice;public class MyThrow implements ThrowsAdvice&#123; public void afterThrowing(ArithmeticException ex) throws Throwable &#123; System.out.println(\"异常通知Schema-based\"); &#125;&#125; 在spring的applicationContext.xml中进行配置 123456789101112131415161718&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd\"&gt; &lt;bean id=\"mythrow\" class=\"com.gdaib.advise.MyThrow\"&gt;&lt;/bean&gt; &lt;aop:config&gt; &lt;aop:pointcut expression=\"execution(* com.gdaib.test.Demo.demo1())\" id=\"mypoint\"/&gt; &lt;aop:advisor advice-ref=\"mythrow\" pointcut-ref=\"mypoint\"/&gt; &lt;aop:aspect&gt; &lt;aop:after-throwing method=\"mythrow\" throwing=\"ex\"/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt; &lt;bean id=\"demo\" class=\"com.gdaib.test.Demo\"&gt;&lt;/bean&gt;&lt;/beans&gt; 环绕通知(schema-base) 把前置通知和后置通知都写到一个通知中，成为环绕通知。 实现步骤： 新建一个类实现MethodInterceptor接口，并重写invoke方法 123456789101112131415/*** * 环绕通知(schema-base) * @author 1huangzewei * */public class MyArround implements MethodInterceptor&#123; @Override public Object invoke(MethodInvocation arg0) throws Throwable &#123; System.out.println(\"环绕-前置\"); Object result = arg0.proceed(); //放行，调用切点方式 System.out.println(\"环绕-后置\"); return result; &#125; &#125; 在spring中配置applicationContext.xml文件 123456&lt;bean id=\"myarround\" class=\"com.gdaib.advise.MyArround\"&gt;&lt;/bean&gt;&lt;aop:config&gt; &lt;aop:pointcut expression=\"execution(* com.gdaib.test.Demo.demo1())\" id=\"mypoint\"/&gt; &lt;aop:advisor advice-ref=\"myarround\" pointcut-ref=\"mypoint\"/&gt;&lt;/aop:config&gt;&lt;bean id=\"demo\" class=\"com.gdaib.test.Demo\"&gt;&lt;/bean&gt; ApsectJ方式实现 新建类，不用实现任何方法 类中的方法任意定义 12345678910111213141516171819202122public class MyAdvice &#123; public void before(String name,int age) &#123; System.out.println(\"前置通知\"); System.out.println(name+\" \"+age); &#125; public void after() &#123; System.out.println(\"后置通知1\"); &#125; public void myaftering() &#123; System.out.println(\"后置通知2\"); &#125; public void mythrow() &#123; System.out.println(\"异常通知\"); &#125; public Object myaround(ProceedingJoinPoint p) throws Throwable &#123; System.out.println(\"执行环绕通知\"); System.out.println(\"环绕前置\"); Object result = p.proceed(); System.out.println(\"环绕后置\"); return result; &#125;&#125; 配置Spring配置文件 &lt;aop:after&gt;：后置通知，是否出现异常都执行 &lt;aop:after-returning/&gt;：后置通知，只有当切点正确执行时执行。 &lt;aop:after&gt;、&lt;aop:after-returning&gt;、&lt;aop:after-throwing&gt;执行顺序和配置顺序有关。 execution()括号不能加上参数 中间使用and不能使用&amp;&amp; 有spring把and解析成&amp;&amp; args括号里的名称是自定义。顺序和demo1(参数，参数)对应 &lt;aop:before&gt;;arg-names=“名称”，名称来源于expression=””中arg()，名称必须一样。 args()有几个参数，arg-names里面必须有几个。 arg-names里面名称必须和通知方法参数名对应。 1234567891011121314&lt;bean id=\"demo\" class=\"com.gdaib.test.Demo\"&gt;&lt;/bean&gt;&lt;bean id=\"myadvice\" class=\"com.gdaib.advise.MyAdvice\"&gt;&lt;/bean&gt;&lt;aop:config&gt; &lt;aop:aspect ref=\"myadvice\"&gt; &lt;aop:pointcut expression=\"execution(* com.gdaib.test.Demo.demo1(String,int)) and args(name,age))\" id=\"mypoint\"/&gt; &lt;aop:before method=\"before\" pointcut-ref=\"mypoint\" arg-names=\"name,age\"/&gt; &lt;!-- 下面两者的区别在于after不管方法出不出异常都会执行，而后者只能在方法执行正常时才执行 --&gt; &lt;!-- &lt;aop:after method=\"after\" pointcut-ref=\"mypoint\"/&gt; &lt;aop:after-returning method=\"myaftering\" pointcut-ref=\"mypoint\"/&gt; &lt;aop:after-throwing method=\"mythrow\" pointcut-ref=\"mypoint\"/&gt; &lt;aop:around method=\"myaround\" pointcut-ref=\"mypoint\"/&gt; --&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; 使用注解(基于Aspect) Spring不会自动去寻找注解，必须告诉Spring哪些包下的类可能有注解。 引入xmlns:context。 1&lt;context:component-scan base-package=\"com.gdaib.advise,com.gdaib.test\"&gt;&lt;/context:component-scan&gt; @Component： 相当于&lt;bean/&gt; 如果没有参数，把类名首字母变小写，相当于&lt;bean id=&quot;&quot;/&gt; @Component(“自定义名称”) 实现步骤 在Spring配置文件中设置注解在哪些包中 1234567&lt;!-- 如果有多个，使用逗号隔开 --&gt;&lt;context:component-scan base-package=\"com.gdaib.advise,com.gdaib.test\"&gt;&lt;/context:component-scan&gt; &lt;!-- true:使用CGLIB动态代理 false：使用JDK动态代理--&gt;&lt;aop:aspectj-autoproxy proxy-target-class=\"true\"&gt;&lt;/aop:aspectj-autoproxy&gt; 在Demo类中添加@Component,在指定方法上添加切点即@Pointcut注解 123456789@Componentpublic class Demo &#123; //添加切点 @Pointcut(\"execution(* com.gdaib.test.Demo.demo1())\") public void demo1() throws Exception&#123; //int i=5/0; System.out.println(\"demo1\"); &#125;&#125; 在通知类类中配置 @Component：表明该类被Spring管理 @Aspect:表明该切面使用AspectJ 12345678910111213141516171819202122232425@Component@Aspectpublic class MyAdvice &#123; @Before(\"com.gdaib.test.Demo.demo1()\") public void mybefore() &#123; System.out.println(\"前置通知\"); &#125; //添加后置通知 /*@After(\"com.gdaib.test.Demo.demo1()\") public void myafter() &#123; System.out.println(\"后置通知\"); &#125;*/ @AfterThrowing(\"com.gdaib.test.Demo.demo1()\") public void mythrow() &#123; System.out.println(\"通知异常\"); &#125; //环绕通知 @Around(\"com.gdaib.test.Demo.demo1()\") public Object myarround(ProceedingJoinPoint p) throws Throwable &#123; System.out.println(\"环绕-前\"); Object result=p.proceed(); System.out.println(\"环绕-后\"); return result; &#125;&#125; 代理设计模式 设计模式：前人总结的一套解决待定问题的代码; 代理设计模式优点： 保护真实对象。 让真实对象职责更明确。 扩展。 代理设计模式 真实对象 代理对象 抽象对象（抽象功能） 静态代理设计模式 由代理对象代理真实对象的功能。 自己编写代理类. 每个代理的功能需要单独编写。 静态代理设计模式的缺点： 当代理功能比较多时，代理类就得代理多个方法。 总结：静态代理模式代码的可重用性差。 动态代理 为了解决静态代理频繁编写代理功能的缺点。 分类： JDK提供的 CGLIB JDK动态代理 和CGLIB动态代理的比较 JDK自带,不需要导入第三方jar包 缺点：真实对象必须实现接口;利用反射机制，效率不高; CGLIB动态代理 优点：基于字节码操作，生成真实对象的子类。 效率比JDK动态代理高 不需要实现接口 缺点，需要导入jar包. 使用SpringAOP时，只要出现Proxy和真实对象转换异常12345&lt;!-- true:使用CGLIB动态代理 false：使用JDK动态代理--&gt;&lt;aop:aspectj-autoproxy proxy-target-class=\"true\"&gt;&lt;/aop:aspectj-autoproxy&gt; 自动驻入 在spring配置文件中对象名和ref=&quot;id&quot;id名相同时使用自动注入，可以不配置property 两种配置方法 在&lt;bean&gt;中通过autowire=&quot;&quot;配置，只对&lt;bean&gt;生效。 在&lt;beans&gt;中通过default-autowire=&quot;&quot;配置，表当当前文件中所有&lt;bean&gt;都是全局配置内容。 autowire可取值 default:默认值，根据全局default-autowire=&quot;&quot;值。默认全局和局部都没有配置情况下。相当于no. no：默认全局和局部都没有配置情况下。 byName：通过名称自动注入，在spring容器中找类id byType：根据类型注入。 Spring容器中不可以出现两个相同类型的&lt;bean/&gt; construtor:根据构造方法注入 提供对应参数的构造方法(构造方法参数中包含注入对象那个) 底层使用byName，构造方法参数名和其他&lt;bean&gt;的id相同。 spring中加载properties文件 在src下新建xxx.properties文件 在spring的配置文件中添加xmlns:context，在下面添加 如果需要加载多个配置文件，需要用逗号隔开 1&lt;context:property-placeholder location=\"classpath:db.properties\"/&gt; 添加属性配置文件记载，并且在&lt;beans&gt;中开启自动注入注意的地方 sqlSessionFactoryBean中的id不能叫sqlSessionFactory 修改:把原来通过ref引用替换成value赋值，自动注入只能影响ref，不能影响value赋值 123456&lt;!-- 配置扫描器 --&gt;&lt;bean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\"&gt; &lt;property name=\"basePackage\" value=\"com.gdaib.mapper\"&gt;&lt;/property&gt; &lt;!-- &lt;property name=\"sqlSessionFactory\" ref=\"factory\"&gt;&lt;/property&gt; --&gt; &lt;property name=\"sqlSessionFactoryBeanName\" value=\"factory\"&gt;&lt;/property&gt;&lt;/bean&gt; 在被spring管理的类中通过@value(&quot;${key}&quot;)取出properties中的值 添加注解扫描 12 &lt;!-- 扫描注解 --&gt;&lt;context:component-scan base-package=\"\"&gt;&lt;/context:component-scan&gt; 在类中添加 key和变量名可以不相同 变量类型任意，只要保证key对应点的value能转换成这个类型就可以。 12@Value(\"$&#123;key&#125;\")private String test; scope属性 &lt;bean&gt;的属性 作用：控制对象有效范围（单例，多例等） &lt;bean/&gt; 标签对应的对象都是单例 scope可取值 singleton：默认值，单例 prototype:多例，每次获取重新实例化 request:每次请求重新实例化 session：每个会话对象内，对象是单例的。 application：每个application范围内，对象是单例的。 global session spring推出的一个对象，依赖于spring-webmvc-portlet，类似于session 单例设计模式 作用：在应用程序中保证最多只有一个实例 好处： 提升运行效率。 实现数据共享.实例：application对象 懒汉式 对象只有被调用，才会去创建对象 1234567891011121314151617181920212223242526272829package com.gdaib.singleton;public class SingleTon &#123; private static SingleTon singleTon; /*** * 方法名和类型相同 * 无返回值 * * 其他类不能实例化这个类 */ private SingleTon() &#123;&#125; /*** * 实例方法，实例方法必须通过对象调用 * 设置方法为静态方法 * @return */ public static SingleTon getInstance() &#123; if(singleTon==null) &#123; //多线程访问下，可能出现线程安全 synchronized (SingleTon.class) &#123; if(singleTon==null) &#123; singleTon=new SingleTon(); &#125; &#125; &#125; return singleTon; &#125;&#125; 由于添加了锁，所以导致执行效率较低。 饿汉式：解决了懒汉式中多线程可能出现多个对象和执行效率低的情况 在类被加载时就被实例化 123456789package com.gdaib.singleton;public class SingleTon &#123; private static SingleTon singleTon=new SingleTon(); private SingleTon() &#123;&#125; public static SingleTon getInstance() &#123; return singleTon; &#125;&#125; 声明式事务 编程式事务 由程序员编写事务控制代码。 OpenSessionInView编程式事务。 声明式事务： 事务控制代码已由spring写好，程序员只需要声明出哪些方法需要进行事务控制和如何进行事务回滚。 声明式事务都是针对于ServiceImpl类的方法下 事务管理器基于通知（advice）的。 在spring中配置声明式事务123456789101112131415161718192021222324252627&lt;!-- 获取数据源 --&gt;&lt;bean id=\"dataSource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\"&gt; &lt;property name=\"driverClassName\" value=\"com.mysql.cj.jdbc.Driver\"&gt;&lt;/property&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/ssm?serverTimezone=UTC&amp;amp;characterEncoding=utf8\"&gt;&lt;/property&gt; &lt;property name=\"username\" value=\"root\"&gt;&lt;/property&gt; &lt;property name=\"password\" value=\"123456\"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- spring-jdbc.jar --&gt;&lt;bean id=\"txManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 配置声明式事务 --&gt;&lt;tx:advice id=\"txAdvice\" transaction-manager=\"txManager\"&gt; &lt;tx:attributes&gt; &lt;!-- 哪些方法需要事务控制 --&gt; &lt;!-- 方法以ins开头事务管理 --&gt; &lt;tx:method name=\"ins*\"/&gt; &lt;tx:method name=\"del*\"/&gt; &lt;tx:method name=\"upd*\"/&gt; &lt;tx:method name=\"*\"/&gt; &lt;/tx:attributes&gt;&lt;/tx:advice&gt;&lt;aop:config&gt; &lt;!-- 切点范围设置大一点 --&gt; &lt;aop:pointcut expression=\"execution(* com.gdaib.service.impl.*.*(..))\" id=\"mypoint\"/&gt; &lt;aop:advisor advice-ref=\"txAdvice\" pointcut-ref=\"mypoint\"/&gt;&lt;/aop:config&gt; 声明式事务属性解释 name=””:哪些方法需要事务控制，支持通配符配置 readonly=”boolean”：是否是只读事务 如果为true，告诉数据库此事务为只读事务。数据库优化，会对性能有一定的提升，所以只要是查询的方法，建议使用此属性值. 如果为false(默认值)：事务需要提交的事务，建议新增，删除，修改 propagation：控制事务传播行为。 当一个具有事务控制的方法被另一个有事务控制的方法调用后，需要如何管理事务。（新建事务？在事务中执行？把事务挂起？报异常） REQUIRED:如果当前有事务，就在事务中执行，如果当前没有事务，则新建一个事务。 SUPPORTS:如果当前有事务就在事务中执行，如果当前没有事务，就在非事务状态下执行。 MANDATORY：必须在事务内部执行，如果当前有事务，就在事务中执行，如果没有事务就报错。 REQUIRES_NEW:必须在事务中执行，如果当前没有事务，则新建事务，如果当前有事务，把当前事务挂起。 NOT_SUPPORTED:必须在非事务下执行，如果当前没有事务，正常执行，如果当前有事务，把当前事务挂起。 NEVER：必须在非事务状态下执行，如果当前没有事务，则正常执行，如果当前有事务，则报错。 NESTED：必须在事务状态下执行，如果没有事务，新建事务，如果当前有事务，创建一个嵌套事务。 isolation=””：事务隔离级别 在多线程和并发访问下如何保证访问到的数据具有完整性。 脏读：一个事务（A）读取到另一个事务(B)中未提交的数据，另一个事务中数据可能进行了改变，此时A事务读取的数据可能和数据库中的数据不一致的，此时认为数据是脏数据，读取脏数据过程叫做脏读。 不可重复读 主要针对的是某行数据（行中某列） 主要针对的操作是修改。 两个读取在通一个事务内。 当事务A第一次读取事务后，事务B对事务A读取的数据进行修改，事务A中再次读取的数据和之前读取的数据不一致，这个过程就叫做不可重复读。 幻读： 主要针对的操作是新增和删除 两次事务的结果 事务A按照特定条件查询出结果，事务B新增了一条符合条件的数据，事务A查询的数据和数据库中的数据不一致的，事务A好像出现了幻觉，这种情况称为幻读。 isolation的可能取值及作用： DEFAULT：默认值，由底层数据库自动判断应该使用什么隔离级别。 READ_UNCOMMITTED：可以读取未提交事务，可能出现脏读、不可重复读、幻读，但是效率最高。 READ_COMMITTED:只能读取其他事务已经提交的数据，可以防止脏读，可能出现不可重复读和幻读。 REPEATABLE_READ：读取的数据被添加锁，防止其他事务修改此数据，可以防止不可重复读、脏读，可能出现幻读。 REPEATABLE_READ：排队操作，对整个表添加锁，一个事务在操作数据时，另一事物等待事务操作完成后才能操作这个表。这个操作，是最安全也是效率最低的。 事务回滚 rollback-for=”类异常的全限定路径” 当出现什么异常时需要进行事务回滚。 建议：给定该属性值。手动抛异常时一定要给定该属性值，即throw new Exception() no-rollback-for=”” 当出现什么异常时不回滚事务。 Spring常用注解 @Component：创建类对象，相当于配置&lt;bean/&gt; @Service与@Component功能相同，@Service写在ServiceImpl上。 @Repository与@Component功能相同,该注解通常写在数据访问层上。 @Controller与@Component功能相同，该注解通常写在控制器上。 @Resource：Java中的注解；默认按照byName,建议把对象名称和属性名称写一样，如果没有名称对象，按照byType注入；不需要编写get和set方法。 @Autowired：Spring框架中的注解；默认按照byType注入。 @Value获取properties文件中的内容 @Pointcut：定义切点。 @Aspect()：定义切面类 @Before()：定义前置通知 @After()：定义后置通知 @AfterReturning()：定义后置通知，必须切点正确执行 @Arround()：环绕通知。ajax复习 $.ajax $.get、$.post $.getJson $.getScript ObjectMapper mapper=new ObjectMapper(); mapper.writeValueAsString(对象);把对象转化为JSON格式字符串。 Spring源码下载地址:https://github.com/spring-projects/spring-framework/tags?after=v4.2.5.RELEASESpring框架下载地址：https://repo.spring.io/release/org/springframework/spring/Spring与Mybatis整合的jar包：https://blog.csdn.net/qiangqiang816/article/details/81541188Maven地址：https://mvnrepository.com/","categories":[{"name":"back-end","slug":"back-end","permalink":"https://CPWS.github.io/categories/back-end/"}],"tags":[{"name":"spring4","slug":"spring4","permalink":"https://CPWS.github.io/tags/spring4/"}]},{"title":"SSM","slug":"SSM","date":"2019-10-18T08:03:37.000Z","updated":"2019-12-05T09:01:52.736Z","comments":true,"path":"2019/10/18/SSM/","link":"","permalink":"https://CPWS.github.io/2019/10/18/SSM/","excerpt":"","text":"第2章 Java设计模式Java反射技术 Java反射技术应用很广泛，它能够配置：类的完全限定名、方法和参数，完成对象的初始化，甚至反射某些方法。这样就可以大大增加Java的可配置性，SpringIoC的基本原理也是如此，当然SpringIoc的代码要复杂很多。 Java的反射内容繁多，包括对象构建、反射方法，、注解、参数、接口等。 对象的构建：包括有参的构建方法和无参数的构建方法。 在Java中，放射是通过包jacva.lang.reflect.*来实现的。 通过反射构建对象 反射的优点是：只要配置就可以生成对象，可以解除耦合度，比较灵活。 反射的缺点是：运行速度比较慢。 案例实现：带无参数构造方法的实现： 123456789101112131415161718192021222324252627282930313233343536373839package com.zhuchuli.demo;import java.lang.reflect.Method;/*** * 反射 * 带有无参的构造方法 + 反射方法 * @author 1huangzewei * */public class ReflectServiceImpl &#123; public void sayHello(String name) &#123; System.err.println(\"hello:\"+name); &#125; /*** * 通过反射获取当前对象 * @return */ public static ReflectServiceImpl getInstance() &#123; ReflectServiceImpl object=null; try &#123; /** * 给类加载器注册一个类 ReflectServiceImpl的全限定名，然后通过调用newInstance()方法初始化一个对象 */ object=(ReflectServiceImpl) Class.forName(\"com.zhuchuli.demo.ReflectServiceImpl\").getConstructor().newInstance(); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; return object; &#125; public static void main(String[] args) &#123; ReflectServiceImpl.getInstance().sayHello(\"张三\"); &#125;&#125; 案例实现：带有有参数构造方法的实现 12345678910111213141516171819202122232425262728293031323334353637383940package com.zhuchuli.demo;/*** * 反射 * 带有有参的构造方法 * @author 1huangzewei * */public class ReflectServiceImpl2 &#123; private String name; public ReflectServiceImpl2(String name) &#123; super(); this.name = name; &#125; public void sayHello() &#123; System.err.println(\"hello:\"+name); &#125; /*** * 通过反射获取当前对象 * @return */ public static ReflectServiceImpl2 getInstance() &#123; ReflectServiceImpl2 object=null; try &#123; /** * 给类加载器注册一个类 ReflectServiceImpl的全限定名，然后通过调用newInstance()方法初始化一个对象 */ object=(ReflectServiceImpl2) Class.forName(\"com.zhuchuli.demo.ReflectServiceImpl2\").getConstructor(String.class).newInstance(\"李四\"); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; return object; &#125; public static void main(String[] args) &#123; ReflectServiceImpl2.getInstance().sayHello(); &#125;&#125; 反射方法 案例实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package com.zhuchuli.demo;import java.lang.reflect.Method;/*** * 反射 * 带有无参的构造方法 + 反射方法 * @author 1huangzewei * */public class ReflectServiceImpl &#123; public void sayHello(String name) &#123; System.err.println(\"hello:\"+name); &#125; /*** * 通过反射获取当前对象 * @return */ public static ReflectServiceImpl getInstance() &#123; ReflectServiceImpl object=null; try &#123; /** * 给类加载器注册一个类 ReflectServiceImpl的全限定名，然后通过调用newInstance()方法初始化一个对象 */ object=(ReflectServiceImpl) Class.forName(\"com.zhuchuli.demo.ReflectServiceImpl\").getConstructor().newInstance(); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; return object; &#125; public Object reflectMethod() &#123; Object returnObj=null; ReflectServiceImpl target=new ReflectServiceImpl(); try &#123; Method method=ReflectServiceImpl.class.getMethod(\"sayHello\", String.class); method.invoke(target, \"王五\"); &#125; catch (NoSuchMethodException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; return returnObj; &#125; public static void main(String[] args) &#123; ReflectServiceImpl.getInstance().reflectMethod(); &#125;&#125; 动态代理模式和责任链模式 动态代理的意义在于生成一个占位（又称代理对象），来代理真实对象，从而控制真实对象的访问。 代理的作用：就是在访问真实对象之前或者之后加入一些对象的逻辑，或者根据其他规则控制是否使用真实对象。 代理必须分为两个步骤： 代理对象和真实对象建立代理关系。 实现代理对象的代理逻辑方法。 JDK的动态代理 JDK的动态代理是java.lang.reflect.*包提供的方式，它必须借助于一个接口才能产生代理对象，所以先定义接口。 CGLIB动态代理 它的优势在于不需要提供接口，只要一个非抽象类即能实现动态代理。 拦截器： 由于动态代理一般比较难理解，程序设计者会设计一个拦截器接口供开发者使用。开发者只需要知道拦截器接口的方法、含义和作用即可，不需要知道动态代理是怎么实现的。用JDK动态代理来实现一个拦截器逻辑，为此先定义拦截器接口Interceptor。 责任链模式： 上一点提到了设计者往往会使用拦截器去代替动态代理，然后将拦截器的接口提供给开发者，从而简化了开发者的开发难度，但是拦截器有很多个。 当一个对象在一条链上被多个拦截器处理时，我们把这样的设计模式成为责任链模式，它用于一个对象在多个角色中传递的场景。 责任链的优点在于我们可以在传递链上加入新的拦截器，增加拦截逻辑，其缺点是会增加代理和反射，而代理和反射的性能不高。 观察者（Observer）模式 观察者模式又称为发布订阅模式，是对象的行为模式。观察者定义了一种一对多的依赖关系，让多个对象观察者同时监听被观察者的状态，当被观察者的状态发生该改变时，会通知所有的被观察者，并让其自动更新。 概述： 实例： 观察者要同时存在观察者和被观察者双方，观察者可以有多个。在Java中，需要去继承java.util.Observable类，从而定义被观察者 有了被观察者对象之后，还需要去编写观察者对象。想要编写观察者对象，还需要去实现java.util.Observer接口的update方法 工厂模式和抽象工厂模式建造者模式","categories":[{"name":"back-end","slug":"back-end","permalink":"https://CPWS.github.io/categories/back-end/"}],"tags":[{"name":"SSM","slug":"SSM","permalink":"https://CPWS.github.io/tags/SSM/"}]},{"title":"文档study","slug":"文档study","date":"2019-10-14T13:00:14.000Z","updated":"2019-12-05T08:57:27.217Z","comments":true,"path":"2019/10/14/文档study/","link":"","permalink":"https://CPWS.github.io/2019/10/14/文档study/","excerpt":"","text":"文档","categories":[{"name":"back-end","slug":"back-end","permalink":"https://CPWS.github.io/categories/back-end/"}],"tags":[{"name":"文档study","slug":"文档study","permalink":"https://CPWS.github.io/tags/文档study/"}]},{"title":"Mybatis3","slug":"Mybatis3","date":"2019-10-08T11:25:53.000Z","updated":"2019-12-05T09:00:55.881Z","comments":true,"path":"2019/10/08/Mybatis3/","link":"","permalink":"https://CPWS.github.io/2019/10/08/Mybatis3/","excerpt":"","text":"数据库命令 创建数据库并制定编码 1Create database 数据库名 default character set utf8 创建表 123Create table 表名( 列明 类型 约束 auto_increment comment '备注') 命名规范 项目名：没有要求，不起中文 包：公司域名倒写 持久层：dao,persist,mapper 实体层：entity，model，bean，javabean，pojo 业务逻辑：service，biz 控制器层：controll,action,servlet,web 过滤器：filter 异常：exception 监听器：listener 注释 类：大驼峰 属性和方法：小驼峰 MVC开发模式 M:Model 模型，实体类、业务和dao V:View 视图，JSP C:Controller 控制器，servlet MVC应用场景：适合大型项目开发 jsp+Servlet完成查询和新增框架是什么？ 框架：软件的半成品。为解决问题制定的一套约束，在提供功能的基础上进行扩充。 框架中一些不能被封装的代码（变量），需要使用框架这新建一个xml文件，在文件中添加变量的内容。 需要建立特定位置和特定名称的配置文件. 需要使用xml解析技术和反射技术。 常用概念： 类库:提供的类没有封装一定逻辑。 举例：类库就是名言警句，写作文时引入名言警句。 框架：区别于类库，里面有一定的约束。 框架是填空题。 Mybatis简介 Mybatis是一个开源免费框架。原名叫iBatis，2010在google code，2013年迁移到github 作用：数据访问层框架。 底层是对JDBC的封装 mybatis优点之一 使用Mybatis不需要编写实现类,只需要编写需要执行的sql命令。 Mybatis 环境搭建 导入jar包 asm.jar：Cglib依赖的包 cglib.jar：动态代理的包 commons-logging.jar、log4j.jar、slf4j.*.jar：日志包 javaassist.jar：字节码解析包 mybatis.jar：mybatis的核心包 在src下编写全局配置文件（JDBC四个变量）（mybatis.xml） 没有名称配置和地址要求。 在全局配置文件中引入dtd或schema 12345678910111213141516171819202122232425&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;!-- default引用 environment的id，当前使用的环境--&gt; &lt;environments default=\"default\"&gt; &lt;!-- 声明可能使用的环境 --&gt; &lt;environment id=\"default\"&gt; &lt;!-- 使用原生JDBC事务 --&gt; &lt;transactionManager type=\"JDBC\"&gt;&lt;/transactionManager&gt; &lt;!-- 数据库连接池 --&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"com.mysql.cj.jdbc.Driver\"/&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/ssm?serverTimezone=UTC&amp;amp;characterEncoding=utf8\"/&gt; &lt;property name=\"username\" value=\"root\"/&gt; &lt;property name=\"password\" value=\"123456\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource=\"com/zhuchuli/mapper/FlowerMapper.xml\"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 新建以mapper结尾的包，在包下新建：实体类名+Mapper.xml（FlowerMapper.xml） 文件作用：编写需要执行的sql语句。 把xml文件理解成实现类。 xml文件内容 1234567891011121314&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;!-- namespace：理解成实现类的完全限定名（报名+类名） --&gt;&lt;mapper namespace=\"a.b\"&gt; &lt;!-- id:方法名 --&gt; &lt;!-- parameterType:定义参数类型 --&gt; &lt;!-- resultType:定义结果返回值类型 --&gt; &lt;!-- 如果方法返回是list，在resultType中写List的泛型，因为Mybatis对jdbc封装，一行一行读取数据 --&gt; &lt;select id=\"selAll\" resultType=\"com.zhuchuli.pojo.Flower\"&gt; select * from flower &lt;/select&gt;&lt;/mapper&gt; 测试结果（只有单独使用Mybatis时使用，最后SSM整合时下面代码不需要编写） 12345678910111213141516171819public static void main(String[] args) &#123; InputStream is=null; try &#123; is = Resources.getResourceAsStream(\"mybatis.xml\"); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; //使用工厂设计模式 SqlSessionFactory factory=new SqlSessionFactoryBuilder().build(is); //生产SqlSession SqlSession session=factory.openSession(); List&lt;Flower&gt; list=session.selectList(\"a.b.selAll\"); for (Flower flower : list) &#123; System.out.println(flower.toString()); &#125; //释放资源 session.close(); &#125; 注意：当表列名与Java的属性名称不一致时，在进行数据库查询时可以指定通过起别名来实现。 环境搭建讲解 全局配置文件讲解 &lt;transactionManager&gt;： type属性可取值 JDBC：事务管理使用JDBC原生事务管理方式。 MANAGED：把事务管理转交给其他容器。原生JDBC事务setAutoMapping(false) &lt;dataSource&gt; : type属性可取值 UNPOOLED：不使用数据库连接池，和直接使用JDBC一样。 POOLED：使用数据库连接池 JNDI（Java语言调用其他语言）：Java命令目录接口技术。 数据库连接池 在内存中开辟一块空间，存放多个数据库连接对象 JDBC Tomcat Pool:直接由tomcat产生数据库连接池 图示: 使用数据库连接池的目的： 在高频率访问数据库时，使用数据库连接池可以降低服务器系统压力，提升程序运行效率。 小项目不适用数据库连接池 实现JDBC Tomcat Pool的步骤： 在META-INF包下添加Context.xml文件 1234567891011121314&lt;Context&gt; &lt;Resource driverClassName=\"com.mysql.cj.jdbc.Driver\" url=\"jdbc:mysql://localhost:3306/ssm\" username=\"root\" password=\"123456\" maxActive=\"50\" maxIdle=\"20\" name=\"test\" auth=\"Container\" maxWait=\"10000\" type=\"javax.sql.DataSource\" /&gt;&lt;/Context&gt; 把项目发布到tomcat中，数据库连接池就产生了. 可以使用Java的JNDI获取数据库连接池对象: Context：上下文接口，Context.xml文件对象类型 123Context ctx=new InitialContext();DataSource ds=ctx.lookup(\"java:comp/env/test\");Connection conn=ds.getConnection(); 当关闭数据库连接池对象时，把连接对象归还给数据库连接池，把状态改为idle状态。 三种查询方式 selectList()：返回值List&lt;resultType属性控制&gt; ,适合于查询结果都需要遍历的需求。 1234List&lt;Flower&gt; list=session.selectList(\"a.b.selAll\");for (Flower flower : list) &#123; System.out.println(flower.toString());&#125; selectOne()：返回Object，适用于返回结果只是变量或一行数据时 12int count=session.selectOne(\"a.b.selById\");System.out.println(count); selectMap()返回值Map，适用于需求需要在查询结果中通过某列的值取到这行数据的值的需求。 Map&lt;Object,Object&gt;：第一个Object的数据类型受到selectMap()第二参数影响，第二个Object的数据类型受到&lt;restultType属性值&gt;的控制。 12Map&lt;Object,Object&gt; map=session.selectMap(\"a.b.c\", \"name\");System.out.println(map); Log4j复习 由apache提出的开源免费日志处理的类库。 为什么需要日志： 在项目中编写 system.out.println();输出到控制台，当项目发布到tomcat后，没有控制台（在命令行能看见），不容易观察一些输出结果。 log4j的作用：不仅能把内容输出到控制台，还能把内容输出到文件中。便于观察结果。 使用步骤： 导入jar包 在src下新建log4j.properties(路径和名称都不允许改变) ConversionPattern：写表达式 log4j.appender.LOGFILE.File：写文件输出路径以及名称（日志文件的扩展名为.log） Log4j输出级别： Fatal(指明错误) &gt; error(错误) &gt; warm(警告) &gt; info(普通信息) &gt; debug(调试信息) 在log4j.properties第一行控制输出级别。 log4j.rootCategory=INFO Log4j输出目的地 log4j.rootCategory=CONSOLE,LOGFILE pattern常用表达式 %C 输出类名 %d 输出时间 %L 输出行号 %m 输出日志信息 %n 换行 &lt;settings&gt;标签 在mybatis全局配置文件中&lt;settings&gt;标签控制mybatis全局开关。 在mybatis.xml中开启log4j 必须保证有jar包 在src目录下要有log4j.properties文件 在mybatis.xml配置文件中添加如下代码 1234&lt;settings&gt; &lt;!-- Mybatis开启日志功能 --&gt; &lt;setting name=\"logImpl\" value=\"LOG4J\"/&gt;&lt;/settings&gt; log4j中可以指定内容的日志（控制某个局部内容的日志级别） 命名级别（包级别）：namespace属性中除了最后一个类名 先在总体级别调成error不输出无用信息。 在该配置文件中为特定包名设置输出级别为debug。 例如： namespace=&quot;com.zhuchuli.mapper.PeopleMapper&quot;其中包级别为com.zhuchuli.mapper，需要在log4j.properties配置文件中配置如下代码：log4j.rootCategory=ERROR, CONSOLE , LOGFILE;log4j.logger.com.zhuchuli.mapper=DEBUG 目的：输出主要的日志信息。 类级别：与上面包级别差不多，此处不再赘述。 方法级别：与上面包级别差不多，此处不再赘述。 parameterType 属性 在XxxMapper.xml中等标签的parameterType可以控制参数类型。 SqlSession的selectList()和selectOne()的第二个参数和selectMap()的第三个参数都表示方法的参数 12People people=session.selectOne(\"a.b.selById\",2);System.out.println(people); 在mapper.xml文件中通过#{}获取参数 123&lt;select id=\"selById\" resultType=\"com.zhuchuli.pojo.People\" parameterType=\"int\"&gt; select * from people where id=#&#123;0&#125;&lt;/select&gt; parameterType指定参数类型 #{}获取参数值，使用索引，从0开始，#{0}表示第一个参数。 如果只有一个参数(基本数据类型或String)，mybatis对#{}里面的内容没有要求，只要写内容即可。 如果参数是对象 #{属性名} 如果参数时msap #{key} 如果想要传递多个参数，可以使用map结构或对象 #{}与${}的区别： #{}获取参数的内容支持 索引获取，param1获取指定位置参数，并且SQL使用?占位符。 ${}字符串拼接不使用?，默认找${内容}的get/set方法，如果写数字，就是一个数字。 如果在xml文件中出现”&lt;”,”&gt;”，双引号等特殊字符时，可以使用xml文件转义标签（XML自身）：&lt;![CDATA[内容]]&gt; mybatis 实现mysql分页查询 ？不允许在关键字前后进行数学运算，需要在代码中计算完成后传递到mapper.xml中 在java代码中运算 12345678910int pageSize=2;int pageNumber=3;//如果希望传递多个参数，可以使用map或者对象Map&lt;String,Object&gt; map=new HashMap&lt;String, Object&gt;();map.put(\"pageSize\",pageSize);map.put(\"pageNumber\",(pageSize-1)*pageNumber);List&lt;People&gt; people=session.selectList(\"a.b.page\",map);System.out.println(people);session.close(); 在mapper.xml文件中代码 1234&lt;!-- 分页查询 --&gt;&lt;select id=\"page\" resultType=\"com.zhuchuli.pojo.People\" parameterType=\"map\"&gt; select * from people limit #&#123;pageSize&#125;,#&#123;pageNumber&#125;&lt;/select&gt; 别名 系统内置别名：把类型全小写 给某个类起别名： alias=”自定义” mybatis.xml配置文件 123&lt;typeAliases&gt; &lt;tyeAliases type=\"com.zhuchuli.pojo.People\" alias=\"peo\"/&gt;&lt;/typeAliases&gt; mapper.xml 123&lt;select id=\"page\" resultType=\"peo\" parameterType=\"map\"&gt; select * from people limit #&#123;pageStart&#125;,#&#123;pageSize&#125;&lt;select&gt; 直接给某个包下所有类起别名， 别名为类名，区分大小写。 mybatis.xml配置 123&lt;typeAliases&gt; &lt;package name=\"com.zhuchu.pojo\"/&gt;&lt;/typeAliases&gt; mapper.xml通过类名引用。 123&lt;select id=\"page\" resultType=\"People\" parameterType=\"map\"&gt; select * from people limit #&#123;pageStart&#125;,#&#123;pageSize&#125;&lt;select&gt; MyBatis实现新增 概念复习 功能：从应用程序角度出发，软件具有哪些功能。 事务: 从数据库角度出发，完成业务时需要执行的SQL集合，统称一个事务。 业务: 完成功能时的逻辑。对应Service中一个方法 事务回滚：如果在一个事务中某个sql执行事务，希望回归到事务的原点，保证数据库数据的完整性。 在Mybatis中默认关闭了JDBC自动提交的功能。 每一个SqlSession默认都是不自动提交事务。 session.commit()提交事务。 openSession(true)：自动提交，setAutoCommit(true); mybatis底层是JDBC的封装 JDBC中executeUpdate()执行新增，删除，修改的SQL，返回值int，表示受影响的行数 mybatis中的标签没有resultType属性，认为返回值int 在openSession()时Mybatis会创建SqlSession时同时创建一个Transaction(事务对象)，同时autoCommit为false 如果出现异常，应该session.roolback()进行事务回滚。 使用进行数据库操作时，要添加事务提交处理.Mybatis接口绑定方案及多参数传递 作用：实现创建一个接口后把mapper.xml由mybatis生成接口的实现类，通常调用接口对象就可以获取mapper.xml中编写的sql。 后面mybatis和spring整合时使用的是这个方案。 实现步骤： 创建一个接口 接口包名和接口名与mapper.xml中的namespace相同。 接口中的方法名和mapper的id属性值相同。 在mybatis.xml中使用标签来进行扫描接口和mapper.xml 代码实现步骤 在mybatis.xml的中使用 123&lt;mappers&gt; &lt;package name=\"com.zhuchuli.mapper\"/&gt;&lt;/mappers&gt; 在com.zhuchuli.mapper新建一个接口 123456789101112public interface LogMapper &#123; List&lt;Log&gt; selAll(); /*** * mybatis把参数转换为map,@Param(\"\")当成key,后面的参数值当成value * @param accin * @param account * @return */ //List&lt;Log&gt; setByAccInAccount(@Param(\"accin\") String accin,@Param(\"account\") String account); List&lt;Log&gt; setByAccInAccount(String accin,String account);&#125; 在com.zhuchuli.mapper新建一个LogMapper.xml文件 12345678910&lt;mapper namespace=\"com.zhuchuli.mapper.LogMapper\"&gt; &lt;select id=\"selAll\" resultType=\"log\"&gt; select * from log &lt;/select&gt; &lt;!-- 当多参数时，不需要写parameter --&gt; &lt;select id=\"setByAccInAccount\" resultType=\"log\"&gt; select * from log where accin=#&#123;arg0&#125; and accout=#&#123;arg1&#125; &lt;!-- select * from log where accin=#&#123;param1&#125; and accout=#&#123;param2&#125; --&gt; &lt;/select&gt;&lt;/mapper&gt; 测试 12345LogMapper logMapper = session.getMapper(LogMapper.class);List&lt;Log&gt; list=logMapper.selAll();for (Log log : list) &#123; System.out.println(log);&#125; 注意：namespace必须和接口的完全限定路径一致，id值必须与接口中的方法名一致。 如果接口中的方法为多个参数，可以省略parameter 多参数实现方法 在接口中声明方法 1List&lt;Log&gt; setByAccInAccount(String accin,String account); 在mapper.xml文件中添加，#{}可以使用[param0,param1,arg0,arg1] 1234&lt;select id=\"setByAccInAccount\" resultType=\"log\"&gt; select * from log where accin=#&#123;arg0&#125; and accout=#&#123;arg1&#125; &lt;!-- select * from log where accin=#&#123;param1&#125; and accout=#&#123;param2&#125; --&gt;&lt;/select&gt; 可以使用注解 在接口中声明方法 1234567/*** * mybatis把参数转换为map,@Param(\"\")当成key,后面的参数值当成value * @param accin * @param account * @return */List&lt;Log&gt; setByAccInAccount(@Param(\"accin\") String accin,@Param(\"account\") String account); 在mapper.xml文件中添加。#{}里面的内容为@param(“内容”)参数中的内容 1select * from log where accin=#&#123;accin&#125; and accout=#&#123;accout&#125; 动态SQL 根据不同的条件需要执行不同的SQl命令，成为动态sql Nybatis中动态sql在mapper.xml添加逻辑判断等 1234567891011&lt;!-- 当多参数时，不需要写parameter --&gt;&lt;select id=\"setByAccInAccount\" resultType=\"log\"&gt; select * from log where 1=1 &lt;!-- OGNL表达式，直接写key或对象的属，不需要添加任何特殊字符 --&gt; &lt;if test=\"accin!=null and accin!='' \"&gt; and accin=#&#123;param1&#125; &lt;/if&gt; &lt;if test=\"accout!=null and accout!=''\"&gt; and accout=#&#123;param2&#125; &lt;/if&gt;&lt;/select&gt; >* 当编写where标签时，如果内容中第一个是and，去掉第一个and。 >* 如果where中有内容会生成where，如果没有内容不会生成where关键字。 >* 比使用if标签少写了1=1 123456789101112&lt;select id=\"setByAccInAccount\" resultType=\"log\"&gt; select * from log &lt;!-- OGNL表达式，直接写key或对象的属，不需要添加任何特殊字符 --&gt; &lt;where&gt; &lt;if test=\"accin!=null and accin!='' \"&gt; and accin=#&#123;param1&#125; &lt;/if&gt; &lt;if test=\"accout!=null and accout!=''\"&gt; and accout=#&#123;param2&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; 只要有一个成立，其他的都不会执行。 代码示例:如果accin和accout都不是Null或不是””，生成的sql中只有where accin=? 1234567891011121314&lt;select id=\"setByAccInAccount\" resultType=\"log\"&gt; select * from log &lt;!-- OGNL表达式，直接写key或对象的属，不需要添加任何特殊字符 --&gt; &lt;where&gt; &lt;choose&gt; &lt;when test=\"accin!=null and accin!=''\"&gt; and accin=#&#123;param1&#125; &lt;/when&gt; &lt;when test=\"accout!=null and accout!=''\"&gt; and accout=#&#123;param2&#125; &lt;/when&gt; &lt;/choose&gt; &lt;/where&gt;&lt;/select&gt; 标签：用在修改SQL中set从句 作用：去掉最后一个逗号 如果里面有内容生成set关键字，没有则不生成 代码示例 : id=#{id} 防止中没有内容。 12345678910111213&lt;update id=\"upd\" parameterType=\"log\"&gt; update log &lt;set&gt; id=#&#123;id&#125;, &lt;if test=\"accIn!=null and accIn!=''\"&gt; accin=#&#123;accIn&#125;, &lt;/if&gt; &lt;if test=\"accOut!=null and accOut!=''\"&gt; accout=#&#123;occOut&#125; &lt;/if&gt; &lt;/set&gt; where id=#&#123;id&#125;&lt;/update&gt; >* prefix 在前面添加内容 >* prefixOverrides：去掉前面内容 >* suffix：在后面添加内容 >* suffixOverrides 去掉后面内容 >* 执行顺序：先去掉内容再添加内容 实现模糊查询 作用：给参数重新赋值 场景：模糊查询，在原内容前后添加内容 标签 循环参数内容，还具备在内容前后添加内容，还具备加分隔符功能 使用场景：in查询中，批量新增中(mybatis中foreach效率较低) 示例 collection=””要遍历的集合 item:迭代变量，#{迭代变量名获取内容} open 循环后左侧要添加的内容 close 循环后右侧要添加的内容 separator 每次循环时，元素之间的分隔符 123456&lt;select id=\"selIn\" parameterType=\"list\"&gt; select * from log where id in &lt;foreach collection=\"list\" item=\"abc\" close=\"\" open=\"\" &gt; #&#123;abc&#125; &lt;/foreach&gt;&lt;/select&gt; 如果希望批量新增，sql命令 1insert into log values(default,1,2),(default,2,3) openSession()必须指定 ExecutorType.BATCH 1SqlSession session=factory.openSession(ExecutorType.BATCH); 某些sql片段，如果希望复用，可以使用定义这个片段 123&lt;sql id=\"mysql\"&gt; id,accin,accout,money&lt;/sql&gt; 在&lt;select&gt;、&lt;delete&gt;、&lt;update&gt;、&lt;insert&gt;中使用标签引用 1select &lt;include refid=\"mysql\"&gt; from log ThreadLocal+OpenSessionInView 线程容器，给线程绑定一个Object内容，后只要线程不变，可以随时取出。 改变内容，无法取出内容123456789101112131415package com.zhuchuli.test;public class Test &#123; public static void main(String[] args) &#123; ThreadLocal&lt;Integer&gt; threadLocal=new ThreadLocal&lt;Integer&gt;(); threadLocal.set(13); new Thread(()-&gt; &#123; threadLocal.set(23); System.out.println(Thread.currentThread().getName()+\"---&gt;\"+threadLocal.get()); &#125;).start(); System.out.println(Thread.currentThread().getName()+\"---&gt;\"+threadLocal.get()); &#125;&#125; 缓存 应用程序和数据库交互的过程是一个相对耗时的过程。 缓存存在的意义：让应用程序减少对数据库的访问，提升程序运行效率。 Mybatis中默认SqlSession缓存开启 同一个SqlSession对象调用同一个&lt;select&gt;时，只有第一次访问数据库，第一次之后把查询结果缓存到SqlSession缓存区(内存)中。 缓存的对象是statement对象。（简单记忆：必须是用一个&lt;select&gt;） 在mybatis时一个&lt;select&gt;对应一个Statement对象. 有效范围必须是同一个SqlSession对象 缓存流程 先去缓存区中找是否存在statement。 返回结果。 如果没有缓存statement对象，去数据库获取数据。 数据库返回查询结果. 把查询结果放到对应的缓存区中。 SqlSessionFactory缓存 二级缓存 有效范围：同一个factory内哪个SqlSession都可以获取。 什么时候使用二级缓存： 当数据频繁被使用，很少被修改 使用二级缓存的步骤，在mapper.xml文件中添加 &lt;cache readOnly=&quot;true&quot;&gt;&lt;/cache&gt; 如果不写 readOnly=&quot;true&quot;,需要把实体类实例化 当SqlSession对象close()时或commit()时会把SqlSession缓存的数据刷到SqlSessionFactory缓存区中。多表查询分类 Mybatis实现多表查询方式： 业务装备：对两个表编写单表查询语句，在业务(Service)把查询的两个结果进行关联. 使用auto mapping特性，在实现两个表联合查询时通过别名完成映射 使用Mybatis的&lt;resultMap&gt;标签进行实现。 多表查询时，类中包含另一类的对象的分类 单个对象 多个对象 &lt;resultMap&gt;标签 该标签写在mapper.xml中，由程序员控制sql查询结果与实体类的映射关系。 默认Mybatis使用auto mapping特性. 使用&lt;resultMap&gt;标签时，&lt;select&gt;标签不写resultType属性，而是使用resultMap属性引用&lt;resultMap&gt;标签 使用resultMap实现单表映射关系 实体类 1234567891011121314151617181920212223package com.zhuchuli.pojo;public class Teacher &#123; private int id1; private String name1; public int getId1() &#123; return id1; &#125; public void setId1(int id1) &#123; this.id1 = id1; &#125; public String getName1() &#123; return name1; &#125; public void setName1(String name1) &#123; this.name1 = name1; &#125; @Override public String toString() &#123; return \"Teacher [id1=\" + id1 + \", name1=\" + name1 + \"]\"; &#125; &#125; TeacherMap.xml 1234567891011&lt;mapper namespace=\"com.zhuchuli.mapper.TeacherMapper\"&gt; &lt;resultMap type=\"teacher\" id=\"mymap\"&gt; &lt;!-- 主键使用id标签配置映射关系--&gt; &lt;id column=\"id\" property=\"id1\"/&gt; &lt;!-- 其它使用result标签配置映射关系 --&gt; &lt;result column=\"name\" property=\"name1\"/&gt; &lt;/resultMap&gt; &lt;select id=\"selAll\" resultMap=\"mymap\"&gt; select * from teacher &lt;/select&gt; &lt;/mapper&gt; 数据库设计 使用resultMap实现关联单个对象(N+1方式) N+1查询方式：先查询出某个表的全部信息，根据这个表的信息查询另一个表的信息。 与业务转配的区别： 在service里面写代码，由mybatis完成转配 实现步骤 在Student实现类中包含一个Teacher对象 1234567public class Student &#123; private int id; private String name; private int age; private int tid; private Teacher teacher;&#125; 在TeacherMapper中提供一个查询： 123&lt;select id=\"selById\" resultType=\"teacher\" parameterType=\"int\"&gt; select * from teacher where id = #&#123;0&#125;&lt;/select&gt; 在StudentMapper中使用： &lt;association&gt;装配一个对象时使用。 property：对象在类中的属性名。 select：通过哪个查询查询这个对象的信息。 column：把当前表的哪个列值最为参数传递给另一个查询。 大前提是使用N+1方式时，如果列名和属性名相同可以不配置，使用Auto mapping特性，但是Mybatis默认只给列装配一次。 12345678910111213&lt;mapper namespace=\"com.zhuchuli.mapper.StudentMapper\"&gt; &lt;resultMap type=\"student\" id=\"stuMap\"&gt; &lt;id property=\"id\" column=\"id\"/&gt; &lt;result property=\"name\" column=\"name\"/&gt; &lt;result property=\"age\" column=\"age\"/&gt; &lt;result property=\"tid\" column=\"tid\"/&gt; &lt;!-- 如果关联一个对象 --&gt; &lt;association property=\"teacher\" select=\"com.zhuchuli.mapper.TeacherMapper.selById\" column=\"tid\"&gt;&lt;/association&gt; &lt;/resultMap&gt; &lt;select id=\"selAll\" resultMap=\"stuMap\"&gt; select * from student &lt;/select&gt;&lt;/mapper&gt; 可以将上面简化为： 123456789101112&lt;mapper namespace=\"com.zhuchuli.mapper.StudentMapper\"&gt; &lt;resultMap type=\"student\" id=\"stuMap\"&gt; &lt;result property=\"tid\" column=\"tid\"/&gt; &lt;!-- 如果关联一个对象 --&gt; &lt;association property=\"teacher\" select=\"com.zhuchuli.mapper.TeacherMapper.selById\" column=\"tid\"&gt;&lt;/association&gt; &lt;/resultMap&gt; &lt;select id=\"selAll\" resultMap=\"stuMap\"&gt; select * from student &lt;/select&gt;&lt;/mapper&gt; 使用&lt;resultMap&gt;查询关联集合对象（N+1） 在Teacher中添加List&lt;Student&gt; 12345public class Teacher &#123; private int id; private String name; private List&lt;Student&gt; list;&#125; 在StudentMapper.xml中添加通过tid查询 123&lt;select id=\"selByTid\" resultType=\"student\" parameterType=\"int\"&gt; select * from student where tid = #&#123;0&#125;&lt;/select&gt; 在TeacherMapper.xml中添加查询全部 &lt;collection&gt;当属性是集合类型时使用的标签 1234567891011121314&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.zhuchuli.mapper.TeacherMapper\"&gt; &lt;resultMap type=\"teacher\" id=\"mymap\"&gt; &lt;id column=\"id\" property=\"id\"/&gt; &lt;result column=\"name\" property=\"name\"/&gt; &lt;collection property=\"list\" ofType=\"student\" select=\"com.zhuchuli.mapper.StudentMapper.selByTid\" column=\"id\"&gt;&lt;/collection&gt; &lt;/resultMap&gt; &lt;select id=\"selAll\" resultMap=\"mymap\"&gt; select * from teacher &lt;/select&gt;&lt;/mapper&gt; 使用&lt;resultMap&gt;实现加载集合数据（联合查询方式） 在TeacherMapper.xml添加 mybatis可以通过主键判断对象是否被加载过 不需要担心重复创建Teacher 12345678910111213&lt;resultMap type=\"teacher\" id=\"mymap1\"&gt; &lt;id column=\"tid\" property=\"id\"/&gt; &lt;result column=\"tname\" property=\"name\"/&gt; &lt;collection property=\"list\" ofType=\"student\"&gt; &lt;id column=\"sid\" property=\"id\"/&gt; &lt;result column=\"sname\" property=\"name\"/&gt; &lt;result column=\"age\" property=\"age\"/&gt; &lt;result column=\"tid\" property=\"tid\"/&gt; &lt;/collection&gt;&lt;/resultMap&gt;&lt;select id=\"selAll1\" resultMap=\"mymap1\"&gt; select t.id tid,t.name tname,s.id sid,s.name sname,age,tid from teacher t left join student s on t.id = s.tid&lt;/select&gt; AutoMapping 结合别名实现多表查询 只能使用多表联合查询 查询出的列名与属性名必须相同 实现方式： .在sql是关键字，两侧添加反单引号 这个方法只适合对象的查询，不适合list集合的查询 123456789&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.zhuchuli.mapper.StudentMapper\"&gt; &lt;select id=\"selAll\" resultType=\"student\"&gt; select t.id `teacher.id`,t.name `teacher.name`,s.id id,s.name name,age,tid from student s left join teacher t on t.id = s.tid &lt;/select&gt;&lt;/mapper&gt; Mybatis 注解 注解：就是为了简化配置文件 Mybatis的注解简化Mapper.xml文件 如果涉及动态SQL依然使用mapper.xml mapper.xml和注解可以共存。 使用注解时mybatis.xml中&lt;mapper&gt;的使用: &lt;package/&gt; &lt;mapper class=&quot;&quot;&gt; 实现查询、修改、新增、删除等功能 12345678910111213141516171819@Select(\"select * from teacher\") List&lt;Teacher&gt; selAll(); @Insert(\"insert into teacher(id,name) values(default,#&#123;name&#125;)\") int insTeacher(Teacher teacher); @Update(\"update teacher set name=#&#123;name&#125; where id=#&#123;id&#125;\") int updTeacher(Teacher teacher); @Delete(\"delete from teacher where id=#&#123;0&#125;\") int delTeacher(int id); @Results(value =&#123; @Result(id=true,property=\"id\",column=\"id\"), @Result(property=\"name\",column=\"name\"), @Result(property=\"list\",column=\"id\",many=@Many(select=\"com.zhuchuli.mapper.StudentMapper.selById\")) &#125;) @Select(\"select * from teacher\") List&lt;Teacher&gt; selTeacher(); @Results()：相当于&lt;resultMap&gt; @result()：相当于&lt;id/&gt;或&lt;result/&gt; @Result(id=true)：相当于&lt;id/&gt; @Many：相当于&lt;collection/&gt; @One：相当于&lt;association/&gt; Mybatis运行原理 运行过程中可能遇到的类： Resources：Mybatis中IO流的工具类。 作用：负责加载配置文件 SqlSessionFactoryBuilder()：构造器 作用：创建SqlSessionFactory接口的实现类 XMLConfigBuilder：Mybatis全局配置文件内容构造器类 负责读取流内容并转换为Java代码 Configuration 封装了全局配置文件所有配置信息。 全局配置文件内容都存在该对象中。 DefaultSqlSessionFactory是SqlSessionFactory接口的实现类。 Transaction 事务类 每一个SqlSession都会带一个Transaction对象 TransactionFactory 事务工厂 负责创建Transaction对象 Executor Mybatis执行器 作用：负责执行SQL语句 相当于JDBC中的statement对象（或PreperedStatement或CallableStatement） 默认的执行器SimpleExecutor 批量操作：BatchExecutor 通过openSession(参数控制) DefaultSqlSession是SqlSession接口的实现类 ExceptionFactory：Mybatis中错误异常工厂 Spring全家桶 SpringData SpringCloud SpringBoot SpringSession","categories":[{"name":"back-end","slug":"back-end","permalink":"https://CPWS.github.io/categories/back-end/"}],"tags":[{"name":"Mybatis3","slug":"Mybatis3","permalink":"https://CPWS.github.io/tags/Mybatis3/"}]},{"title":"Hibernate4","slug":"Hibernate4","date":"2019-10-07T02:16:21.000Z","updated":"2019-12-05T08:59:13.055Z","comments":true,"path":"2019/10/07/Hibernate4/","link":"","permalink":"https://CPWS.github.io/2019/10/07/Hibernate4/","excerpt":"","text":"第一讲 Hibernate简介 Hibernate是一个轻量级、ORM的框架。完成数据的持久化。是对jdbc的封装，简化jdbc操作。使用Hibernate后，不需要编写Sql语句，是一个全自动的持久化框架。使用Hibernate后，可以跨数据库平台。提高开发效率。 持久化：就是数据从瞬时状态变为持久状态的过程。 ORM：Object Relational Mapping，对象关系映射.使得操作关系可以像操作对象一样方便。 结构体系 第二讲 helloworld 使用hibernate进行helloworld程序开发，步骤： 新建Java项目 导入hibernate jar包 新建数据库表 新建pojo对象 编写User.hbm.xml 12345678910111213141516&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC \"-//Hibernate/Hibernate Mapping DTD 3.0//EN\" \"http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd\"&gt;&lt;hibernate-mapping&gt; &lt;class name=\"com.zhuchuli.vo.User\" table=\"t_user\"&gt; &lt;!-- 主键映射 --&gt; &lt;id name=\"id\" column=\"id\" type=\"int\"&gt; &lt;!-- 主键生成策略 --&gt; &lt;generator class=\"native\"/&gt; &lt;/id&gt; &lt;property name=\"name\" column=\"name\" type=\"java.lang.String\"&gt;&lt;/property&gt; &lt;property name=\"age\" column=\"age\" type=\"int\"&gt;&lt;/property&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 在src包下新建hibernate.cfg.xml 123456789101112131415&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE hibernate-configuration PUBLIC \"-//Hibernate/Hibernate Configuration DTD 3.0//EN\" \"http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd\"&gt;&lt;hibernate-configuration&gt; &lt;session-factory&gt; &lt;property name=\"connection.driver_class\"&gt;com.mysql.cj.jdbc.Driver&lt;/property&gt; &lt;property name=\"connection.url\"&gt;jdbc:mysql://localhost:3306/hibernate4?serverTimezone=UTC&lt;/property&gt; &lt;property name=\"connection.username\"&gt;root&lt;/property&gt; &lt;property name=\"connection.password\"&gt;123456&lt;/property&gt; &lt;!-- 指定数据库的方言 --&gt; &lt;property name=\"dialect\"&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt; &lt;mapping resource=\"com/zhuchuli/vo/User.hbm.xml\"/&gt; &lt;/session-factory&gt;&lt;/hibernate-configuration&gt; 测试 12345678910111213141516171819202122232425262728293031package com.zhuchuli.test;import org.hibernate.Session;import org.hibernate.SessionFactory;import org.hibernate.boot.registry.StandardServiceRegistryBuilder;import org.hibernate.cfg.Configuration;import org.hibernate.service.ServiceRegistry;import com.zhuchuli.vo.User;public class HiberatorTest &#123; public static void main(String[] args) &#123; //1.读取hibrator.cfg.xml配置文件 Configuration cfg=new Configuration().configure(); //2.创建服务注册 ServiceRegistry registery=new StandardServiceRegistryBuilder() .applySettings(cfg.getProperties()) .build(); //3.新建sessionFactory对象 SessionFactory factory=cfg.buildSessionFactory(registery); //4.创建session对象 Session session=factory.openSession(); //5.获取数据 User user=(User) session.get(User.class,1); System.out.println(user); //6.释放资源 session.close(); factory.close(); &#125;&#125; 第三讲 配置文件讲解 hibernate.cfg.xml是hibernate的主配置文件,Configuration读取的也是该对象。 1234567891011121314151617181920212223242526&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE hibernate-configuration PUBLIC \"-//Hibernate/Hibernate Configuration DTD 3.0//EN\" \"http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd\"&gt;&lt;hibernate-configuration&gt; &lt;session-factory&gt; &lt;!-- 数据库连接信息 根据不同的数据库，要配置不同参数信息。 --&gt; &lt;property name=\"connection.driver_class\"&gt;com.mysql.cj.jdbc.Driver&lt;/property&gt; &lt;property name=\"connection.url\"&gt;jdbc:mysql://localhost:3306/hibernate4?serverTimezone=UTC&lt;/property&gt; &lt;property name=\"connection.username\"&gt;root&lt;/property&gt; &lt;property name=\"connection.password\"&gt;123456&lt;/property&gt; &lt;!-- 通用配置 --&gt; &lt;!-- 指定数据库的方言 --&gt; &lt;property name=\"dialect\"&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt; &lt;!-- 打印sql语句 --&gt; &lt;property name=\"show_sql\"&gt;true&lt;/property&gt; &lt;!-- 格式化sql语句 --&gt; &lt;property name=\"format_sql\"&gt;true&lt;/property&gt; &lt;!-- 映射文件信息 --&gt; &lt;mapping resource=\"com/zhuchuli/vo/User.hbm.xml\"/&gt; &lt;/session-factory&gt;&lt;/hibernate-configuration&gt; 映射文件：Xxx-hbm.xml 非关系型数据库：MongoDB、HBase、redis 《组成原理》《编译原理》 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC \"-//Hibernate/Hibernate Mapping DTD 3.0//EN\" \"http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd\"&gt;&lt;!-- package用于指定类所在的包，如果不指定，那么在指定class的name时，需要指定完全限定名 --&gt;&lt;hibernate-mapping package=\"com.zhuchuli.vo\"&gt; &lt;!-- class指定类的映射信息 name指定类，如果没有指定package时需要使用完全限定名 table指定类对应的数据库的数据表名，如果不指定，默认和类型相同。 schema:指定模式 --&gt; &lt;class name=\"User\" table=\"t_user\" schema=\"\"&gt; &lt;!-- 主键映射 在hibernate中，类所对应的表必须要有主键 name:为类所的属性名 column:是属性名所对应的表的字段名称，类型是属性的类型 column默认很属性名一致，类型默认和属性的类型一致。 length 指定长度 --&gt; &lt;id name=\"id\" column=\"id\" type=\"int\"&gt; &lt;!-- 主键生成策略 Oracle数据库 自增生成策略 &lt;generator class=\"sequence\"&gt; &lt;param name=\"sequence\"&gt;user_seq&lt;/param&gt; &lt;/generator&gt; UUID：生成的字符串唯一 hilo：使用一个高/低位算法高效生成long，short或int类型的标识符 assign:自己输入主键 forign： --&gt; &lt;generator class=\"native\"/&gt; &lt;/id&gt; &lt;!-- property 指定属性的映射 --&gt; &lt;property name=\"name\" column=\"name\" type=\"java.lang.String\"&gt;&lt;/property&gt; &lt;property name=\"age\" column=\"age\" type=\"int\"&gt;&lt;/property&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 第四讲 工具类及hibernate crud操作 工具类Util 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.zhuchuli.util;import org.hibernate.Session;import org.hibernate.SessionFactory;import org.hibernate.boot.registry.StandardServiceRegistryBuilder;import org.hibernate.cfg.Configuration;import org.hibernate.service.ServiceRegistry;public class HibernateUtil &#123; private static Configuration cfg=null; private static ServiceRegistry registery=null; private static SessionFactory factory=null; private static ThreadLocal&lt;Session&gt; sessionLocal=null; static &#123; cfg=new Configuration().configure(); registery=new StandardServiceRegistryBuilder() .applySettings(cfg.getProperties()) .build(); /*** * sessionFactory是一个重量级对象，在一个应用中只需一个即可。是一个 * 进程级别对象，可以在集群中使用。 * 操作完后一般不会释放资源。 */ factory=cfg.buildSessionFactory(registery); sessionLocal=new ThreadLocal&lt;Session&gt;(); &#125; public static Session getSession() &#123; if( sessionLocal.get()!=null &amp;&amp; !sessionLocal.get().isOpen()) &#123; sessionLocal.set(null); &#125; if(sessionLocal.get() == null) &#123; sessionLocal.set(factory.openSession()); &#125; return sessionLocal.get(); &#125; //释放资源 public static void close() &#123; if(sessionLocal.get()!=null) &#123; sessionLocal.get().close(); sessionLocal.set(null); &#125; &#125;&#125; crud操作 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091package com.zhuchuli.hibernate.test;import org.hibernate.Session;import org.hibernate.Transaction;import com.zhuchuli.util.HibernateUtil;import com.zhuchuli.vo.User;public class HibernateTest &#123; public static void main(String[] args) &#123; &#125; //删除 先查后删除。 private static void delete() &#123; Session session=null; Transaction tx=null; try &#123; //获取Session对象 session= HibernateUtil.getSession(); //获取事务并且开启事务 tx= session.beginTransaction(); User user=(User) session.get(User.class, 4); //删除 session.delete(user); //提交事务 tx.commit(); &#125; catch (Exception e) &#123; e.printStackTrace(); if(tx!=null) &#123; tx.rollback(); &#125; &#125;finally &#123; HibernateUtil.close(); &#125; &#125; //修改数据 先查在修改最后再删除 private static void update() &#123; Session session=null; Transaction tx=null; try &#123; //获取Session对象 session= HibernateUtil.getSession(); //获取事务并且开启事务 tx= session.beginTransaction(); User user=(User) session.get(User.class, 4); System.out.println(user); user.setName(\"小六六\"); //修改 session.save(user); //提交事务 tx.commit(); &#125; catch (Exception e) &#123; e.printStackTrace(); if(tx!=null) &#123; tx.rollback(); &#125; &#125;finally &#123; HibernateUtil.close(); &#125; &#125; // //增加数据 private static void save() &#123; Session session=null; Transaction tx=null; try &#123; //获取Session对象 session= HibernateUtil.getSession(); //获取事务并且开启事务 tx= session.beginTransaction(); /* 下面两句话等同上面一句话 Transaction tx=session.getTransaction(); tx.begin(); */ User user = new User(); user.setName(\"刘德华\"); user.setAge(53); //保存数据 session.save(user); //提交事务 tx.commit(); &#125; catch (Exception e) &#123; e.printStackTrace(); if(tx!=null) &#123; tx.rollback(); &#125; &#125;finally &#123; HibernateUtil.close(); &#125; &#125;&#125; 第五讲 软件工程步骤： 需要分析、概要分析、详细分析、编程、测试、发布 测试: 黑盒测试：工人测试。 白盒测试：Junit，需要编码实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.zhuchuli.test;import org.hibernate.Session;import org.hibernate.Transaction;import org.junit.After;import org.junit.Before;import org.junit.Test;import com.zhuchuli.util.HibernateUtil;import com.zhuchuli.vo.User;public class HibernateTest &#123; private Session session=null; private Transaction tx=null; @Before public void setUp() &#123; try &#123; //获取Session对象 session = HibernateUtil.getSession(); //获取事务并且开启事务 tx = session.beginTransaction(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; @After public void tear() &#123; HibernateUtil.close(); &#125; @Test public void testSave() &#123; try &#123; User user = new User(); user.setName(\"张学友\"); user.setAge(53); //保存数据 session.save(user); //提交事务 tx.commit(); &#125; catch (Exception e) &#123; e.printStackTrace(); if(tx!=null) &#123; tx.rollback(); &#125; &#125; &#125;&#125; 第六讲 对象生命周期 对象生命周期图 两种路线 new —&gt; 瞬时状态 —&gt; save() —&gt; 持久状态 —&gt; close() —&gt; 游离状态。 1234567891011121314151617181920212223242526272829//测试对象生命周期：第一条线路@Testpublic void testSession1() &#123; User user=null; try &#123; //user处于瞬时状态 user = new User(); user.setName(\"kkk\"); user.setAge(40); //user处于持久状态 //对象处于持久状态时被session管理 session.save(user); //对象处于持久状态时，提交事务前会将session中对象与数据库中的记录进行脏数据检查，如果不一致则进行数据同步。 //user.setAge(23);//此时会自动调用update() //提交事务 tx.commit(); &#125; catch (Exception e) &#123; e.printStackTrace(); if(tx!=null) &#123; tx.rollback(); &#125; &#125; //请除指定对象 ----&gt; session不再管理user //user此时处于游离状态，可能会把垃圾回收站回收。 session.evict(user); //close关闭session session.close(); //clear清楚session所有对象&#125; Get —&gt; 持久状态 —&gt; clear —&gt; 游离状态 —&gt; update() —&gt; 持久状态 –&gt; delete() —&gt; 瞬时状态 12345678910111213141516171819//测试对象生命周期：第二条线路@Testpublic void testSession2() &#123; User user=null; try &#123; //user对象被session管理，处于持久状态 user=(User) session.get(User.class, 1); //调用clear后，session不在管理user，user处理游离状态 session.clear(); user.setName(\"ddd\");//此时处于游离状态，所有数据库的数据不会发生改变 session.update(user);//重回持久状态,user对象被session管理. session.delete(user);//删除后user对象处于瞬时状态。 tx.commit(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; 总结 瞬时状态 session没有，数据库没有 持久状态 session有，数据库有,在该状态下会进行脏数据的读取 游离状态 session没有，数据库有 第七讲 hibernate与struts2框架的整合第八讲 关联映射之单向多对一 SchemaExport工具类 123456789101112/**** 将对象信息 转换为 关系信息*/@Testpublic void testCreateDB() &#123; Configuration cfg=new Configuration().configure(); //使得hibernate映射信息转化为ddl(数据库定义语言) SchemaExport se = new SchemaExport(cfg); //第一参数：是否打印ddl语句 //第二个参数：是否将ddl到数据库执行 se.create(true, true);&#125; 通用配置实现hbm to ddl 1234567&lt;!-- hbm2ddl.auto：该属性用于配置 是否将映射信息转换为关系信息 create：每次执行都会删除表再创建表 update：先检查数据库中表是否存在，如果不存在则先创建表，通常使用update create-drop：--&gt;&lt;property name=\"hbm2ddl.auto\"&gt;create&lt;/property&gt; 类与类之间的关系 依赖 –&gt; 关联 –&gt; 组合 –&gt; 聚合 学生和班级的信息是一个多对一的关系 表结构 类结构： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.zhuchuli.vo;import java.io.Serializable;/*** * 学生类 * @author 朱楚利 * */public class Student implements Serializable&#123; private int id; private String name; private int age; private String sex; //学生所对应的班级 private Cluss cluss; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125; public Cluss getCluss() &#123; return cluss; &#125; public void setCluss(Cluss cluss) &#123; this.cluss = cluss; &#125; &#125; 123456789101112131415161718192021222324252627282930313233package com.zhuchuli.vo;import java.io.Serializable;/*** * 班级类 * @author 朱楚利 * */public class Cluss implements Serializable&#123; private int id; private String name; private String address; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125; &#125; 映射文件 班级映射文件:Cluss_hbm.xml 123456789&lt;hibernate-mapping package=\"com.zhuchuli.vo\"&gt; &lt;class name=\"Cluss\" table=\"t_class\"&gt; &lt;id name=\"id\"&gt; &lt;generator class=\"native\"&gt;&lt;/generator&gt; &lt;/id&gt; &lt;property name=\"name\"&gt;&lt;/property&gt; &lt;property name=\"address\"&gt;&lt;/property&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; OpenSessionInView组合主键 学生管理系统中，成绩表的主键组合主键。 表结构 组合主键在Hibernate中类的结构有3种 类结构1：Result.java 123456789101112131415161718192021222324public class Result implements Serializable&#123; private int stuId; private int subId; private double score; public int getStuId() &#123; return stuId; &#125; public void setStuId(int stuId) &#123; this.stuId = stuId; &#125; public int getSubId() &#123; return subId; &#125; public void setSubId(int subId) &#123; this.subId = subId; &#125; public double getScore() &#123; return score; &#125; public void setScore(double score) &#123; this.score = score; &#125; &#125; 类的结构2 ResultPK.java、Result.java 123456789101112131415public class ResultPK implements Serializable &#123; private int stuId; private int subId; public int getStuId() &#123; return stuId; &#125; public void setStuId(int stuId) &#123; this.stuId = stuId; &#125; public int getSubId() &#123; return subId; &#125; public void setSubId(int subId) &#123; this.subId = subId; &#125; 12345678910111213141516171819202122232425/*** * 如果组合主键的字段是类的属性时，该类必须实现Serializable * @author 1huangzewei * */public class Result implements Serializable&#123; private double score; private ResultPK id; public ResultPK getId() &#123; return id; &#125; public void setId(ResultPK id) &#123; this.id = id; &#125; public double getScore() &#123; return score; &#125; public void setScore(double score) &#123; this.score = score; &#125; &#125; 类的结构3 Student、Subject是一个单独的类，需要把它们配置成Result的成员变量。 12345678910111213141516171819package com.zhuchuli.vo;public class Student &#123; private int id; private String name; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; &#125; 123456789101112131415161718192021222324252627282930/*** * 如果组合主键的字段是类的属性时，该类必须实现Serializable * @author 1huangzewei * */public class Result implements Serializable&#123; private Student student; private Subject subject; private double score; public Student getStudent() &#123; return student; &#125; public void setStudent(Student student) &#123; this.student = student; &#125; public Subject getSubject() &#123; return subject; &#125; public void setSubject(Subject subject) &#123; this.subject = subject; &#125; public double getScore() &#123; return score; &#125; public void setScore(double score) &#123; this.score = score; &#125; &#125; 12345678910111213141516171819package com.zhuchuli.vo;public class Subject &#123; private int id; private String name; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; &#125; 映射文件 类结构1 相匹配的映射文件： Result.hbm.xml 123456789101112&lt;hibernate-mapping package=\"com.zhuchuli.vo\"&gt; &lt;class name=\"Result\" table=\"t_result\"&gt; &lt;!-- 组合主键映射 --&gt; &lt;composite-id&gt; &lt;key-property name=\"stuId\"&gt;&lt;/key-property&gt; &lt;key-property name=\"subId\"&gt;&lt;/key-property&gt; &lt;/composite-id&gt; &lt;!-- property 指定属性的映射 --&gt; &lt;property name=\"score\"&gt;&lt;/property&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 类结构2 相匹配的映射文件： Result.hbm.xml 123456789101112&lt;hibernate-mapping package=\"com.zhuchuli.vo\"&gt; &lt;class name=\"Result\" table=\"t_result\"&gt; &lt;!-- 组合主键映射 --&gt; &lt;composite-id name=\"id\" class=\"ResultPK\"&gt; &lt;key-property name=\"stuId\"&gt;&lt;/key-property&gt; &lt;key-property name=\"subId\"&gt;&lt;/key-property&gt; &lt;/composite-id&gt; &lt;!-- property 指定属性的映射 --&gt; &lt;property name=\"score\"&gt;&lt;/property&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 类结构3 相匹配的映射文件： Result.hbm.xml、Student.hbml.xml、Subject.hbm.xml 12345678910111213&lt;!-- package用于指定类所在的包，如果不指定，那么在指定class的name时，需要指定完全限定名 --&gt;&lt;hibernate-mapping package=\"com.zhuchuli.vo\"&gt; &lt;class name=\"Result\" table=\"t_result\"&gt; &lt;!-- 组合主键映射 --&gt; &lt;composite-id&gt; &lt;key-many-to-one name=\"student\" column=\"stuId\"&gt;&lt;/key-many-to-one&gt; &lt;key-many-to-one name=\"subject\" column=\"subId\"&gt;&lt;/key-many-to-one&gt; &lt;/composite-id&gt; &lt;!-- property 指定属性的映射 --&gt; &lt;property name=\"score\"&gt;&lt;/property&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 12345678&lt;hibernate-mapping package=\"com.zhuchuli.vo\"&gt; &lt;class name=\"Student\" table=\"t_student\"&gt; &lt;id name=\"id\"&gt; &lt;generator class=\"native\"&gt;&lt;/generator&gt; &lt;/id&gt; &lt;property name=\"name\"&gt;&lt;/property&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 123456789&lt;!-- package用于指定类所在的包，如果不指定，那么在指定class的name时，需要指定完全限定名 --&gt;&lt;hibernate-mapping package=\"com.zhuchuli.vo\"&gt; &lt;class name=\"Subject\" table=\"t_subject\"&gt; &lt;id name=\"id\"&gt; &lt;generator class=\"native\"&gt;&lt;/generator&gt; &lt;/id&gt; &lt;property name=\"name\"&gt;&lt;/property&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 测试 类结构1、类结构2、类结构3测试 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class HibernateTest &#123; private Session session=null; private Transaction tx=null; @Before public void setUp() &#123; try &#123; //获取Session对象 session = HibernateUtil.getSession(); //获取事务并且开启事务 tx = session.beginTransaction(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; @After public void tear() &#123; HibernateUtil.close(); &#125; /*** * 将对象信息 转换为 关系信息 */ @Test public void testCreateDB() &#123; Configuration cfg=new Configuration().configure(); //使得hibernate映射信息转化为ddl(数据库定义语言) SchemaExport se = new SchemaExport(cfg); //第一参数：是否打印ddl语句 //第二个参数：是否将ddl到数据库执行 se.create(true, true); &#125; @Test public void testInit() &#123; try &#123; Result r=new Result(); r.setStuId(1); r.setSubId(1); r.setScore(70); session.save(r); tx.commit(); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); if(tx!=null)tx.rollback(); &#125; &#125; @Test public void testGet() &#123; Result r=new Result(); r.setStuId(1); r.setSubId(1); Result r1=(Result) session.get(Result.class,r); System.out.println(r1.getScore()); &#125; &#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class HibernateTest &#123; private Session session=null; private Transaction tx=null; @Before public void setUp() &#123; try &#123; //获取Session对象 session = HibernateUtil.getSession(); //获取事务并且开启事务 tx = session.beginTransaction(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; @After public void tear() &#123; HibernateUtil.close(); &#125; /*** * 将对象信息 转换为 关系信息 */ @Test public void testCreateDB() &#123; Configuration cfg=new Configuration().configure(); //使得hibernate映射信息转化为ddl(数据库定义语言) SchemaExport se = new SchemaExport(cfg); //第一参数：是否打印ddl语句 //第二个参数：是否将ddl到数据库执行 se.create(true, true); &#125; @Test public void testInit() &#123; try &#123; ResultPK pk=new ResultPK(); pk.setStuId(1); pk.setSubId(1); Result r=new Result(); r.setId(pk); r.setScore(70); session.save(r); tx.commit(); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); if(tx!=null)tx.rollback(); &#125; &#125; @Test public void testGet() &#123; ResultPK pk=new ResultPK(); pk.setStuId(1); pk.setSubId(1); Result r1=(Result) session.get(Result.class,pk); System.out.println(r1.getScore()); &#125; &#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class HibernateTest &#123; private Session session=null; private Transaction tx=null; @Before public void setUp() &#123; try &#123; //获取Session对象 session = HibernateUtil.getSession(); //获取事务并且开启事务 tx = session.beginTransaction(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; @After public void tear() &#123; HibernateUtil.close(); &#125; /*** * 将对象信息 转换为 关系信息 */ @Test public void testCreateDB() &#123; Configuration cfg=new Configuration().configure(); //使得hibernate映射信息转化为ddl(数据库定义语言) SchemaExport se = new SchemaExport(cfg); //第一参数：是否打印ddl语句 //第二个参数：是否将ddl到数据库执行 se.create(true, true); &#125; @Test public void testInit() &#123; try &#123; Student student=(Student) session.get(Student.class, 1); Subject subject=(Subject) session.get(Subject.class, 1); Result result=new Result(); result.setStudent(student); result.setSubject(subject); result.setScore(80); session.save(result); tx.commit(); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); if(tx!=null)tx.rollback(); &#125; &#125; @Test public void testGet() &#123; Student student=(Student) session.get(Student.class, 1); Subject subject=(Subject) session.get(Subject.class, 1); Result result=new Result(); result.setStudent(student); result.setSubject(subject); Result r1=(Result) session.get(Result.class,result); System.out.println(r1.getScore()); &#125; &#125; 有序集合映射（List） 有序集合映射 表结构 indx为有序值：idx 类结构 Cluss.java 12345678910111213141516171819202122232425262728293031public class Cluss implements Serializable&#123; private int id; private String name; private String address; private List&lt;Student&gt; students=new ArrayList&lt;Student&gt;(); public int getId() &#123; return id; &#125; public List&lt;Student&gt; getStudents() &#123; return students; &#125; public void setStudents(List&lt;Student&gt; students) &#123; this.students = students; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125; &#125; Student.java 1234567891011121314151617181920212223242526272829303132public class Student implements Serializable&#123; private int id; private String name; private int age; private String sex; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125; &#125; 映射文件 Cluss.hbm.xml 1234567891011121314151617&lt;hibernate-mapping package=\"com.zhuchuli.vo\"&gt; &lt;class name=\"Cluss\" table=\"t_class\"&gt; &lt;id name=\"id\"&gt; &lt;generator class=\"native\"&gt;&lt;/generator&gt; &lt;/id&gt; &lt;property name=\"name\"&gt;&lt;/property&gt; &lt;property name=\"address\"&gt;&lt;/property&gt; &lt;list name=\"students\"&gt; &lt;key column=\"cluss_id\"&gt;&lt;/key&gt; &lt;!-- 有序列 顺序有hibernate来维护 --&gt; &lt;list-index base=\"1\" column=\"idx\"&gt;&lt;/list-index&gt; &lt;one-to-many class=\"Student\"/&gt; &lt;/list&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; Student.hbm.xml 1234567891011121314&lt;!-- package用于指定类所在的包，如果不指定，那么在指定class的name时，需要指定完全限定名 --&gt;&lt;hibernate-mapping package=\"com.zhuchuli.vo\"&gt; &lt;class name=\"Student\" table=\"t_student\" schema=\"\"&gt; &lt;id name=\"id\"&gt; &lt;generator class=\"native\"/&gt; &lt;/id&gt; &lt;!-- property 指定属性的映射 --&gt; &lt;property name=\"name\"/&gt; &lt;property name=\"age\" /&gt; &lt;property name=\"sex\" /&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 测试12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576public class HibernateTest &#123; private Session session=null; private Transaction tx=null; @Before public void setUp() &#123; try &#123; //获取Session对象 session = HibernateUtil.getSession(); //获取事务并且开启事务 tx = session.beginTransaction(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; @After public void tear() &#123; HibernateUtil.close(); &#125; /*** * 将对象信息 转换为 关系信息 */ @Test public void testCreateDB() &#123; Configuration cfg=new Configuration().configure(); //使得hibernate映射信息转化为ddl(数据库定义语言) SchemaExport se = new SchemaExport(cfg); //第一参数：是否打印ddl语句 //第二个参数：是否将ddl到数据库执行 se.create(true, true); &#125; @Test public void testInit() &#123; try &#123; Student s1=new Student(); s1.setName(\"张三\"); s1.setAge(23); s1.setSex(\"男\"); Student s2=new Student(); s2.setName(\"李四\"); s2.setAge(21); s2.setSex(\"男\"); Student s3=new Student(); s3.setName(\"王小蒙\"); s3.setAge(20); s3.setSex(\"女\"); session.save(s1); session.save(s2); session.save(s3); Cluss c1=new Cluss(); c1.setName(\"D-201\"); c1.setAddress(\"d-201\"); Cluss c2=new Cluss(); c2.setName(\"C-201\"); c2.setAddress(\"c-201\"); c1.getStudents().add(s1); c1.getStudents().add(s3); c2.getStudents().add(s2); session.save(c1); session.save(c2); tx.commit(); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); if(tx!=null)tx.rollback(); &#125; &#125; @Test public void testGet() &#123; Cluss c1=(Cluss) session.get(Cluss.class,1); System.out.println(c1.getName() + \"\\t\" +c1.getAddress()); System.out.println(\"------------------------------\"); for (Student s : c1.getStudents()) &#123; System.out.println(s.getName() + \"\\t\" + s.getSex() + \"\\t\" + s.getAge()); &#125; &#125;&#125; cascade 和 inverse cascade 级联:操作一个对象时，可以附带操作关联对象1&lt;many-to-one name=\"card\" column=\"card_id\" cascade=\"save-update\"&gt;&lt;/many-to-one&gt; 在many-to-one中 将级联设置为save-update，意味着在保存多的一端数据时，会检查关联对象，如果关联对象没有保存或更新，那么级联会将关联对象保存和更新.如果cascase值为delete，那么会级联将关联对象删除，如果有多个记录关联同一个级联对象时会报错，不建议设置为delete，如果值为all,所有相关动作都会级联，建议在many-to-one时设置save-update. 1234&lt;set name=\"students\" cascade=\"save-update\"&gt; &lt;key column=\"cluss_id\"&gt;&lt;/key&gt; &lt;one-to-many class=\"Student\"/&gt;&lt;/set&gt; 在one-to-many中，如果cascase是save-update，会级联保存多的一端数据，前提要在一的一端设置关联对象，但是会多出n条update语句，所以不建议在一的一端设置为save-update，如果cascase值为delete，会级联会删除多的一端的数据。一般情况下不会设置delete，在企业中，删除大多数为虚拟删除。 invers：反e转，表示控制关系（外健）由谁来管理。多的一方默认是管理（外健）的，一的一方默认也是管理关系的。但是一的一方可以设置inverse=true，让另一方来控制关系，有一的一方控制关系，那么在管理关系会发出update语句。invserse控制是谁来管理关系。cascade控制如何级联操作。 hql HQL:hibernate query language:hibernate的查询语句，是一种完全面向对象的查询语言。编写Hql语句 和 sql几乎相同 ，关键字都一样，不区分大小写，hql查询的是类，不是表，字段写属性名，而不是表中字段名 Criteria查询 完全面向对象查询 本地sql Hibernate支持跨数据平台，导致一些数据库特有的功能Hibernate不支持。所以Hibernate提供了解决方法，那就是使用本地sql进行查询 –hibernate支持使用sql进行。 过滤器 过滤器：处理具有“显性(visibility)”规则的数据 使用Hibernate filter。 Hibernate filter是全局有效的、具有名字、可以带参数的过滤器， 对于某个特定的Hibernate session您可以选择是否启用（或禁用）某个过滤器。 使用步骤 定义过滤器 12345&lt;!-- 过滤器的定义 name是过滤器的名称 全局唯一 --&gt;&lt;filter-def name=\"userFilter\"&gt; &lt;!-- 过滤器可以携带参数，需要指定参数的名称和类型 --&gt; &lt;filter-param name=\"age\" type=\"int\"/&gt;&lt;/filter-def&gt; 在类的映射文件中引用过滤器 12&lt;!-- 引用过滤器时 需要指定名称和条件 --&gt;&lt;filter name=\"userFilter\" condition=\"age&gt;:age\"&gt;&lt;/filter&gt; 在类中的应用 1234567891011/*** * 过滤器的使用 */@Testpublic void testFilter() &#123; session.enableFilter(\"userFilter\").setParameter(\"age\",20); List&lt;User&gt; users=session.createQuery(\"from User\").list(); for (User user : users) &#123; System.out.println(user.getName() + \"\\t\" + user.getAge()); &#125;&#125; 加载策略和抓取策略 加载策略指hibernate如何查询数据，加载策略有两种方式：一种是即时架加载，一种是延迟加载。 即时加载策略是指调用方法立即到数据库查询。 get方法：是属于即时加载策略 12345678/** * get()是属于及时加载，获取数据时，如果不存在返回null */@Testpublic void testGet() &#123; User user=(User)session.get(User.class, 1); System.out.println(user.getName());&#125; List()方法也属性即时加载策略 123456789/** * 测试List：该方法也是及时加载 */@Testpublic void testList() &#123; List&lt;User&gt; users=session.createQuery(\"from User\").list(); System.out.println(\"----------------\"); System.out.println(users.size());&#125; 即时记载在需要立即使用数据时使用。— 响应速度比较快。 延迟加载又称为懒加载 —&gt; 懒加载可以提供系统使用率，在调用方法时不会立即到数据库查询数据，只有真正使用到数据时才去数据库查询。 1234567891011/**** load：延迟加载或懒加载*/@Testpublic void testLoad() &#123; //load方法查询数据 如果数据不存在将会抛出异常 User user=(User)session.load(User.class, 1); System.out.println(user.getId()); System.out.println(\"------------\"); System.out.println(user.getName());//到数据库查询&#125; 懒加载：在关联查询中也可以使用懒加载； Many-to-one: 1&lt;many-to-one name=\"cluss\" column=\"cluss_id\" lazy=\"proxy\"&gt;&lt;/many-to-one&gt; Lazy的值默认是proxy，是懒加载模式 no-proxy:也是懒加载模式,只是加载对象不使用代理。 lazy=”false”时采用即时加载。 set 1234&lt;set name=\"students\" lazy=\"true\"&gt; &lt;key column=\"cluss_id\"&gt;&lt;/key&gt; &lt;one-to-many class=\"Student\"/&gt;&lt;/set&gt; lazy=”true”默认，采用懒加载 Lazy=”false”：采用即时加载，一次将关联对象查询出来。 Lazy=”extra”：聪明的懒加载模式，如果只是查询关联对象的大小时，只会查询个数，不会查询数据。 Class：查询对象默认是lazy=true property默认是lazy=false 抓取策略：指查询数据时，采用什么样的sql语句来查询。1&lt;many-to-one name=\"cluss\" column=\"cluss_id\" lazy=\"proxy\" fetch=\"select\"&gt;&lt;/many-to-one&gt; Select采用的是select语句查询数据，默认采用select，在这种抓取策略下lazy才有意义。 Join抓取，采用的额join语句查询数据，一次将关联数据查出，lazy没有意义了。 一级缓存、二级缓存和查询缓存 缓存：提高执行效率。 hibernate提供了3类缓存：一级缓存，二级缓存，查询缓存。 一级缓存又称为session缓存,是线程级别的缓存。生命周期比较短。 get()方法获取，先检查缓存中是否有该数据，如果有直接使用，如果没有那么从数据库中查询，并写入缓存。 1234567891011/*** get()属于一级缓存*/@Testpublic void testGet() &#123; User user=(User)session.get(User.class, 1); System.out.println(user.getName()); System.out.println(\"---------------\"); user=(User)session.get(User.class, 1); System.out.println(user.getName());&#125; load()方法获取数据，先检查缓存中是否有该数据，如果有直接使用，如果没有那么从数据库中查询，并写入缓存。 1234567891011/*** load()也属于一级缓存*/@Testpublic void testLoads() &#123; User user=(User)session.load(User.class, 1); System.out.println(user.getName()); System.out.println(\"---------------\"); user=(User)session.load(User.class, 1); System.out.println(user.getName());&#125; List()方法，直接从数据库中获取，获取后将数据存入到缓存中 1234567891011121314/** * load()也属于一级缓存 */@Testpublic void testList() &#123; List&lt;User&gt; users=session.createQuery(\"from User\").list(); System.out.println(\"----------------\"); User user=(User)session.load(User.class, 1); System.out.println(user.getName()); System.out.println(\"----------------\"); users=session.createQuery(\"from User\").list(); System.out.println(users.size());&#125; iterate()方法，属于懒加载模式，先获取数据的id，如果使用数据再根据id查询数据，是一种延迟加载方式。Iterate方法获取数据时会先插件缓存，如果有直接使用，如果没有再去数据库查询，然后再把查询结果写入到缓存中。 1 和 N+1 问题：1是指list方法通过一条sql语句将所有的数据查询出来，而iterate方法通过n+1条sql语句将数据查询。他们的不同在于加载数据的方式不同。 缓存的管理：一般情况下不用管理一级缓存，如果在进行批量处理时需要管理缓存。清理缓存可以使用：evict清除指定对象，clear清空缓存，flush刷新缓存数据，close关闭缓存。 二级缓存又称为SessionFactory缓存，是进程级别的，生命周期比较长，并且可以在集群中使用。缓存的数据比较多，当需要清理缓存使用相关算法进行清理。比如：LRU和FIFO等。Hibernate二级缓存采用第三方插件来实现。 二级缓存使用步骤： 新建项目 导入jar包 添加ehcache.xml配置文件到src下 1234567891011121314&lt;!-- maxElementsInMemory：最多缓存元素的个数 eternal：是否永久缓存 timeToIdleSeconds 空闲时间 timeToLiveSeconds 存活时间 overflowToDisk 是否溢出到磁盘 --&gt;&lt;defaultCache maxElementsInMemory=\"10000\" eternal=\"false\" timeToIdleSeconds=\"120\" timeToLiveSeconds=\"120\" overflowToDisk=\"true\" /&gt; 在hibernate.cfg.xml开启二级缓存 1234&lt;!-- 开启二级缓存 --&gt;&lt;property name=\"cache.use_second_level_cache\"&gt;true&lt;/property&gt;&lt;property name=\"cache.provider_class\"&gt;org.hibernate.cache.ehcache.EhCacheRegionFactory&lt;/property&gt;&lt;property name=\"cache.region.factory_class\"&gt;org.hibernate.cache.ehcache.EhCacheRegionFactory&lt;/property&gt; 在映射文件中添加&lt;cache/&gt;标签 123&lt;class name=\"User\" table=\"t_user\" schema=\"\"&gt; &lt;cache usage=\"read-only\"/&gt;&lt;/class&gt; 测试：使用二级缓存时，说明在关闭session时还能继续查到数据。 123456789101112/** * get()是属于及时加载，获取数据时，如果不存在返回null */@Testpublic void testGet() &#123; User user=(User)session.get(User.class, 1); System.out.println(user.getName()); System.out.println(\"---------------\"); session=HibernateUtil.getSession(); user=(User)session.get(User.class, 1); System.out.println(user.getName());&#125; 查询缓存：在二级缓存的基础上使用， 开启查询缓存 hibernate.cfg.xml 12&lt;!-- 开启查询缓存 --&gt;&lt;property name=\"cache.use_query_cache\"&gt;true&lt;/property&gt; 在查询数据时，设置查询缓存有效 setCacheable(true) 12345678910111213@Testpublic void testList() &#123; List&lt;User&gt; users=session.createQuery(\"from User\") .setCacheable(true) .list(); System.out.println(\"----------------\"); User user=(User)session.load(User.class, 1); System.out.println(user.getName()); System.out.println(\"----------------\"); users=session.createQuery(\"from User\").setCacheable(true).list(); System.out.println(users.size());&#125; 事务隔离级别 从低到高: 读取未提交，读取已提交，可重复读，序列化 我们一般采用读取已提交，配合各种并发访问控制策略来达到事务控制的目的。 锁机制 乐观锁和悲观锁","categories":[{"name":"back-end","slug":"back-end","permalink":"https://CPWS.github.io/categories/back-end/"}],"tags":[{"name":"Hibernate4","slug":"Hibernate4","permalink":"https://CPWS.github.io/tags/Hibernate4/"}]},{"title":"深入使用struts2","slug":"深入使用struts2","date":"2019-09-29T11:17:18.000Z","updated":"2019-12-05T08:56:45.105Z","comments":true,"path":"2019/09/29/深入使用struts2/","link":"","permalink":"https://CPWS.github.io/2019/09/29/深入使用struts2/","excerpt":"","text":"详解Struts2的类型转换Strut2内建的类型转换器 对于大部分常用类型，开发者无须理会类型转换，Struts2可以完成大多数常用的类型转换。这是常用的类型转换是通过Struts2内建的类型转化器完成的，Struts2已经内建了字符串类型与如下类型之间相互转换的转换器。 boolean和Boolean：完成字符串和布尔值之间的转换。 char和Character：完成字符串和字符之间的转换。 int和Integer：完成字符串和整型值之间的转换。 long和Long：完成字符串和长整型值之间的转换。 float和Float：完成字符串和单精度浮点之间的转换。 double和Double：完成字符串和双精度浮点之间的转换。 Date：完成字符串和日期类型之间的转换，日期格式使用用户请求所在Locale的SHORT格式。 数据：在默认情况下，数组元素是字符串，如果用户提供了自定义的类型转换器，也可以是其他复合类型的转换器。 集合：在默认情况下，假定集合元素类型为String，并创建一个新的ArrayList封装所有的字符串。基于OGNL的类型转换 借助于内置的类型转换器，Struts2可以完成字符串和基本类型之间的转换。除此之外，借助于OGNL表达式，Struts2允许以另一种简单的方法将请求参数转换成复合类型。 不仅如此，还可以直接将请求参数转换成Collection集合。 指定集合元素的类型 使用集合时都使用了泛型，这种泛型可以让Struts2了解集合元素的类型，Struts2就可以通过反射来创建对应类的对象，并将这些对象加入到List中。 如果不使用泛型的话，这时得通过局部类型转换文件来指定集合元素的类型。 局部类型转换文件文件名应该为：actionName-convention.properties 类型转换文件应该与Action存放在相同的位置。 为了指定List集合里元素的类型，需要指定两个部分 List集合属性名称 List集合里元素的类型 提示：为了让Struts2了解集合中元素的类型，可以使用如下两种方式： 通过为集合指定泛型。 通过在Action的局部类型转换文件中指定集合元素的类型。 自定义类型转换器 大部分时候，使用Struts2提供的类型转换器，以及基于OGNL的类型转换机制,就能满足大部分类型转换的需求。但在某些特殊的情况下，例如需要把一个字符串转换成一个复合对象，这时候就需要使用到类型转换器。 Struts2的类型转换器实际上依然是基于OGNL框架的，在OGNL项目中有一个TypeConverter接口，这个接口就是自定义类型转换器要实现的接口。该接口的定义如下： 1234//OGNL提供的类型转换器接口public interface TypeConverter&#123; public Object converterValue(Map context,Object target,Member member,String propertyName,Object value,Class toType); &#125; 实现类型转换器必须实现上面的TypeConverter接口，不过上面接口里面的方法太过复杂，所有OGNL项目还为该接口提供了一个实现类：DefultTypeConverter，通常采用扩展该方法来实现自定义类型转换器。实现类型转换器需要重写DefaultTypeConverter类的converterValue方法。 converterValue方法：为了实现该方法的双向转换，程序需要通过判断toType的类型即可判断转换的方向。 注册类型转换器 自定义类型转换器完成之后，必须在web应用中注册该类型转换器，Struts2才可以正常使用该类型转换器。 Struts2支持如下三种类型转换器 注册局部类型转换器：ActionName-conversion.properties 注册全局类型转换器：xwork-conversion.properties 使用JDK1.5的注解来注册类型转换器：通过注解方法来注册类型转换器。 局部转换器只对指定的Action的执行属性有效，全局转换器指对指定类型的全部属性有效。 基于Struts2的类型转换器 Struts2提供了StrutsTypeConverter抽象类，实际上它是DefaultTypeConverter的子类，实现该抽象类，需要实现两个方法convertFromString()和convertToString()。第一个方法是将字符串类型转换成复合类型时调用，第二方法是将复合类型转换为字符串类型的调用。 注册该方法的方式与上面三种方法一样。 处理set集合 由于set集合元素是无序状态，所以Struts2无法准确将字符串转换为set集合，也无法准确读取set集合元素。 如果想要实现处理set集合，就需要为集合里每个元素添加一个标识属性。 Struts2允许使用局部类型转换文件来指定Set集合元素的标识属性，在局部类型转换文件中增加如下一行代码即可指定Set集合标识属性。 1KeyProperty_&lt;SetPropName&gt; = &lt;KeyPropName&gt; 在jsp页面中访问set元素的方式：&lt;SetPropName&gt;(&#39;&lt;indexPropValue&gt;&#39;) 类型转换中的错误处理 实际上，表现层数据设计两个处理：类型转换和数据校验。 可以进行有效的类型转换是基础，只有当数据完成有效数据转换后，下一步才去进行数据校验。 Struts2中类型转换的错误处理流程 当conversionError拦截器对异常进行处理后，系统会跳到名为input的逻辑视图名。 处理类型转换错误 为了让struts2的类型转换机制生效，必须让Action实现ActionSupport基类，因为ActionSupport基类负责收集异常信息，并将他们封装到FieldError对象，添加到ActionContext中。 在jsp页面中使用&lt;s:fielderror&gt;输出异常信息。 使用Struts2的输入校验 输入校验分为客户端校验和服务器端校验，客户端校验主要是过滤正常用户的误操作，主要由JavaScript代码完成；服务器端校验是整个应用阻止非法数据的最后防线，主要通过在应用编程中实现。 Struts2的输入校验即包括服务器端的校验，也包括客户端的校验。编写校验规则文件 Struts2提供了基于框架的输入校验，在这种输入校验下，所有的输入校验只需要编写简单的配置文件，Struts2的验证框架将会负责服务器端校验和客户端校验. 输入校验的配置文件的文件名：ActionName-validation.xml。 该文件的配置： &lt;validtors../&gt;:该配置文件的根元素。 &lt;field-validator../&gt;：字段校验配置风格。 &lt;validator ../&gt;：非字段校验配置风格。 当输入校验失败后，Struts2会自动返回名为input的逻辑视图名。 案例实现：12345678910111213 &lt;!--registerForm.jsp--&gt;&lt;h2&gt;请输入您的注册信息&lt;/h2&gt;&lt;s:fielderror/&gt;&lt;s:form action=\"register\"&gt; &lt;s:textarea name=\"name\" label=\"用户名\"&gt;&lt;/s:textarea&gt; &lt;s:textarea name=\"pass\" label=\"密码\"&gt;&lt;/s:textarea&gt; &lt;s:textarea name=\"age\" label=\"年龄\"&gt;&lt;/s:textarea&gt; &lt;s:textarea name=\"birth\" label=\"生日\"&gt;&lt;/s:textarea&gt; &lt;s:submit value=\"注册\"&gt;&lt;/s:submit&gt;&lt;/s:form&gt; 12345678910//Register Actionpublic class RegisterAction extends ActionSupport&#123; //定义四个成员变量封装请求参数 private String name; private String pass; private int age; private Date birth; //此处省略了getter和setter方法 //处理方采用ActionSupport中的方法&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;!--校验配置文件 RegisetAction-validation.xml--&gt;&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!-- 指定校验配置文件的dtd信息 --&gt; &lt;!DOCTYPE validators PUBLIC \"-//Apache Struts//XWork Validator 1.0.3//EN\" \"http://struts.apache.org/dtds/xwork-validator-1.0.3.dtd\"&gt;&lt;!-- 校验文件根元素 --&gt;&lt;validators&gt; &lt;!-- 校验Action的name属性 --&gt; &lt;field name=\"name\"&gt; &lt;!-- 指定name属性必须满足必填规则 --&gt; &lt;field-validator type=\"requiredstring\"&gt; &lt;param name=\"trim\"&gt;true&lt;/param&gt; &lt;message&gt;必须输入用户名&lt;/message&gt; &lt;/field-validator&gt; &lt;!-- 指定name属性必须匹配正则表达式 --&gt; &lt;field-validator type=\"regex\"&gt; &lt;param name=\"regex\"&gt;&lt;![CDATA[(\\w&#123;4,25&#125;)]]&gt;&lt;/param&gt; &lt;message&gt;您输入的用户只能是字母或数字，且长度必须在4-25位之间&lt;/message&gt; &lt;/field-validator&gt; &lt;/field&gt; &lt;!-- 校验Action的pass属性 --&gt; &lt;field name=\"pass\"&gt; &lt;!-- 指定pass属性必须满足必填规则 --&gt; &lt;field-validator type=\"requiredstring\"&gt; &lt;param name=\"trim\"&gt;true&lt;/param&gt; &lt;message&gt;必须输入密码&lt;/message&gt; &lt;/field-validator&gt; &lt;!-- 指定pass属性必须匹配正则表达式 --&gt; &lt;field-validator type=\"regex\"&gt; &lt;param name=\"regex\"&gt;&lt;![CDATA[(\\w&#123;4,25&#125;)]]&gt;&lt;/param&gt; &lt;message&gt;您输入的密码只能是字母或数字，且长度必须在4-25位之间&lt;/message&gt; &lt;/field-validator&gt; &lt;/field&gt; &lt;!-- 指定age必须在指定范围内 --&gt; &lt;field name=\"age\"&gt; &lt;field-validator type=\"int\"&gt; &lt;param name=\"min\"&gt;1&lt;/param&gt; &lt;param name=\"max\"&gt;150&lt;/param&gt; &lt;message&gt;年纪必须在1到150之间的整数&lt;/message&gt; &lt;/field-validator&gt; &lt;/field&gt; &lt;!-- 指定birth必须在指定范围内 --&gt; &lt;field name=\"birth\"&gt; &lt;field-validator type=\"date\"&gt; &lt;!-- 下面指定日期字符串时，必须使用Locale的日期格式 --&gt; &lt;param name=\"min\"&gt;1900-01-01&lt;/param&gt; &lt;param name=\"max\"&gt;2050-20-21&lt;/param&gt; &lt;message&gt;生日必须在$&#123;min&#125;到s&#123;max&#125;之间&lt;/message&gt; &lt;/field-validator&gt; &lt;/field&gt;&lt;/validators&gt; 12345&lt;!--struts.xml--&gt;&lt;action name=\"register\" class=\"org.crazyit.app.action.RegisterAction\"&gt; &lt;result&gt;/WEB-INF/content/show.jsp&lt;/result&gt; &lt;result name=\"input\"&gt;/WEB-INF/content/registerForm.jsp&lt;/result&gt;&lt;/action&gt; 12345&lt;!--show.jsp--&gt;用户名：&lt;s:property value=\"name\"/&gt;&lt;br/&gt;密 码：&lt;s:property value=\"pass\"/&gt;&lt;br/&gt;年 龄：&lt;s:property value=\"age\"/&gt;&lt;br/&gt;生 日：&lt;s:property value=\"birth\"/&gt;&lt;br/&gt; 注意：上面案例的校验配置文件与Action类放在同一个包下面。 从上面可以看出，这种校验方式的可用性很高，只要在配置文件中配置校验规则，即可完成数据校验，无须用户书写任何的数据校验代码。国家化提示信息 在上面的数据校验中，所有的提示信息都是通过硬编码的方式写在配置文件中，这种方式显然不利于程序国际化。 使用国际化资源文件案例： 数据校验配置文件： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;!--输入校验配置文件--&gt;&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!-- 指定校验配置文件的dtd信息 --&gt; &lt;!DOCTYPE validators PUBLIC \"-//Apache Struts//XWork Validator 1.0.3//EN\" \"http://struts.apache.org/dtds/xwork-validator-1.0.3.dtd\"&gt;&lt;!-- 校验文件根元素 --&gt;&lt;validators&gt; &lt;!-- 校验Action的name属性 --&gt; &lt;field name=\"name\"&gt; &lt;!-- 指定name属性必须满足必填规则 --&gt; &lt;field-validator type=\"requiredstring\"&gt; &lt;param name=\"trim\"&gt;true&lt;/param&gt; &lt;!-- &lt;message&gt;必须输入用户名&lt;/message&gt;--&gt; &lt;message key=\"name.required\"/&gt; &lt;/field-validator&gt; &lt;!-- 指定name属性必须匹配正则表达式 --&gt; &lt;field-validator type=\"regex\"&gt; &lt;param name=\"regex\"&gt;&lt;![CDATA[(\\w&#123;4,25&#125;)]]&gt;&lt;/param&gt; &lt;!-- 采用国际化资源文件配置提示信息 --&gt; &lt;message key=\"name.regex\"/&gt; &lt;/field-validator&gt; &lt;/field&gt; &lt;!-- 校验Action的pass属性 --&gt; &lt;field name=\"pass\"&gt; &lt;!-- 指定pass属性必须满足必填规则 --&gt; &lt;field-validator type=\"requiredstring\"&gt; &lt;param name=\"trim\"&gt;true&lt;/param&gt; &lt;!-- &lt;message&gt;必须输入密码&lt;/message&gt; --&gt; &lt;message key=\"pass.required\"/&gt; &lt;/field-validator&gt; &lt;!-- 指定pass属性必须匹配正则表达式 --&gt; &lt;field-validator type=\"regex\"&gt; &lt;param name=\"regex\"&gt;&lt;![CDATA[(\\w&#123;4,25&#125;)]]&gt;&lt;/param&gt; &lt;message key=\"pass.regex\"/&gt; &lt;/field-validator&gt; &lt;/field&gt; &lt;!-- 指定age必须在指定范围内 --&gt; &lt;field name=\"age\"&gt; &lt;field-validator type=\"int\"&gt; &lt;param name=\"min\"&gt;1&lt;/param&gt; &lt;param name=\"max\"&gt;150&lt;/param&gt; &lt;message key=\"age.range\"/&gt; &lt;/field-validator&gt; &lt;/field&gt; &lt;!-- 指定birth必须在指定范围内 --&gt; &lt;field name=\"birth\"&gt; &lt;field-validator type=\"date\"&gt; &lt;!-- 下面指定日期字符串时，必须使用Locale的日期格式 --&gt; &lt;param name=\"min\"&gt;1900-01-01&lt;/param&gt; &lt;param name=\"max\"&gt;2050-20-21&lt;/param&gt; &lt;message key=\"birth.range\"/&gt; &lt;/field-validator&gt; &lt;/field&gt;&lt;/validators&gt; 国际资源文件：RegisterAction_zh_CN.properties 123456name.required=您必须输入用户名！name.regex=您输入的用户只能是字母或数字，且长度必须在4-25位之间pass.required=必须输入密码pass.regex=您输入的密码只能是字母或数字，且长度必须在4-25位之间age.range=年纪必须在$&#123;min&#125;和$&#123;max&#125;之间的整数birth.range=生日必须在$&#123;min&#125;和$&#123;max&#125;之间 其它代码与上面一样。 从上面可以看出：&lt;message../&gt;没有直接给出提示信息，而是添加一个key属性，用它来指定国际资源文件。 使用客户端校验 在Struts2应用中使用客户端校验非常简单，只需要改变人如下两个地方即可。 将输入页面的表单标签改为使用Struts2标签来生成表单。 为该&lt;s:form&gt;元素增加validate=&quot;true&quot; 123456789101112&lt;h2&gt;请输入您的注册信息&lt;/h2&gt; &lt;s:fielderror/&gt; &lt;s:form action=\"register\" validate=\"true\"&gt; &lt;s:textarea name=\"name\" label=\"用户名\"&gt;&lt;/s:textarea&gt; &lt;s:textarea name=\"pass\" label=\"密码\"&gt;&lt;/s:textarea&gt; &lt;s:textarea name=\"age\" label=\"年龄\"&gt;&lt;/s:textarea&gt; &lt;s:textarea name=\"birth\" label=\"生日\"&gt;&lt;/s:textarea&gt; &lt;s:submit value=\"注册\"&gt;&lt;/s:submit&gt; &lt;/s:form&gt; 字段校验器配置风格 Struts2提供了两种方式来配置校验规则，字段校验风格和非字段校验风格。 字段校验风格是以字段为优先的配置方式 非字段校验风格是以校验器为优先的配置方式 字段校验器风格配置文件 &lt;field ../&gt;：校验规则文件的基本组成单位。 &lt;field-validator ../&gt;：指定一个校验规则。 ：用于指定该校验器的参数。 &lt;message ../&gt;：确定失败后的提示信息。 非字段校验配置风格 对于非字段校验配置风格，这是一种以校验器为优先的配置方式 文件格式如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!-- 指定校验配置文件的dtd信息 --&gt; &lt;!DOCTYPE validators PUBLIC \"-//Apache Struts//XWork Validator 1.0.3//EN\" \"http://struts.apache.org/dtds/xwork-validator-1.0.3.dtd\"&gt;&lt;!-- 校验文件根元素 --&gt;&lt;validators&gt; &lt;!-- 非字段校验配置风格 --&gt; &lt;!-- 配置指定必填字符串的校验器 --&gt; &lt;validator type=\"requiredstring\"&gt; &lt;!-- 使用该校验器name属性 --&gt; &lt;param name=\"fieldName\"&gt;name&lt;/param&gt; &lt;param name=\"trim\"&gt;true&lt;/param&gt; &lt;!-- 指定校验失败后 输出name.required的国际化提示信息 --&gt; &lt;message key=\"name.required\"/&gt; &lt;/validator&gt; &lt;validator type=\"regex\"&gt; &lt;!--使用该校验器校验name属性 --&gt; &lt;param name=\"fieldName\"&gt;name&lt;/param&gt; &lt;param name=\"trim\"&gt;true&lt;/param&gt; &lt;param name=\"regex\"&gt;&lt;![CDATA[(\\w&#123;4,25&#125;)]]&gt;&lt;/param&gt; &lt;!-- 指定校验失败后 输出name.regex的国际化提示信息 --&gt; &lt;message key=\"name.regex\"/&gt; &lt;/validator&gt; &lt;!-- 配置指定必填字符串的校验器 --&gt; &lt;validator type=\"requiredstring\"&gt; &lt;!-- 使用该校验器pass属性 --&gt; &lt;param name=\"fieldName\"&gt;pass&lt;/param&gt; &lt;param name=\"trim\"&gt;true&lt;/param&gt; &lt;!-- 指定校验失败后 输出pass.required的国际化提示信息 --&gt; &lt;message key=\"pass.required\"/&gt; &lt;/validator&gt; &lt;validator type=\"regex\"&gt; &lt;!--使用该校验器校验name属性 --&gt; &lt;param name=\"fieldName\"&gt;pass&lt;/param&gt; &lt;param name=\"trim\"&gt;true&lt;/param&gt; &lt;param name=\"regex\"&gt;&lt;![CDATA[(\\w&#123;4,25&#125;)]]&gt;&lt;/param&gt; &lt;!-- 指定校验失败后 输出pass.regex的国际化提示信息 --&gt; &lt;message key=\"pass.regex\"/&gt; &lt;/validator&gt; &lt;!-- 配置指定整数的校验器 --&gt; &lt;validator type=\"int\"&gt; &lt;!-- 使用该校验器name属性 --&gt; &lt;param name=\"fieldName\"&gt;age&lt;/param&gt; &lt;!-- 配置指定整数的范围 --&gt; &lt;param name=\"min\"&gt;1&lt;/param&gt; &lt;param name=\"max\"&gt;150&lt;/param&gt; &lt;!-- 年纪必须在1到150之间的整数--&gt; &lt;message key=\"age.range\"/&gt; &lt;/validator&gt; &lt;!-- 配置指定整数的校验器 --&gt; &lt;validator type=\"date\"&gt; &lt;!-- 使用该校验器name属性 --&gt; &lt;param name=\"fieldName\"&gt;birth&lt;/param&gt; &lt;!-- 下面指定日期字符串时，必须使用Locale的日期格式 --&gt; &lt;param name=\"min\"&gt;1900-01-01&lt;/param&gt; &lt;param name=\"max\"&gt;2050-20-21&lt;/param&gt; &lt;!-- 生日必须在$&#123;min&#125;到$&#123;max&#125;之间 --&gt; &lt;message key=\"birth.range\"/&gt; &lt;/validator&gt;&lt;/validators&gt; 非字段校验器配置风格的配置文件 &lt;validator ../&gt;:定义一个校验规则 &lt;validator type=”” ../&gt;：用于指定校验器名称。 功能与字段校验规则一样。 ：功能与字段校验规则一样。 ：用于指定需要被校验的`Action`的属性。 短路校验器 short-circuit：在&lt;field-validator ../&gt;元素上添加该属性实现短路验证器。 校验文件的搜索规则 如果一个Action中可能包含多个处理逻辑，Struts2中允许为不同的处理逻辑提供不同的校验规则。 校验规则名字：&lt;Action Name&gt; - &lt;ActionAliasName&gt; - validation.xml；ActionAliasName为struts.xml配置文件Action的`name``值。 如果一个处理逻辑，例如登录请求处理逻辑，既有LoginAction-volidator.xml校验规则，又有LoginAction-loginPro-volidator.xml的校验规则，则该处理逻辑的校验规则为这两个校验规则的总和。 此处之外，还有另外一种情形：如果系统包含两个Action处理类：BaseAction和RegisterAction，RegisterAction继承了BaseAction,则registerAction的校验规则是RegisterAction-validation.xml和BaseAction-validation.xml这两个规则文件的总和。 假设系统中有两个Action：BaseAction和RegisterAction，则系统搜索规则文件的顺序如下： BaseAction-validation.xml BaseAction-别名-validation.xml RegisterAction-validation.xml RegisterAction-别名-validation.xml 如果上面的RegisterAction继承了BaseAction，那么RegisterAction的校验规则是上面四个校验规则文件的总和。 注意：Struts2校验规则文件是从上到下搜索的，实际用的校验规则是所有校验规则的总和。如果校验规则有冲突时，则后面文件中的校验规则取胜。 校验顺序和短路 校验器的执行顺序有如下原则： 所有非字段风格的校验器优先于字段风格的校验器。 所有的非字段风格的校验器，排在前面的会先执行。 所有的字段风格的校验器，排在前面的会先执行。 校验器短路的原则如下： 所有非字段校验器是最优先执行，如果某个非字段校验器校验失败了，则该字段上所有的校验器都不会获得校验的机会。 非字段校验器的校验失败，不会阻止其他非字段校验器的执行。 如果一个字段校验器校验失败后，则该字段下且排在该校验失败的校验器之后的其他校验器不会获得校验的机会。 如果应用中所需要的校验规则非常复杂，用户可以两个选择，开发自己的校验器，或者重写Action中的validate方法。 内建校验器 注册一个校验器，通过一个&lt;validator../&gt;元素即可注册一个校验器，name属性指定校验器名称，class指定校验器的实现类。 如果开发者开发了一个自己的校验器，则可以通过添加一个validators.xml文件来注册校验器。 注意：如果Struts2系统在src路径下找到一个validators.xml文件，则不会加载系统默认的default.xml文件。如果开发者开发自己的校验器时，要把default.xml文件里的内容全部复制到validators.xml文件中。 必填校验器(name=required):要求指定的字段必须有值（非空）。 必填校验器可以接受如下参数： fieldName:该参数用于指定校验的Action属性名，如果采用字段校验器风格，则无需指定该参数 采用非字段校验器配置风格，该校验器的配置示例如下： 123456789&lt;validators&gt; &lt;!--使用非字段校验配置风格--&gt; &lt;validator type=\"required\"&gt; &lt;!--指定需要校验的字段名--&gt; &lt;param name=\"fieldName\"&gt;username&lt;/param&gt; &lt;!--指定校验失败的提示信息--&gt; &lt;message&gt;username must not be null&lt;/message&gt; &lt;/validator&gt;&lt;/validators&gt; 采用字段校验器配置风格，该校验器的配置示例如下： 12345678910&lt;validators&gt; &lt;!--使用字段校验配置风格--&gt; &lt;field name=\"username\"&gt; &lt;field-validator type=\"required\"&gt; &lt;!--指定校验失败的提示信息--&gt; &lt;message&gt;username must not be null&lt;/message&gt; &lt;/field-validator&gt; &lt;/field&gt;&lt;/validators&gt; 必填字符串校验器（requiredstring）:该校验器要求字段值必须非空且长度大于0，即该字符串不能是””. 必填字符串校验器可以接受如下参数： fieldName:该属性指定校验的Action属性名，如果采用字段校验器配置风格，则无须指定该属性 trim:是否在校验前截断被校验属性值前后的空白，该属性是可选的，默认为true 采用非字段校验器配置风格，该校验器的配置示例如下： 12345678910&lt;validators&gt; &lt;!--使用非字段校验配置风格来配置必填字符串校验器--&gt; &lt;validator type=\"requiredstring\"&gt; &lt;!--指定需要校验的字段名--&gt; &lt;param name=\"fieldName\"&gt;username&lt;/param&gt; &lt;param name=\"trim\"&gt;true&lt;/param&gt; &lt;!--指定校验失败的提示信息--&gt; &lt;message&gt;username must not be null&lt;/message&gt; &lt;/validator&gt;&lt;/validators&gt; 采用字段校验器配置风格，该校验器的配置示例如下： 12345678910&lt;validators&gt; &lt;!--使用字段校验配置风格来配置必填字符串校验器--&gt; &lt;field name=\"username\"&gt; &lt;field-validator type=\"requiredstring\"&gt; &lt;param name=\"trim\"&gt;true&lt;/param&gt; &lt;!--指定校验失败的提示信息--&gt; &lt;message&gt;username must not be null&lt;/message&gt; &lt;/field-validator&gt; &lt;/field&gt;&lt;/validators&gt; 整数校验器（int）:整数校验器包括int、short、long，该校验器要求字段的整数值必须在指定的范围内. 该校验器可以接受如下参数: fieldName:该属性指定校验的Action属性名，如果采用字段校验器配置风格，则无须指定该属性 min：指定该属性的最小值，该参数可选，如果没有指定，则不检查最小值。 max：指定该属性的最大值，该参数可选，如果没有指定，则不检查最大值。 采用非字段校验器配置风格，该校验器的配置示例如下： 12345678910111213&lt;validators&gt; &lt;!--使用非字段校验配置风格来配置整数校验器--&gt; &lt;validator type=\"int\"&gt; &lt;!--指定需要校验的字段名--&gt; &lt;param name=\"fieldName\"&gt;age&lt;/param&gt; &lt;!--指定最小值--&gt; &lt;param name=\"min\"&gt;1&lt;/param&gt; &lt;!--指定最大值--&gt; &lt;param name=\"max\"&gt;150&lt;/param&gt; &lt;!--指定校验失败的提示信息--&gt; &lt;message&gt;username must not be null&lt;/message&gt; &lt;/validator&gt;&lt;/validators&gt; 采用字段校验器配置风格，该校验器的配置示例如下： 12345678910111213&lt;validators&gt; &lt;!--使用字段校验配置风格来配置整数校验器--&gt; &lt;field name=\"age\"&gt; &lt;field-validator type=\"int\"&gt; &lt;!--指定最小值--&gt; &lt;param name=\"min\"&gt;1&lt;/param&gt; &lt;!--指定最大值--&gt; &lt;param name=\"max\"&gt;150&lt;/param&gt; &lt;!--指定校验失败的提示信息--&gt; &lt;message&gt;username must not be null&lt;/message&gt; &lt;/field-validator&gt; &lt;/field&gt;&lt;/validators&gt; 日期校验器（date）:，该校验器要求字段的日期值必须在指定的范围内. 该校验器可以接受如下参数: fieldName:该属性指定校验的Action属性名，如果采用字段校验器配置风格，则无须指定该属性 min：指定该属性的最小值，该参数可选，如果没有指定，则不检查最小值。 max：指定该属性的最大值，该参数可选，如果没有指定，则不检查最大值。 采用非字段校验器配置风格，该校验器的配置示例如下： 12345678910111213&lt;validators&gt; &lt;!--使用非字段校验配置风格来配置日期校验器--&gt; &lt;validator type=\"int\"&gt; &lt;!--指定需要校验的字段名--&gt; &lt;param name=\"fieldName\"&gt;birth&lt;/param&gt; &lt;!--指定最小值--&gt; &lt;param name=\"min\"&gt;1900-01-01&lt;/param&gt; &lt;!--指定最大值--&gt; &lt;param name=\"max\"&gt;2020-02-21&lt;/param&gt; &lt;!--指定校验失败的提示信息--&gt; &lt;message&gt;username must not be null&lt;/message&gt; &lt;/validator&gt;&lt;/validators&gt; 采用字段校验器配置风格，该校验器的配置示例如下： 12345678910111213&lt;validators&gt; &lt;!--使用字段校验配置风格来配置日期校验器--&gt; &lt;field name=\"age\"&gt; &lt;field-validator type=\"birth\"&gt; &lt;!--指定最小值--&gt; &lt;param name=\"min\"&gt;1900-01-01&lt;/param&gt; &lt;!--指定最大值--&gt; &lt;param name=\"max\"&gt;2020-02-21&lt;/param&gt; &lt;!--指定校验失败的提示信息--&gt; &lt;message&gt;username must not be null&lt;/message&gt; &lt;/field-validator&gt; &lt;/field&gt;&lt;/validators&gt; 表达式校验器（expression）：它是一个非字段校验器，不可在字段校验配置风格中使用。 字段表达式验证器（fieldexpression）：它要求指定字段满足一个逻辑表达式。 邮箱地址校验器（email）：它要求检查的字段如果不为空，则必须满足的邮箱地址。 网址校验器（url）：它要求被检查的字符如果非空，则必须满足合法的url地址。 Visitor校验器：主要用于检测Action里的复合属性。 转换器校验（conversion）：主要用于被检验字段在类型转换过程中是否出现错误。 字符串长度校验器（stringlength）：它要求被校验字段的长度必须在指定范围内，否则校验失败。 正则表达式校验器（regex）：它用于检查被校验字符是否匹配一个正则表达式。基于注册的输入校验 案例实现：12345678910111213141516171819202122232425262728293031323334353637383940414243public class RegisterAction02 extends ActionSupport&#123; private static final long serialVersionUID = 1L; //定义User类型的成员变量用于封装请求参数 private String name; private String pass; private int age; private Date birth; public String getName() &#123; return name; &#125; //使用注解指定必填，正则表达式两个校验器 @RequiredStringValidator(key=\"name.required\",message=\"\") @RegexFieldValidator(regex=\"\\\\w&#123;4,25&#125;\",key=\"name.regex\",message=\"\") public void setName(String name) &#123; this.name = name; &#125; public String getPass() &#123; return pass; &#125; //使用注解指定必填，正则表达式两个校验器 @RequiredStringValidator(key=\"pass.required\",message=\"\") @RegexFieldValidator(regex=\"\\\\w&#123;4,25&#125;\",key=\"pass.regex\",message=\"\") public void setPass(String pass) &#123; this.pass = pass; &#125; public int getAge() &#123; return age; &#125; @IntRangeFieldValidator(message=\"\",key=\"age.range\",min=\"1\",max=\"150\") public void setAge(int age) &#123; this.age = age; &#125; public Date getBirth() &#123; return birth; &#125; @DateRangeFieldValidator(message=\"\",key=\"birth.range\",min=\"1900/01/01\",max=\"2050/02/21\") public void setBirth(Date birth) &#123; this.birth = birth; &#125; &#125; 手动完成输入校验 重写validate()方法 重写validateXxx()方法 使用Struts2控制文件上传Struts2的文件上传 实现步骤: 实现文件上传的Action 12345&lt;s:form action=\"upload\" method=\"POST\" enctype=\"multipart/form-data\"&gt; &lt;s:textfield name=\"title\" label=\"文件标题\"&gt;&lt;/s:textfield&gt; &lt;s:file name=\"upload\" label=\"选择文件\"&gt;&lt;/s:file&gt; &lt;s:submit value=\"上传\"&gt;&lt;/s:submit&gt; &lt;/s:form&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package org.crazyit.app.action;import java.io.File;import java.io.FileInputStream;import java.io.FileOutputStream;import org.apache.struts2.ServletActionContext;import com.opensymphony.xwork2.ActionSupport;@SuppressWarnings(\"all\")public class UploadAction extends ActionSupport&#123; //封装文件标题请求参数的成员变量 private String title; //封装上传文件域的成员变量 private File upload; //封装上传文件类型的成员变量 private String uploadContentType; //封装上传文件名的属性 private String uploadFileName; //直接在`struts.xml`文件中配置的成员变量 private String savePath; //接收`struts.xml`文件配置值的方法 public void setSavePath(String value) &#123; this.savePath=value; &#125; //获取上传文件的保存位置 public String getSavePath() throws Exception&#123; return ServletActionContext.getServletContext().getRealPath(savePath); &#125; public String getTitle() &#123; return title; &#125; public void setTitle(String title) &#123; this.title = title; &#125; public File getUpload() &#123; return upload; &#125; public void setUpload(File upload) &#123; this.upload = upload; &#125; public String getUploadContentType() &#123; return uploadContentType; &#125; public void setUploadContentType(String uploadContentType) &#123; this.uploadContentType = uploadContentType; &#125; public String getUploadFileName() &#123; return uploadFileName; &#125; public void setUploadFileName(String uploadFileName) &#123; this.uploadFileName = uploadFileName; &#125; @Override public String execute() throws Exception &#123; //以服务器的文件保存地址和原文件建立上传文件输出流 FileOutputStream fos=new FileOutputStream(getSavePath()+\"\\\\\"+getUploadFileName()); FileInputStream fis=new FileInputStream(getUpload()); byte[] buffer=new byte[1024]; int len=0; while((len=fis.read(buffer))!=-1) &#123; fos.write(buffer,0,len); &#125; fos.flush(); return SUCCESS; &#125;&#125; 配置文件上传的Action 123456789101112&lt;constant name=\"struts.i18n.encoding\" value=\"GBK\"&gt;&lt;/constant&gt;&lt;package name=\"default\" namespace=\"/\" extends=\"struts-default\" &gt; &lt;!-- 配置處理文件上傳的Action --&gt; &lt;action name=\"upload\" class=\"org.crazyit.app.action.UploadAction\"&gt; &lt;!-- 動態設置Action的属性值--&gt; &lt;param name=\"savePath\"&gt;/uploadFiles&lt;/param&gt; &lt;result&gt;/WEB-INF/content/succ.jsp&lt;/result&gt; &lt;/action&gt; &lt;action name=\"*\"&gt; &lt;result&gt;/WEB-INF/content/&#123;1&#125;.jsp&lt;/result&gt; &lt;/action&gt;&lt;/package&gt; 手动实现文件过滤 如果需要手动实现文件过滤，可按如下步骤进行： 在Action中定义一个专门用于过滤文件的方法，该方法的方法名是任意的，该方法的逻辑就是判断上传文件的类型是否为允许类型。例如增加filterTypes()方法,方法代码如下： 1234567891011public String filterTypes(String[] types) &#123; System.out.println(types); //获取允许上传的所有文件类型 String fileType=getUploadContentType(); for(String type:types) &#123; if(type.equals(fileType)) &#123; return null; &#125; &#125; return ERROR;&#125; 上面的方法判断了上传文件的文件类型是否在允许上传的文件类型列表中。为了让程序可以动态设置允许上传的文件类型，为该action增加一个allowTypes属性，该属性的值列出了所有允许上传的文件类型。为了可以在struts.xml文件中配置allowTypes属性的值，必须在Action类中提供如下代码: 123456789//定义该action允许上传的文件类型private String allowTypes;public String getAllowTypes() &#123; return allowTypes;&#125;public void setAllowTypes(String allowTypes) &#123; this.allowTypes = allowTypes;&#125; 利用Struts2的数据校验来判断用户输入的文件是否符合要求。如果不符合要求，接下来将错误提示信息添加到FieldError中。该Action中添加的validate()代码如下： 1234567891011//执行输入校验@Overridepublic void validate() &#123; //将允许上传的文件类型的字符串以英文逗号(,) //分解成字符串数字从而判断当前文件类型是否允许上传 String filterResult=filterTypes(getAllowTypes().split(\",\")); if(filterResult!=null) &#123; addFieldError(\"upload\", \"您要上传的文件类型不符合！\"); &#125;&#125; 在Struts.xml配置文件的配置如下： 12345678&lt;action name=\"upload\" class=\"org.crazyit.app.action.UploadAction\"&gt; &lt;!-- 動態設置Action的属性值--&gt; &lt;param name=\"savePath\"&gt;/uploadFiles&lt;/param&gt; &lt;!-- 设置允许上传的文件类型 --&gt; &lt;param name=\"allowTypes\"&gt;image/png,image/gif&lt;/param&gt; &lt;result name=\"input\"&gt;/WEB-INF/content/uploadForm.jsp&lt;/result&gt; &lt;result&gt;/WEB-INF/content/succ.jsp&lt;/result&gt;&lt;/action&gt; 为了在页面显示错误提示信息，可以在该页面添加如下代码： 1&lt;s:fielderror/&gt; 拦截器实现文件过滤 配置文件如下：1234567891011121314151617&lt;action name=\"upload\" class=\"org.crazyit.app.action.UploadAction\"&gt; &lt;!-- 配置fileUpload拦截器 --&gt; &lt;interceptor-ref name=\"fileUpload\"&gt; &lt;!-- 配置允许上传的文件类型 --&gt; &lt;param name=\"allowTypes\"&gt;image/png,image/gif&lt;/param&gt; &lt;!-- 配置允许上传的文件的大小 --&gt; &lt;param name=\"maximumSize\"&gt;2000&lt;/param&gt; &lt;/interceptor-ref&gt; &lt;!-- 配置系统默认的拦截器 --&gt; &lt;interceptor-ref name=\"defaultStack\"&gt;&lt;/interceptor-ref&gt; &lt;!-- 動態設置Action的属性值--&gt; &lt;param name=\"savePath\"&gt;/uploadFiles&lt;/param&gt; &lt;!-- 设置允许上传的文件类型 --&gt; &lt;result name=\"input\"&gt;/WEB-INF/content/uploadForm.jsp&lt;/result&gt; &lt;result&gt;/WEB-INF/content/succ.jsp&lt;/result&gt;&lt;/action&gt; 输出错误提示信息 …文件上传的常量配置 … 使用Struts2控制文件下载实现文件下载的Action 实现文件下载的Action与普通的Action没有太大的区别，，仅仅需要提供一个返回InputStream流的方法，该输入流代表了被下载文件的入口。该Action类的代码如下： 12345678910111213141516171819public class FileDownloadAction extends ActionSupport&#123; //该成员变量可以在配置文件中动态指定该值 private String inputPath; //inputName的setter方法 public void setInputPath(String value) &#123; this.inputPath = value; &#125; /* 定义一个返回InputStream的方法， 该方法将作为被下载文件的入口， 且需要配置stream类型结果时指定inputName参数， inputName参数的值就是方法去掉get前缀、首字母小写的字符串 */ public InputStream getTargetFile() throws Exception&#123; // ServletContext提供getResourceAsStream()方法 // 返回指定文件对应的输入流 return ServletActionContext.getServletContext().getResourceAsStream(inputPath); &#125;&#125; 一旦定义了该Action就可以实现文件下载。 配置Action 配置文件下载的Action与配置普通的Action并没有太大的不同，关键是要配置一个类型为stream的结果，该Stream的结果将使用文件下载作为响应。 Stream结果类型的逻辑视图是返回客户端一个输入流，因此无需指定location属性。 1234567891011121314&lt;action name=\"down\" class=\"org.crazyit.app.action.FileDownloadAction\"&gt; &lt;!-- 指定被下载资源的位置 --&gt; &lt;param name=\"inputPath\"&gt;/WEB-INF/img/56efbc0d6b66e.jpg&lt;/param&gt; &lt;result type=\"stream\"&gt; &lt;!-- 指定下载文件的文件类型 --&gt; &lt;param name=\"contentType\"&gt;image/jpg&lt;/param&gt; &lt;!-- 指定由getTargetFile()方法返回被下载文件的InputStream --&gt; &lt;param name=\"inputName\"&gt;targetFile&lt;/param&gt; &lt;!-- 指定下载的文件名 --&gt; &lt;param name=\"contentDisposition\"&gt;filename=\"demo.jpg\"&lt;/param&gt; &lt;!-- 指定下载文件的缓冲大小 --&gt; &lt;param name=\"bufferSize\"&gt;4096&lt;/param&gt; &lt;/result&gt;&lt;/action&gt; 下载前的权限控制 案例 1234567891011121314151617181920212223public class AuthorityDownAction implements Action&#123; private String inputPath; public void setInputPath(String value) &#123; this.inputPath=value; &#125; public InputStream getTargetFile() throws Exception&#123; return ServletActionContext.getServletContext().getResourceAsStream(inputPath); &#125; @Override public String execute() throws Exception &#123; //取得ActionContext实例 ActionContext ctx=ActionContext.getContext(); //通过ActionContext访问用户的HttpSession Map session=ctx.getSession(); String user=(String) session.get(\"user\"); //判断Session里的user是否通过检查 if(user!=null&amp;&amp;user.equals(\"crazyit.org\")) &#123; return SUCCESS; &#125; ctx.put(\"tip\", \"您还没有登录\"); return LOGIN; &#125;&#125; 123456789101112131415161718&lt;action name=\"download2\" class=\"org.crazyit.app.action.AuthorityDownAction\"&gt; &lt;!-- 定义被下载文件的物理资源 --&gt; &lt;param name=\"inputPath\"&gt;/WEB-INF/images/wjc_logo.zip&lt;/param&gt; &lt;result type=\"stream\"&gt; &lt;!-- 指定下载文件的文件类型 --&gt; &lt;param name=\"contentType\"&gt;application/zip&lt;/param&gt; &lt;!-- 指定由getTargetFile()方法返回被下载文件的InputStream --&gt; &lt;param name=\"inputName\"&gt;targetFile&lt;/param&gt; &lt;param name=\"contentDisposition\"&gt;filename=\"wjc_logo.zip\"&lt;/param&gt; &lt;!-- 指定下载文件的缓冲大小 --&gt; &lt;param name=\"bufferSize\"&gt;4096&lt;/param&gt; &lt;/result&gt; &lt;!-- 定义一个名为login的结果 --&gt; &lt;result name=\"login\"&gt;/WEB-INF/content/loginForm.jsp&lt;/result&gt;&lt;/action&gt;&lt;action name=\"login\" class=\"org.crazyit.app.action.LoginAction\"&gt; &lt;result&gt;/WEB-INF/content/struts2Down.jsp&lt;/result&gt;&lt;/action&gt; 详解Struts2的拦截器机制配置拦截器 定义拦截器使用&lt;interceptor../&gt;元素来定义，定义拦截器的简答的格式如下： 12&lt;!--通过指定拦截器名和拦截器实现类来定义拦截器--&gt;&lt;interceptor name=\"拦截器名\" class=\"拦截器实现类\" /&gt; 如果还需要在配置拦截器是传入拦截器参数，需要在&lt;interceptor../&gt;元素中使用&lt;param ../&gt;子元素即可。下面是它配置的简单格式： 123456&lt;!--通过指定拦截器名和拦截器实现类来定义拦截器--&gt;&lt;interceptor name=\"拦截器名\" class=\"拦截器实现类\"&gt; &lt;!--下面的元素可以出现0次，或者是无限次--&gt; &lt;!--name属性指定参数名，中间值指定的该参数名对象的参数值--&gt; &lt;param name=\"参数名\"&gt;参数值&lt;/param&gt;&lt;/interceptor&gt; 还可以把多个拦截器连在一起组成拦截器栈，定于拦截器栈可以使用&lt;interceptor-stack ../&gt;元素，拦截器栈是由多个拦截器组成的，因此需要在该元素中使用&lt;interceptor-ref ../&gt;元素来定义多个拦截器引用，即该拦截器栈由多个&lt;inteceptor-ref../&gt;元素指定的拦截器组成。配置拦截器栈的语法格式如下： 12345&lt;interceptor-stack name=\"拦截器栈名\"&gt; &lt;interceptor-ref name=\"拦截器1\"/&gt; &lt;interceptor-ref name=\"拦截器2\"/&gt; ...&lt;/inteceptor-stack&gt; 因为拦截器栈与拦截器在功能上完全统一，因此可能出现，拦截器里也可能包含其他拦截器栈。因此，可能出现如下配置片段： 12345678910&lt;interceptor-stack name=\"拦截器栈1\"&gt; &lt;interceptor-ref name=\"拦截器1\"/&gt; &lt;interceptor-ref name=\"拦截器2\"/&gt; ...&lt;/inteceptor-stack&gt;&lt;interceptor-stack name=\"拦截器栈2\"&gt; &lt;interceptor-ref name=\"拦截器3\"/&gt; &lt;interceptor-ref name=\"拦截器栈1\"/&gt; ...&lt;/inteceptor-stack&gt; 系统为拦截器指定参数有两种时机。 定义拦截器时指定参数值：这种参数值将作为拦截器参数的默认参数值。 使用拦截器时指定参数值：在配置Action时为拦截器参数指定值。 通过为&lt;interceptor-ref&gt;元素增加&lt;param../&gt;子元素，就可以在拦截器使用时为参数指定值。因此可能出现以下片段 1234567891011121314&lt;interceptor-stack name=\"拦截器栈1\"&gt; &lt;interceptor-ref name=\"拦截器1\"&gt; &lt;param name=\"参数名\"&gt;参数值&lt;/param&gt; &lt;param name=\"参数名\"&gt;参数值&lt;/param&gt; ... &lt;/interceptor-ref&gt; &lt;interceptor-ref name=\"拦截器2\"/&gt; ...&lt;/inteceptor-stack&gt;&lt;interceptor-stack name=\"拦截器栈2\"&gt; &lt;interceptor-ref name=\"拦截器3\"/&gt; &lt;interceptor-ref name=\"拦截器栈1\"/&gt; ...&lt;/inteceptor-stack&gt; 使用拦截器的配置语法 下面是在Action中定义拦截器的配置实例：123456789101112131415161718192021&lt;!--定义全部拦截器--&gt;&lt;interceptors&gt; &lt;!--定义第一个拦截器--&gt; &lt;interceptor name=\"mySimple\" class=\"lee.SimpleInterceptor\"/&gt; &lt;!--定义第二个拦截器--&gt; &lt;interceptor name=\"later\" class=\"lee.LaterInterceptor\"&gt; &lt;param name=\"参数名\"&gt;参数值&lt;/param&gt; &lt;/interceptor&gt;&lt;/interceptors&gt;...&lt;action name=\"login\" class=\"org.crazyit.app.action.LoginAction\"&gt; &lt;!--使用系统默认的拦截器--&gt; &lt;interceptor-ref name=\"defaultStack\"/&gt; &lt;!--使用第一个拦截器--&gt; &lt;interceptor-ref name=\"mySimple\"/&gt; &lt;!--使用第二个拦截器--&gt; &lt;interceptor-ref name=\"later\"&gt; &lt;!--为该Action指定拦截器参数，该参数会覆盖默认值--&gt; &lt;param name=\"name\"&gt;动态参数&lt;/param&gt; &lt;/interceptor-ref&gt;&lt;/action&gt; 配置默认拦截器 配置默认拦截器使用&lt;default-interceptor-ref&gt;元素，该元素作为package的子元素,为该包下的所有Action配置默认拦截器。 下面配置默认拦截器的配置示例：1234567891011&lt;package name=\"\" namespace=\"\" extends=\"struts-default\"&gt; &lt;interceptors&gt; &lt;!--定义拦截器--&gt; &lt;interceptor .../&gt; &lt;!--定义拦截器栈--&gt; &lt;interceptor-stack .../&gt; &lt;/interceptor&gt; &lt;!--配置该包下的默认拦截器--&gt; &lt;default-interceptor-ref name=\"拦截器名或拦截器栈名\"&gt; &lt;action ../&gt;&lt;/package&gt; 使用拦截器类 如果用户想要开发自己的拦截器，需要实现com.opensymphony.xwork2.interceptor.Interceptor接口. 该接口的类定义如下： 12345678public interface Interceptor&#123; //销毁该拦截器之前的回调方法 void destory(); //初始化该拦截器的回调方法 void init(); //拦截器实现拦截的逻辑方法 String interceptor(ActionInvocation innovation) throws Exception;&#125; 下面实现一个简单的拦截器示例： 12345678910111213141516171819202122232425262728293031323334353637public class SimpleInterceptor extends AbstractInterceptor&#123; //简单拦截器的名字 private String name; public void setName(String name) &#123; this.name = name; &#125; @Override public void init() &#123; // TODO Auto-generated method stub super.init(); &#125; @Override public void destroy() &#123; // TODO Auto-generated method stub super.destroy(); &#125; @Override public String intercept(ActionInvocation invocation) throws Exception &#123; //取得被拦截的Action实例 LoginAction action=(LoginAction) invocation.getAction(); //打印开始执行时间 System.out.println(name+\"拦截器的动作----------\"+\"开始执行登录Action的时间：\"+new Date()); //取得开始执行Action的事件 long start =System.currentTimeMillis(); //执行该烂机器的最后一个拦截器 String result=invocation.invoke(); //打印结束执行时间 System.out.println(name+\"拦截器的动作----------\"+\"介绍登录Action的时间：\"+new Date()); long end=System.currentTimeMillis(); System.out.println(\"执行时间\"+(end-start)+\"ms\"); return result; &#125; &#125; 使用拦截器 使用拦截器需要两个步骤： 通过&lt;interceptor&gt;元素来定义拦截器 通过&lt;interceptor-ref&gt;元素来使用拦截器 12345678910111213141516&lt;!-- 应用所需的拦截器需要在该元素下配置 --&gt;&lt;interceptors&gt; &lt;interceptor name=\"mySimple\" class=\"org.crazyit.app.interceptor.SimpleInterceptor\"&gt; &lt;!-- 为拦截器指定参数值 --&gt; &lt;param name=\"name\"&gt;简单拦截器&lt;/param&gt; &lt;/interceptor&gt;&lt;/interceptors&gt;&lt;action name=\"login\" class=\"org.crazyit.app.action.LoginAction\"&gt; &lt;result name=\"error\"&gt;/WEB-INF/content/eeor.jsp&lt;/result&gt; &lt;result name=\"success\"&gt;/WEB-INF/content/welcome.jsp&lt;/result&gt; &lt;!-- 配置系统的默认拦截器 --&gt; &lt;interceptor-ref name=\"defaultStack\"&gt;&lt;/interceptor-ref&gt; &lt;interceptor-ref name=\"mySimple\"&gt; &lt;param name=\"name\"&gt;改名后的拦截器&lt;/param&gt; &lt;/interceptor-ref&gt;&lt;/action&gt; 拦截方法的拦截器 方法过滤的拦截器方法的示例：123456789101112131415161718192021222324252627282930313233343536/*** * 拦截器方法的拦截器，应该继承MethodFilterInterceptor * @author 1huangzewei * */public class MyFilterInterceptor extends MethodFilterInterceptor&#123; /** * */ private static final long serialVersionUID = 1L; //简单拦截器的名字 private String name; public void setName(String name) &#123; this.name = name; &#125; @Override protected String doIntercept(ActionInvocation invocation) throws Exception &#123; //取得被拦截的Action实例 LoginAction action=(LoginAction) invocation.getAction(); //打印开始执行时间 System.out.println(name+\"拦截器的动作----------\"+\"开始执行登录Action的时间：\"+new Date()); //取得开始执行Action的事件 long start =System.currentTimeMillis(); //执行该烂机器的最后一个拦截器 String result=invocation.invoke(); //打印结束执行时间 System.out.println(name+\"拦截器的动作----------\"+\"介绍登录Action的时间：\"+new Date()); long end=System.currentTimeMillis(); System.out.println(\"执行时间\"+(end-start)+\"ms\"); return result; &#125; &#125; 123456789101112131415161718&lt;!-- 应用所需的拦截器需要在该元素下配置 --&gt;&lt;interceptors&gt; &lt;interceptor name=\"mySimple\" class=\"org.crazyit.app.interceptor.MyFilterInterceptor\"&gt; &lt;!-- 为拦截器指定参数值 --&gt; &lt;param name=\"name\"&gt;拦截器方法拦截器&lt;/param&gt; &lt;/interceptor&gt;&lt;/interceptors&gt;&lt;action name=\"login\" class=\"org.crazyit.app.action.LoginAction\"&gt; &lt;result name=\"error\"&gt;/WEB-INF/content/eeor.jsp&lt;/result&gt; &lt;result name=\"success\"&gt;/WEB-INF/content/welcome.jsp&lt;/result&gt; &lt;!-- 配置系统的默认拦截器 --&gt; &lt;interceptor-ref name=\"defaultStack\"&gt;&lt;/interceptor-ref&gt; &lt;interceptor-ref name=\"mySimple\"&gt; &lt;param name=\"name\"&gt;改名后的拦截器&lt;/param&gt; &lt;!-- 指定execute方法不需要被拦截 --&gt; &lt;param name=\"excludeMethods\"&gt;execute&lt;/param&gt; &lt;/interceptor-ref&gt;&lt;/action&gt; Struts2中提供了方法过滤的拦截器有如下几个 TokenInterceptor、TokenSessionStoreInterceptor、DefaultWorkflowInterceptor、ValidationInterceptor 拦截器的执行顺序 在Action的控制方法执行之前，位于拦截器链前面的拦截器将先发生作用，在Action控制方法执行之后，为于拦截器链前面的拦截器将后发生作用。 拦截结果的监听器 拦截结果的监听器代码： 1234567891011public class MyPreResultListener implements PreResultListener&#123; //定义在处理result之前的行为。 @Override public void beforeResult(ActionInvocation invocation, String resultCode) &#123; //打印出执行结果 System.out.println(\"返回的逻辑视图名：\"+resultCode); &#125;&#125; 在拦截器中手动注册拦截结果监听器 12345678910111213public class BeforeResultInterceptor extends AbstractInterceptor&#123; @Override public String intercept(ActionInvocation invocation) throws Exception &#123; //将一个拦截结果的监听器注册给该监听器 invocation.addPreResultListener(new MyPreResultListener()); System.out.println(\"execute方法执行之前的拦截...\"); String result=invocation.invoke(); System.out.println(\"execute方法执行之后拦截...\"); return result; &#125;&#125; 值得注意的是，虽然beforeResule()方法中也可获得ActionInvocation实例，但千万不可通过该实例再次调用invoke()方法，如果再次调用invoke()方法，将会再次执行Action处理，Action处理后紧跟beforeResule()方法……这样会陷入死循环。 覆盖拦截器栈里特定拦截器的参数 如果需要覆盖拦截器栈里特定拦截器的参数，则在定义&lt;param&gt;元素的name属性时使用：&lt;拦截器名&gt;.&lt;参数名&gt; 代码示例 123456789101112131415161718192021222324252627&lt;interceptors&gt; &lt;interceptor name=\"mySimple\" class=\"org.crazyit.app.interceptor.BeforeResultInterceptor\"&gt; &lt;!-- 为拦截器指定参数值 --&gt; &lt;param name=\"name\"&gt;简单拦截器&lt;/param&gt; &lt;/interceptor&gt; &lt;interceptor name=\"second\" class=\"org.crazyit.app.interceptor.SecondInterceptor\"/&gt; &lt;interceptor-stack name=\"myStack\"&gt; &lt;interceptor-ref name=\"mySimple\"&gt; &lt;!-- 为拦截器指定参数值 --&gt; &lt;param name=\"name\"&gt;第一个&lt;/param&gt; &lt;/interceptor-ref&gt; &lt;interceptor-ref name=\"second\"&gt; &lt;!-- 为拦截器指定参数值 --&gt; &lt;param name=\"name\"&gt;第二个&lt;/param&gt; &lt;/interceptor-ref&gt; &lt;/interceptor-stack&gt;&lt;/interceptors&gt;&lt;action name=\"login\" class=\"org.crazyit.app.action.LoginAction\"&gt; &lt;result name=\"error\"&gt;/WEB-INF/content/eeor.jsp&lt;/result&gt; &lt;result name=\"success\"&gt;/WEB-INF/content/welcome.jsp&lt;/result&gt; &lt;!-- 配置系统的默认拦截器 --&gt; &lt;interceptor-ref name=\"defaultStack\"&gt;&lt;/interceptor-ref&gt; &lt;interceptor-ref name=\"myStack\"&gt; &lt;!-- 覆盖指定拦截器的指定参数值 --&gt; &lt;param name=\"second.name\"&gt;改名后的拦截结果监听器&lt;/param&gt; &lt;/interceptor-ref&gt;&lt;/action&gt; 使用拦截器完成权限控制 登录权限案例实现: 拦截代码的实现 1234567891011121314151617181920//权限检查拦截器继承 AbstractInterceptorpublic class AuthorityInterceptor extends AbstractInterceptor&#123; //拦截Action处理的拦截方法 @Override public String intercept(ActionInvocation invocation) throws Exception &#123; //取得请求相关的ActionContext实例 ActionContext ctx=invocation.getInvocationContext(); Map session=ctx.getSession(); //取出session里的user属性 String user=(String) session.get(\"user\"); //如果没有登录，或者登录的用户名不是crazyit.org，都返回登录 if(user!=null &amp;&amp; user.equals(\"crazyit.org\")) &#123; invocation.invoke(); &#125; ctx.put(\"tip\",\"您还没有登录\"); return Action.LOGIN; &#125; &#125; 配置文件中进行配置 1234567891011121314151617181920212223242526272829&lt;!-- 用户拦截器定义在该元素下 --&gt;&lt;interceptors&gt; &lt;!-- 定义了一个名为authority的拦截器 --&gt; &lt;interceptor name=\"authority\" class=\"org.crazyit.app.interceptor.AuthorityInterceptor\"/&gt;&lt;/interceptors&gt;&lt;!-- 定义全局Result --&gt;&lt;global-results&gt; &lt;!-- 当返回login视图名时，转入loginForm.jsp页面 --&gt; &lt;result name=\"login\"&gt;/WEB-INF/content/loginForm.jsp&lt;/result&gt;&lt;/global-results&gt;&lt;action name=\"login\" class=\"org.crazyit.app.action.LoginAction\"&gt; &lt;result name=\"error\"&gt;/WEB-INF/content//error.jsp&lt;/result&gt; &lt;result&gt;/WEB-INF/content/welcome.jsp&lt;/result&gt;&lt;/action&gt;&lt;!-- 定义一个名为viewBook的Action，其实现类为ActionSupport --&gt;&lt;action name=\"viewBook\"&gt; &lt;!-- 返回success视图名时，转入viewBook.jsp页面 --&gt; &lt;result&gt;/WEB-INF/content/viewBook.jsp&lt;/result&gt; &lt;interceptor-ref name=\"defaultStack\"/&gt; &lt;!-- 应用自定义拦截器 --&gt; &lt;interceptor-ref name=\"authority\"/&gt;&lt;/action&gt;&lt;action name=\"*\"&gt; &lt;result&gt;/WEB-INF/content/&#123;1&#125;.jsp&lt;/result&gt;&lt;/action&gt; 使用Struts2的ajax支持使用Stream类型的Result实现Ajax 案例实现1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib prefix=\"s\" uri=\"/struts-tags\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;使用JSON插件&lt;/title&gt;&lt;script type=\"text/javascript\" src=\"$&#123;pageContext.request.contextPath&#125;/jquery-3.2.1.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;s:form id=\"loginForm\"&gt; &lt;s:textfield name=\"user\" label=\"用户名\"&gt;&lt;/s:textfield&gt; &lt;s:textfield name=\"pass\" label=\"密码\"&gt;&lt;/s:textfield&gt; &lt;tr&gt; &lt;td colspan=\"2\"&gt; &lt;input id=\"loginBn\" type=\"button\" value=\"提交\"/&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/s:form&gt; &lt;div id=\"show\" style=\"display:none\"&gt;&lt;/div&gt; &lt;script type=\"text/javascript\"&gt; $(\"#loginBn\").click(function()&#123; $.get(\"login\",$(\"#loginForm\").serializeArray(), function(data,statusText)&#123; $(\"#show\").height(80) .width(230) .css(\"border\",\"1px solid black\") .css(\"border-radius\",\"15px\") .css(\"background-color\",\"#efef99\") .css(\"color\",\"#ff0000\") .css(\"padding\",\"20px\") .empty(); $(\"#show\").append(\"登录结果：\"+data+\"&lt;br/&gt;\"); $(\"#show\").show(600); &#125;,\"html\" ) &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920212223242526package org.crazyit.app.action;import java.io.ByteArrayInputStream;import java.io.InputStream;import com.opensymphony.xwork2.Action;public class LoginAction implements Action&#123; //封装请求参数的两个成员变量 private String user; private String pass; //封装输出结果二进制流 private InputStream inputStream; public InputStream getResult() &#123; return this.inputStream; &#125; //此处省略了setter和getter @Override public String execute() throws Exception &#123; //判断用户名和密码，生成响应 inputStream=(getUser().equals(\"crazyit.org\") &amp;&amp; getPass().equals(\"leegang\"))? new ByteArrayInputStream(\"恭喜你！登录成功\".getBytes(\"UTF-8\")):new ByteArrayInputStream(\"对不起，用户名，密码不匹配。\".getBytes(\"UTF-8\")); return SUCCESS; &#125; &#125; 12345678&lt;action name=\"login\" class=\"org.crazyit.app.action.LoginAction\"&gt; &lt;result type=\"stream\"&gt; &lt;!-- 指定stream生成的响应数据的类型 --&gt; &lt;param name=\"contentType\"&gt;text/html&lt;/param&gt; &lt;!-- 指定由getResult()返回输出结果的InputStream --&gt; &lt;param name=\"inputName\"&gt;result&lt;/param&gt; &lt;/result&gt;&lt;/action&gt; 除此之外，Strust2还提供了一个JSON插件，通过该插件可以更简单的完成Ajax。 JSON的基本知识 JSON主要有如下两种格式： key-value 有序集合 在Javascript中主要有两种JSON语法，一种用于创建对象，另一种用于创建数组。 使用JSON语法创建对象 语法格式如下： 123456789101112131415161718192021222324252627var object=&#123; propertyName1:propertyValue1, propertyName2:propertyValue2&#125;function Person(name,sex)&#123; this.name=name; this.sex=sex;&#125;var p=new Person(\"kk\",\"man\");alert(p.name)var p2=&#123;\"name\":\"yeeku\",\"age\":12&#125;console.log(p2.age)var p3=&#123; name:\"yeeku\", sex:\"man\", son:&#123; name:'nono', grade:1 &#125;, info:function()&#123; console.log(\"姓名：\"+this.son.name+\" 年龄：\"+this.son.grade) &#125;&#125;p3.info(); 使用JSON语法创建数组 使用教程如下 1234567891011//创建数组 方式1var a=new Array();a[0]='yeeku';a[1]='man';alert(a[0])//创建数组 方式2var b=new Array(\"yeeku\",\"man\");alert(b[1]);//创建数组 方式3var c=['yeeu','name'];alert(c[0]) 使用JSON创建数组的语法格式:arr=[value1,value2] 实现Action逻辑1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package org.crazyit.app.action;import java.util.HashMap;import java.util.Map;import org.apache.struts2.json.annotations.JSON;import com.opensymphony.xwork2.Action;public class JSONExample &#123; //模拟处理结果的成员变量 private int[] ints= &#123;10,20&#125;; private Map&lt;String,String&gt; map=new HashMap&lt;String, String&gt;(); private String customName=\"顾客\"; //封装请求参数的三个成员变量 private String field1; //`transient`修饰的成员变量不会被序列化 private transient String field2; //没有getter和setter方法的成员变量不会被序列化 private String field3; public String execute()&#123; map.put(\"name\", \"疯狂Java讲义\"); return Action.SUCCESS; &#125; //使用注解来改变该成员变量序列化后的名字 @JSON(name=\"newName\") public Map getMap() &#123; return this.map; &#125; // customName的setter和getter方法 public void setCustomName(String customName) &#123; this.customName = customName; &#125; public String getCustomName() &#123; return this.customName; &#125; // field1的setter和getter方法 public void setField1(String field1) &#123; this.field1 = field1; &#125; public String getField1() &#123; return this.field1; &#125; // field2的setter和getter方法 public void setField2(String field2) &#123; this.field2 = field2; &#125; public String getField2() &#123; return this.field2; &#125; // field3的setter和getter方法 public void setField3(String field3) &#123; this.field3 = field3; &#125; public String getField3() &#123; return this.field3; &#125; &#125; JSON插件与json类型的Result12345678910&lt;action name=\"JSONExample\" class=\"org.crazyit.app.action.JSONExample\"&gt; &lt;result type=\"json\"&gt; &lt;!-- 配置类型的json的Result --&gt; &lt;!-- 为该Result指定参数 --&gt; &lt;param name=\"noCache\"&gt;true&lt;/param&gt; &lt;param name=\"contentType\"&gt;text/html&lt;/param&gt; &lt;!-- 设置只序列Action的map属性 --&gt; &lt;!-- param name=\"root\"&gt;map&lt;/param --&gt; &lt;/result&gt;&lt;/action&gt; 实现JSP页面12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib prefix=\"s\" uri=\"/struts-tags\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;使用JSON插件&lt;/title&gt;&lt;script type=\"text/javascript\" src=\"$&#123;pageContext.request.contextPath&#125;/jquery-3.2.1.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;s:form id=\"form1\"&gt; &lt;s:textfield name=\"field1\" label=\"Field 1\"/&gt; &lt;s:textfield name=\"field2\" label=\"Field 2\"/&gt; &lt;s:textfield name=\"field3\" label=\"Field 3\"/&gt; &lt;tr&gt;&lt;td colspan=\"2\"&gt; &lt;input type=\"button\" value=\"提交\" onclick=\"gotClick();\"/&gt; &lt;/td&gt;&lt;/tr&gt; &lt;/s:form&gt; &lt;div id=\"show\"&gt;&lt;/div&gt; &lt;script type=\"text/javascript\"&gt; function gotClick()&#123; console.log(1) $(\"#show\").hide(); // 指定向JSONExample发送请求，将id为form1的表单所包含的表单控件转换为请求参数 $.post(\"JSONExample\" , $(\"#form1\").serializeArray() , // 指定回调函数 function(data , statusText) &#123; console.log(data) console.log(statusText) $(\"#show\").height(120) .width(340) .css(\"border\" , \"1px solid black\") .css(\"border-radius\" , \"15px\") .css(\"background-color\" , \"#efef99\") .css(\"color\" , \"#ff0000\") .css(\"padding\" , \"20px\") .empty(); // 遍历JavaScript对象的各属性 for(var propName in data) &#123; $(\"#show\").append(propName + \"--&gt;\" + data[propName] + \"&lt;br /&gt;\"); &#125; $(\"#show\").show(600); &#125;, // 指定服务器响应为JSON数据 \"json\"); &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"back-end","slug":"back-end","permalink":"https://CPWS.github.io/categories/back-end/"}],"tags":[{"name":"深入使用struts2","slug":"深入使用struts2","permalink":"https://CPWS.github.io/tags/深入使用struts2/"}]},{"title":"Java邮箱接口","slug":"Java邮箱接口","date":"2019-09-25T07:52:14.000Z","updated":"2019-12-05T09:00:01.221Z","comments":true,"path":"2019/09/25/Java邮箱接口/","link":"","permalink":"https://CPWS.github.io/2019/09/25/Java邮箱接口/","excerpt":"","text":"邮箱的相关标准 常见的邮件协议 SMTP（Simple Mail Transfer Protocol）：即简单邮箱传输协议，它是一组用于源地址到目的地址传送邮件的规则，由它来控制信息的中转方式。 POP3（Post Office Protocol - Version 3）: 即邮局协议版本 3，用于接收电子邮件的标准协议。","categories":[{"name":"back-end","slug":"back-end","permalink":"https://CPWS.github.io/categories/back-end/"}],"tags":[{"name":"Java邮箱接口","slug":"Java邮箱接口","permalink":"https://CPWS.github.io/tags/Java邮箱接口/"}]},{"title":"Struts2.5","slug":"Struts2-5","date":"2019-09-17T08:17:50.000Z","updated":"2019-12-05T09:02:22.146Z","comments":true,"path":"2019/09/17/Struts2-5/","link":"","permalink":"https://CPWS.github.io/2019/09/17/Struts2-5/","excerpt":"","text":"Struts2的下载和安装 为Web应用增加的Struts支持 下载和安装Struts2的步骤如下: 登录https://struts.apache.org/download.cgi#struts2520站点，下载Struts2的最新包2.5.20。 进入Struts2的解压目录的lib目录下，将一些相关的jar包导入到Web用于的/web-inf/lib路径下。 编写Web应用的web.xml配置文件，配置Struts2的核心Filter。 12345678910111213141516171819202122&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://java.sun.com/xml/ns/javaee\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd\" version=\"3.0\"&gt; &lt;display-name&gt;Struts_studyByBook01&lt;/display-name&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;welcome-file&gt;default.html&lt;/welcome-file&gt; &lt;welcome-file&gt;default.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;default.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;!-- 定义Struts2的核心Filter --&gt; &lt;filter&gt; &lt;filter-name&gt;Struts2&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.struts2.dispatcher.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;!-- 让Strut2 的核心标签库Filter拦截所有的请求 --&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;Struts2&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt; 将Struts2解压目录下的apps目录下的struts2-rest-showcase.war压缩包的struts.xml配置文件复制到web应用的src目录下。并将该配置文件修改为如下格式： 1234567891011&lt;struts&gt; &lt;!-- Overwrite Convention --&gt; &lt;constant name=\"struts.enable.DynamicMethodInvocation\" value=\"false\"/&gt; &lt;constant name=\"struts.devMode\" value=\"true\"/&gt; &lt;!-- Uncomment the lines below to use Jackson XML bindings instead of the XStream library to handle XML serialisations --&gt; &lt;package name=\"crazyit\" namespace=\"/\" extends=\"struts-default\"&gt; &lt;action name=\"*\"&gt; &lt;result&gt;/WEB-INF/content/&#123;1&#125;.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; 在Eclipse使用Struts2 首先创建一个Dynamic Web Project,也就是创建一个动态web项目。 在项目的/webcontent/WEB-INF/lib导入一些响相应的jar包。类型参考上面第2点。 打开/webcontent/WEB-INF/web.xml，编译该文件，并在其中定义Struts2核心的Filter。 在项目的src目录下定义一个struts.xml配置文件，其内容参考上面第四点。 至此，该Web应用完全具备了Struts2框架的支持。 增加登录处理 创建一个Strut2Demo的动态web项目，并且按上面的步骤依次导入相关的jar包、配置web.xml、配置struts.xml。 在/webcontent/WEB-INF/content/下添加一个名为loginForm的JSP页面,该页面的代码如下： 1234567891011121314151617&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@taglib prefix=\"s\" uri=\"/struts-tags\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;&lt;s:text name=\"loginPage\"&gt;&lt;/s:text&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;s:form action=\"login\"&gt; &lt;s:textfield name=\"username\" key=\"user\"&gt;&lt;/s:textfield&gt; &lt;s:textfield name=\"password\" key=\"pass\"&gt;&lt;/s:textfield&gt; &lt;s:submit key=\"login\"&gt;&lt;/s:submit&gt; &lt;/s:form&gt;&lt;/body&gt;&lt;/html&gt; 除此之外，还要添加一个welcome.jsp和error.jsp作为登录成功，登录失败的提示页面，它们的代码如下： 12345678910111213141516&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@taglib prefix=\"s\" uri=\"/struts-tags\"%&gt;&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt; &lt;title&gt;&lt;s:text name=\"succPage\"/&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!--成功界面--&gt; &lt;s:text name=\"succTip\"&gt; &lt;s:param&gt;$&#123;sessionScope.user&#125;&lt;/s:param&gt; &lt;/s:text&gt;&lt;br/&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314&lt;%@page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@taglib prefix=\"s\" uri=\"/struts-tags\"%&gt;&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt; &lt;title&gt;&lt;s:text name=\"errorPage\"/&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!--失败界面--&gt; &lt;s:text name=\"failTip\"/&gt;&lt;/body&gt;&lt;/html&gt; 配置Struts.xml文件 1234567891011121314&lt;struts&gt; &lt;!-- Overwrite Convention --&gt; &lt;!-- 指定全局国际化资源文件 --&gt; &lt;constant name=\"struts.enable.DynamicMethodInvocation\" value=\"false\"/&gt; &lt;constant name=\"struts.custom.i18n.resources\" value=\"mess\"/&gt; &lt;constant name=\"struts.devMode\" value=\"true\"&gt;&lt;/constant&gt; &lt;!-- Uncomment the lines below to use Jackson XML bindings instead of the XStream library to handle XML serialisations --&gt; &lt;!-- 所有的Action定义都应方法package包下 --&gt; &lt;package name=\"loginForm\" namespace=\"/\" extends=\"struts-default\"&gt; &lt;action name=\"*\"&gt; &lt;result&gt;/WEB-INF/content/&#123;1&#125;.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; 由于上面已经指定了国际化资源，所以在src目录还应该提供一个名为mess_zh_CN.properties的文件，其内容为： loginPage=登录页面 errorPage=错误页面 succPage=成功页面 failTip=对不起，您不能登录！ succTip=欢迎，{0}，您已经登录！ user=用户名 pass=密码 login=登录 把项目部署到Tomcat服务器，并在浏览器的地址栏上输入 http://localhost:8080/Strust2Demo/LoginForm，将会看到登录界面。 在Eclipse工具创建一个Java类，该Java类的类名为LoginAction，代码如下 123456789101112131415161718192021222324252627282930313233343536package org.crazyit.app.action;import com.opensymphony.xwork2.ActionContext;import com.opensymphony.xwork2.ActionSupport;public class LoginAction extends ActionSupport &#123; private static final long serialVersionUID = 1L; //定义封装请求参数的username和password成员变量 private String username; private String password; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; //定义处理用户请求的execute方法 public String execute() &#123; System.out.println(getUsername() + \"--&gt;\" + getPassword()); //当username为crazyit.org,password为leegang时即登录成功 if(getUsername().equals(\"crazyit.org\") &amp;&amp; getPassword().equals(\"leegang\")) &#123; //采用解耦的方法获取session对象 ActionContext.getContext().getSession().put(\"user\",getUsername()); return SUCCESS; &#125; return ERROR; &#125; &#125; 在struts.xml中添加一个name=&quot;login&quot;&lt;action.../&gt;代码如下： 12345&lt;action name=\"login\" class=\"org.crazyit.app.action.LoginAction\"&gt; &lt;!-- 定义三个逻辑视图和物理资源之间进行映射 --&gt; &lt;result name=\"success\"&gt;/WEB-INF/content/welcome.jsp&lt;/result&gt; &lt;result name=\"error\"&gt;/WEB-INF/content/error.jsp&lt;/result&gt;&lt;/action&gt; 至此，整个Struts2的应用已经创建完成，再次重启服务器，然后先访问loginForm，并在该页面输入用户名和密码进行登录，如果为crazyit.org、leegang，则跳转到welcome.jsp页面，否则则跳转到error.jsp。 Struts2的流程 Struts2应用的开发步骤 在web.xml文件中定义核心的Filter来拦截用户请求。 如果需要以POST的方式提交请求，则定义包含表单数据的JSP页面。如果仅仅是以GET方法发送请求，则无需通过这一步。 定义处理用户请求的Action类。 配置Action 配置处理结果和物理视图资源之间的对应关系。 编写视图资源。如果Action需要将一些数据传给视图资源，则可以借助于OGNL表达式。 经过上面6个步骤，基本完成一个Struts2的处理流程的开发，也就是可以执行一次完整的请求--&gt;响应过程。 Struts2的运行流程 Struts2的常规配置 虽然Struts2提供了Convention插件来管理Action，结果映射，但对于大部分实际开发来说还会考虑使用XML配置文件来管理Struts2的配置信息。 Struts2的默认配置文件名为struts.xml，该文件放在web应用的类加载器路径下，通常就是方法WEB-INF/classes路径下。 struts.xml配置文件的最大作用就是配置Action与请求之间的对应关系，并配置逻辑视图名与物理视图资源的对应关系，除此之外，struts.xml文件还有一些额外的配置，例如Bean配置，配置常量以及导入其他配置文件等。 常量配置 Strut2还提供了struts.properties文件来管理常量 struts.properties是一个标准的properties文件，该文件包含了系列key-value，每个key对应一个Struts2常量，该key对应的value值就是一个Struts2常量值。 Struts2配置常量总共有三种方式： 通过struts.properties文件 通过struts.xml文件 通过web.xml文件 如下struts.xml配置片段在struts.xml文件中配置一个常量，该常量即可代替struts.properties文件中struts2配置属性。 1234567891011121314151617181920212223&lt;!DOCTYPE struts PUBLIC \"-//Apache Software Foundation//DTD Struts Configuration 2.5//EN\" \"http://struts.apache.org/dtds/struts-2.5.dtd\"&gt;&lt;struts&gt; &lt;!-- Overwrite Convention --&gt; &lt;!-- 指定全局国际化资源文件 --&gt; &lt;constant name=\"struts.enable.DynamicMethodInvocation\" value=\"false\"/&gt; &lt;constant name=\"struts.custom.i18n.resources\" value=\"mess\"/&gt; &lt;constant name=\"struts.devMode\" value=\"true\"&gt;&lt;/constant&gt; &lt;!-- Uncomment the lines below to use Jackson XML bindings instead of the XStream library to handle XML serialisations --&gt; &lt;!-- 所有的Action定义都应方法package包下 --&gt; &lt;package name=\"loginForm\" namespace=\"/\" extends=\"struts-default\"&gt; &lt;action name=\"*\"&gt; &lt;result&gt;/WEB-INF/content/&#123;1&#125;.jsp&lt;/result&gt; &lt;/action&gt; &lt;action name=\"login\" class=\"org.crazyit.app.action.LoginAction\"&gt; &lt;!-- 定义三个逻辑视图和物理资源之间进行映射 --&gt; &lt;result name=\"success\"&gt;/WEB-INF/content/welcome.jsp&lt;/result&gt; &lt;result name=\"error\"&gt;/WEB-INF/content/error.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; 在web.xml配置文件中配置常量 12345678910111213&lt;filter&gt; &lt;filter-name&gt;Struts2&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.struts2.dispatcher.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;struts.custom.i18n.resources&lt;/param-name&gt; &lt;param-value&gt;mess&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;!-- 让Strut2 的核心标签库Filter拦截所有的请求 --&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;Struts2&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 包含其他配置文件 下面的struts.xml文件就通过&lt;include ../&gt;手动导入一个配置文件。 1&lt;include file=\"struts-part1.xml\"&gt;&lt;/include&gt; 被包含的配置文件应该也包含dtd信息和struts根元素等信息，且该配置文件也应该放在WEB-INF/classes/路径下。 实现Action Action类默认处理用户请求的方法：execute方法。 Action接口和ActionSupport基类 下面是一个标准的Action接口代码 1234567891011package com.opensymphony.xwork2;public interface Action &#123; public static final String SUCCESS = \"success\"; public static final String NONE = \"none\"; public static final String ERROR = \"error\"; public static final String INPUT = \"input\"; public static final String LOGIN = \"login\"; public String execute() throws Exception;&#125; 下面是ActionSupport实现类的片段代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327/* * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */package com.opensymphony.xwork2;import com.opensymphony.xwork2.inject.Container;import com.opensymphony.xwork2.inject.Inject;import com.opensymphony.xwork2.interceptor.ValidationAware;import com.opensymphony.xwork2.util.ValueStack;import org.apache.logging.log4j.LogManager;import org.apache.logging.log4j.Logger;import org.apache.struts2.StrutsConstants;import java.io.Serializable;import java.util.*;/** * Provides a default implementation for the most common actions. * See the documentation for all the interfaces this class implements for more detailed information. */public class ActionSupport implements Action, Validateable, ValidationAware, TextProvider, LocaleProvider, Serializable &#123; private static final Logger LOG = LogManager.getLogger(ActionSupport.class); private final ValidationAwareSupport validationAware = new ValidationAwareSupport(); private transient TextProvider textProvider; private transient LocaleProvider localeProvider; protected Container container; public void setActionErrors(Collection&lt;String&gt; errorMessages) &#123; validationAware.setActionErrors(errorMessages); &#125; public Collection&lt;String&gt; getActionErrors() &#123; return validationAware.getActionErrors(); &#125; public void setActionMessages(Collection&lt;String&gt; messages) &#123; validationAware.setActionMessages(messages); &#125; public Collection&lt;String&gt; getActionMessages() &#123; return validationAware.getActionMessages(); &#125; public void setFieldErrors(Map&lt;String, List&lt;String&gt;&gt; errorMap) &#123; validationAware.setFieldErrors(errorMap); &#125; public Map&lt;String, List&lt;String&gt;&gt; getFieldErrors() &#123; return validationAware.getFieldErrors(); &#125; @Override public Locale getLocale() &#123; return getLocaleProvider().getLocale(); &#125; @Override public boolean isValidLocaleString(String localeStr) &#123; return getLocaleProvider().isValidLocaleString(localeStr); &#125; @Override public boolean isValidLocale(Locale locale) &#123; return getLocaleProvider().isValidLocale(locale); &#125; public boolean hasKey(String key) &#123; return getTextProvider().hasKey(key); &#125; public String getText(String aTextName) &#123; return getTextProvider().getText(aTextName); &#125; public String getText(String aTextName, String defaultValue) &#123; return getTextProvider().getText(aTextName, defaultValue); &#125; public String getText(String aTextName, String defaultValue, String obj) &#123; return getTextProvider().getText(aTextName, defaultValue, obj); &#125; public String getText(String aTextName, List&lt;?&gt; args) &#123; return getTextProvider().getText(aTextName, args); &#125; public String getText(String key, String[] args) &#123; return getTextProvider().getText(key, args); &#125; public String getText(String aTextName, String defaultValue, List&lt;?&gt; args) &#123; return getTextProvider().getText(aTextName, defaultValue, args); &#125; public String getText(String key, String defaultValue, String[] args) &#123; return getTextProvider().getText(key, defaultValue, args); &#125; public String getText(String key, String defaultValue, List&lt;?&gt; args, ValueStack stack) &#123; return getTextProvider().getText(key, defaultValue, args, stack); &#125; public String getText(String key, String defaultValue, String[] args, ValueStack stack) &#123; return getTextProvider().getText(key, defaultValue, args, stack); &#125; /** * Dedicated method to support I10N and conversion errors * * @param key message which contains formatting string * @param expr that should be formatted * @return formatted expr with format specified by key */ public String getFormatted(String key, String expr) &#123; Map&lt;String, Object&gt; conversionErrors = ActionContext.getContext().getConversionErrors(); if (conversionErrors.containsKey(expr)) &#123; String[] vals = (String[]) conversionErrors.get(expr); return vals[0]; &#125; else &#123; final ValueStack valueStack = ActionContext.getContext().getValueStack(); final Object val = valueStack.findValue(expr); return getText(key, Arrays.asList(val)); &#125; &#125; public ResourceBundle getTexts() &#123; return getTextProvider().getTexts(); &#125; public ResourceBundle getTexts(String aBundleName) &#123; return getTextProvider().getTexts(aBundleName); &#125; public void addActionError(String anErrorMessage) &#123; validationAware.addActionError(anErrorMessage); &#125; public void addActionMessage(String aMessage) &#123; validationAware.addActionMessage(aMessage); &#125; public void addFieldError(String fieldName, String errorMessage) &#123; validationAware.addFieldError(fieldName, errorMessage); &#125; public String input() throws Exception &#123; return INPUT; &#125; /** * A default implementation that does nothing an returns \"success\". * * &lt;p&gt; * Subclasses should override this method to provide their business logic. * &lt;/p&gt; * * &lt;p&gt; * See also &#123;@link com.opensymphony.xwork2.Action#execute()&#125;. * &lt;/p&gt; * * @return returns &#123;@link #SUCCESS&#125; * @throws Exception can be thrown by subclasses. */ public String execute() throws Exception &#123; return SUCCESS; &#125; public boolean hasActionErrors() &#123; return validationAware.hasActionErrors(); &#125; public boolean hasActionMessages() &#123; return validationAware.hasActionMessages(); &#125; public boolean hasErrors() &#123; return validationAware.hasErrors(); &#125; public boolean hasFieldErrors() &#123; return validationAware.hasFieldErrors(); &#125; /** * Clears field errors. Useful for Continuations and other situations * where you might want to clear parts of the state on the same action. */ public void clearFieldErrors() &#123; validationAware.clearFieldErrors(); &#125; /** * Clears action errors. Useful for Continuations and other situations * where you might want to clear parts of the state on the same action. */ public void clearActionErrors() &#123; validationAware.clearActionErrors(); &#125; /** * Clears messages. Useful for Continuations and other situations * where you might want to clear parts of the state on the same action. */ public void clearMessages() &#123; validationAware.clearMessages(); &#125; /** * Clears all errors. Useful for Continuations and other situations * where you might want to clear parts of the state on the same action. */ public void clearErrors() &#123; validationAware.clearErrors(); &#125; /** * Clears all errors and messages. Useful for Continuations and other situations * where you might want to clear parts of the state on the same action. */ public void clearErrorsAndMessages() &#123; validationAware.clearErrorsAndMessages(); &#125; /** * A default implementation that validates nothing. * Subclasses should override this method to provide validations. */ public void validate() &#123; &#125; @Override public Object clone() throws CloneNotSupportedException &#123; return super.clone(); &#125; /** * &lt;!-- START SNIPPET: pause-method --&gt; * Stops the action invocation immediately (by throwing a PauseException) and causes the action invocation to return * the specified result, such as &#123;@link #SUCCESS&#125;, &#123;@link #INPUT&#125;, etc. * * &lt;p&gt; * The next time this action is invoked (and using the same continuation ID), the method will resume immediately * after where this method was called, with the entire call stack in the execute method restored. * &lt;/p&gt; * * &lt;p&gt; * Note: this method can &lt;b&gt;only&lt;/b&gt; be called within the &#123;@link #execute()&#125; method. * &lt;/p&gt; * * &lt;!-- END SNIPPET: pause-method --&gt; * * @param result the result to return - the same type of return value in the &#123;@link #execute()&#125; method. */ public void pause(String result) &#123; &#125; /** * If called first time it will create &#123;@link com.opensymphony.xwork2.TextProviderFactory&#125;, * inject dependency (if &#123;@link com.opensymphony.xwork2.inject.Container&#125; is accesible) into in, * then will create new &#123;@link com.opensymphony.xwork2.TextProvider&#125; and store it in a field * for future references and at the returns reference to that field * * @return reference to field with TextProvider */ protected TextProvider getTextProvider() &#123; if (textProvider == null) &#123; Container container = getContainer(); TextProviderFactory tpf = container.getInstance(TextProviderFactory.class); textProvider = tpf.createInstance(getClass()); &#125; return textProvider; &#125; protected LocaleProvider getLocaleProvider() &#123; if (localeProvider == null) &#123; Container container = getContainer(); LocaleProviderFactory localeProviderFactory = container.getInstance(LocaleProviderFactory.class); localeProvider = localeProviderFactory.createLocaleProvider(); &#125; return localeProvider; &#125; /** * TODO: This a temporary solution, maybe we should consider stop injecting container into beans */ protected Container getContainer() &#123; if (container == null) &#123; container = ActionContext.getContext().getContainer(); if (container != null) &#123; boolean devMode = Boolean.parseBoolean(container.getInstance(String.class, StrutsConstants.STRUTS_DEVMODE)); if (devMode) &#123; LOG.warn(\"Container is null, action was created manually? Fallback to ActionContext\"); &#125; else &#123; LOG.debug(\"Container is null, action was created manually? Fallback to ActionContext\"); &#125; &#125; else &#123; LOG.warn(\"Container is null, action was created out of ActionContext scope?!?\"); &#125; &#125; return container; &#125; @Inject public void setContainer(Container container) &#123; this.container = container; &#125;&#125; Action访问ServletAPI Struts2还提供了一个ActionContext类，Struts2通过该类来访问ServletAPI。下面是ActionContext类中包含的几个常用方法： Object get(Object ley)：该方法类似于调用HtppServletRequest的getAttribute(String name) Map getApplication()：返回一个Map对象，该对象模拟了该应用的ServletContext实例. static ActionContext getContext()：静态方法，获取系统的ActionContext实例。 Map getParameters()：获取所有的请求参数。类似于调用HttpServletRequest对象的getParametermap（）方法。 Map getSession()：返回一个Map对象，该Map对象模拟了HttpSession的实例。 void setApplication(Map application)：直接传入一个Map实例，将该Map实例里的key-value转换成application的属性名和属性值。 void setSession(Map session)：直接传入一个Map实例，将该Map实例里的key-value转换成session的属性名和属性值。 通过案例示范在rquest、session、application范围设置属性值12345678910111213141516171819202122&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://java.sun.com/xml/ns/javaee\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd\" version=\"3.0\"&gt; &lt;display-name&gt;Struts_studyByBook01&lt;/display-name&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;welcome-file&gt;default.html&lt;/welcome-file&gt; &lt;welcome-file&gt;default.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;default.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;!-- 定义Struts2的核心Filter --&gt; &lt;filter&gt; &lt;filter-name&gt;Struts2&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.struts2.dispatcher.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;!-- 让Strut2 的核心标签库Filter拦截所有的请求 --&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;Struts2&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt; 1234567891011121314151617&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib prefix=\"s\" uri=\"/struts-tags\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;&lt;s:text name=\"loginPage\"&gt;&lt;/s:text&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;s:form action=\"login\"&gt; &lt;s:textfield name=\"username\" key=\"user\"&gt;&lt;/s:textfield&gt; &lt;s:textfield name=\"password\" key=\"pass\"&gt;&lt;/s:textfield&gt; &lt;s:submit key=\"login\"&gt;&lt;/s:submit&gt; &lt;/s:form&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@taglib prefix=\"s\" uri=\"/struts-tags\"%&gt;&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt; &lt;title&gt;&lt;s:text name=\"succPage\"/&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; 本站访问的次数：$&#123;applicationScope.counter&#125;&lt;br&gt; $&#123;sessionScope.user&#125;，您已登录成功！ $&#123;requestScope.tip&#125;&lt;/body&gt;&lt;/html&gt; 12345678910111213&lt;%@page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@taglib prefix=\"s\" uri=\"/struts-tags\"%&gt;&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt; &lt;title&gt;&lt;s:text name=\"errorPage\"/&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; $&#123;sessionScope.user&#125;,$&#123;requestScope.tip&#125;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package org.crazyit.app.action;import com.opensymphony.xwork2.Action;import com.opensymphony.xwork2.ActionContext;public class LoginAction implements Action&#123; private String username; private String password; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; @Override public String execute() throws Exception &#123; ActionContext ctx=ActionContext.getContext(); //通过ActionContext访问application范围内的属性 Integer counter=(Integer) ctx.getApplication().get(\"counter\"); if(counter == null) &#123; counter=1; &#125;else &#123; counter = counter+1; &#125; //通过ActionContext设置application范围的属性 ctx.getApplication().put(\"counter\",counter); //通过ActionContext设置Session范围内的属性 ctx.getSession().put(\"user\",getUsername()); if(getUsername().equals(\"crazyit\") &amp;&amp; getPassword().equals(\"leegang\")) &#123; //通过ActionContext设置request范围内的属性 ctx.put(\"tip\", \"服务器提示，你已经成功登录\"); return SUCCESS; &#125; //通过ActionContext设置request范围内的属性 ctx.put(\"tip\", \"服务器提示，登录失败\"); return ERROR; &#125; &#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!--/* * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */--&gt;&lt;!-- 下面指定struts2配置文件的dtd信息 --&gt;&lt;!DOCTYPE struts PUBLIC \"-//Apache Software Foundation//DTD Struts Configuration 2.5//EN\" \"http://struts.apache.org/dtds/struts-2.5.dtd\"&gt;&lt;struts&gt; &lt;!-- Overwrite Convention --&gt; &lt;!-- 指定全局国际化资源文件 --&gt; &lt;constant name=\"struts.enable.DynamicMethodInvocation\" value=\"false\"/&gt; &lt;constant name=\"struts.custom.i18n.resources\" value=\"mess\"/&gt; &lt;constant name=\"struts.devMode\" value=\"true\"&gt;&lt;/constant&gt; &lt;!-- Uncomment the lines below to use Jackson XML bindings instead of the XStream library to handle XML serialisations --&gt; &lt;!-- 所有的Action定义都应方法package包下 --&gt; &lt;!-- package元素是struts2配置文件的核心，该元素可以出现0次或者无限次 --&gt; &lt;package name=\"loginForm\" namespace=\"/\" extends=\"struts-default\" &gt; &lt;action name=\"*\"&gt; &lt;result&gt;/WEB-INF/content/&#123;1&#125;.jsp&lt;/result&gt; &lt;/action&gt; &lt;action name=\"login\" class=\"org.crazyit.app.action.LoginAction\"&gt; &lt;!-- 处理结果返回为error,则对应于 /WEB-INF/content/error.jsp视图资源 --&gt; &lt;result name=\"error\"&gt; /WEB-INF/content/error.jsp&lt;/result&gt; &lt;!-- 处理结果返回为success,则对应于 /WEB-INF/content/welcome.jsp视图资源 --&gt; &lt;result name=\"success\"&gt; /WEB-INF/content/welcome.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; mess_zh_CN.properties的文件，其内容为： loginPage=登录页面 errorPage=错误页面 succPage=成功页面 failTip=对不起，您不能登录！ succTip=欢迎，{0}，您已经登录！ user=用户名 pass=密码 login=登录 从以上案列可以看出，Struts2的Action设计非常优秀，它既可以与ServletAPI解耦，也可以脱离Web容器运行，也可以脱离Web容器测试，又可以用简单的方式来操作request、session、application范围内的属性。 Action直接访问ServletAPI 虽然struts2提供了ActionContext来访问ServletAPI，但是这种访问毕竟不是直接获得Servlet API实例。为了在Action中直接访问ServletAPI，Struts2还提供如下几个接口：ServletContextAware：实现该接口的Action可以直接访问Web应用的ServletContext实例。ServletRequestAware：实现该接口的Action可以直接访问Web应用的HttpServletRequest实例。ServletResponseAware：实现该接口的Action可以直接访问Web应用的HttpServletResponse实例。 案列：以ServletResponseAware为例,如何在Action中访问HttpServletResponse123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172package org.crazyit.app.action;import javax.servlet.http.Cookie;import javax.servlet.http.HttpServletResponse;import org.apache.struts2.ServletActionContext;import org.apache.struts2.interceptor.ServletResponseAware;import com.opensymphony.xwork2.Action;import com.opensymphony.xwork2.ActionContext;/*** * 解耦方式 * @author 1huangzewei * */public class LoginAction02 implements Action,ServletResponseAware&#123; private String username; private String password; private HttpServletResponse response; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; //重写ServletResponseAware接口必须实现的方法 @Override public void setServletResponse(HttpServletResponse response) &#123; // TODO Auto-generated method stub this.response=response; &#125; @Override public String execute() throws Exception &#123; System.out.println(\"---- LoginAction2---\"); // TODO Auto-generated method stub ActionContext ctx=ActionContext.getContext(); //通过ActionContext访问application范围内的属性 Integer counter=(Integer) ctx.getApplication().get(\"counter\"); if(counter == null) &#123; counter=1; &#125;else &#123; counter = counter+1; &#125; //通过ActionContext设置application范围的属性 ctx.getApplication().put(\"counter\", counter); // 通过ActionContext设置Session范围内的属性 ctx.getSession().put(\"user\", getUsername()); if (getUsername().equals(\"crazyit\") &amp;&amp; getPassword().equals(\"leegang\")) &#123; //通过Response添加cookie Cookie c=new Cookie(\"user\", getUsername()); c.setMaxAge(60*60); response.addCookie(c); //通过ActionContext设置request范围的属性 ctx.put(\"tip\", \"服务器提示，你已经成功登录\"); return SUCCESS; &#125; // 通过ActionContext设置request范围内的属性 ctx.put(\"tip\", \"服务器提示，登录失败\"); return ERROR; &#125; &#125; 123456789101112131415&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@taglib prefix=\"s\" uri=\"/struts-tags\"%&gt;&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt; &lt;title&gt;&lt;s:text name=\"succPage\"/&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; 本站访问的次数：$&#123;applicationScope.counter&#125;&lt;br&gt; &lt;!-- $&#123;sessionScope.user&#125; --&gt;$&#123;user&#125;，您已登录成功！ $&#123;requestScope.tip&#125;&lt;/body&gt;&lt;/html&gt; ServletActionContext访问ServletAPI 除此之外，为了能直接访问ServletAPI，Struts2还提供了一个ServletActionContext工具类。该类包含如下几个静态方法： static PageContext getPageContext()：取得web应用的pageContext对象。 static HttpServletRequest getRequest()：取得web应用的request对象。 static HttpServletResponse getResponse()：取得web应用的response对象。 static ServletContext getServletContext()：取得web应用的ServletContext对象。 案列，以static HttpServletResponse getResponse()为例，获取response实例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package org.crazyit.app.action;import javax.servlet.http.Cookie;import javax.servlet.http.HttpServletResponse;import org.apache.struts2.ServletActionContext;import org.apache.struts2.interceptor.ServletResponseAware;import com.opensymphony.xwork2.Action;import com.opensymphony.xwork2.ActionContext;/*** * 解耦方式 * @author 1huangzewei * */public class LoginAction03&#123; private String username; private String password; private HttpServletResponse response; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; @Override public String execute() throws Exception &#123; System.out.println(\"---- LoginAction2---\"); // TODO Auto-generated method stub ActionContext ctx=ActionContext.getContext(); //通过ActionContext访问application范围内的属性 Integer counter=(Integer) ctx.getApplication().get(\"counter\"); if(counter == null) &#123; counter=1; &#125;else &#123; counter = counter+1; &#125; //通过ActionContext设置application范围的属性 ctx.getApplication().put(\"counter\", counter); // 通过ActionContext设置Session范围内的属性 ctx.getSession().put(\"user\", getUsername()); if (getUsername().equals(\"crazyit\") &amp;&amp; getPassword().equals(\"leegang\")) &#123; //通过Response添加cookie Cookie c=new Cookie(\"user\", getUsername()); c.setMaxAge(60*60); ServletActionContext().getResponse().addCookie(c); //通过ActionContext设置request范围的属性 ctx.put(\"tip\", \"服务器提示，你已经成功登录\"); return SUCCESS; &#125; // 通过ActionContext设置request范围内的属性 ctx.put(\"tip\", \"服务器提示，登录失败\"); return ERROR; &#125; &#125; 配置Action 实现了Action处理类之后，就可以在struts.xml文件中配置该Action了。配置Action就是让Struts2知道哪个Action处理哪个请求，也就是完成用户请求和Action之间的对应关系。 包和命名空间 定义&lt;package ../&gt;元素时可以指定如下几个元素： name：必须元素，该属性指定该包的名字，该名字是该包被其他包引用的key； extends：可选属性，该属性指定该包继承其他包。继承其他包，可以继承其他包中的Action定义、拦截器定义等。 namespace：可选元素。该属性定义该包的命名空间。 abstract：可选元素。它指定该包是否为抽象包。抽象包不能包含Action定义。 Action的基本配置 定义&lt;action ../ &gt;元素时可以指定如下几个元素： name：必须元素，该属性定义该action的名字，也定义了处理该请求的url class：非必须元素。用于指定action的实现类，如果没有定义该属性，系统则默认使用ActionSupport作为处理类。 method：非必须元素。该属性用于指定处理类中的业务处理方法的方法名，如果没有定义该属性，系统则默认使用execute。 配置Action时应该配置逻辑视图名与物理视图名之间的对应关系，而配置他们之间的映射关系，是通过&lt;result ../&gt;元素来完成。 使用Action的动态方法调用 动态方法调用采用如下方式:ActionName!method.action，其中actionName指定的是要提交到哪个Action，method指定的是交给哪个方法调用。 案列实现： 登录注册界面 123456789101112131415161718192021222324&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib prefix=\"s\" uri=\"/struts-tags\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;&lt;s:text name=\"loginPage\"&gt;&lt;/s:text&gt;&lt;/title&gt;&lt;script&gt; function regist()&#123; //获得第1个表单页面 targetForm=document.forms[0]; targetForm.action=\"login02!regist\" &#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=\"login02\"&gt; 用户名：&lt;input name=\"username\"/&gt;&lt;br/&gt; 密 码：&lt;input name=\"password\"/&gt;&lt;br/&gt; &lt;input type=\"submit\" value=\"登录\"/&gt;&lt;input type=\"submit\" value=\"注册\" onclick=\"regist();\"/&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 业务处理类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package org.crazyit.app.action;import com.opensymphony.xwork2.Action;import com.opensymphony.xwork2.ActionContext;import com.opensymphony.xwork2.ActionSupport;public class LoginRegisterAction extends ActionSupport&#123; //封装用户请求参数的两个成员变量 private String username; private String password; //封装处理结果的tip成员变量 private String tip; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public String getTip() &#123; return tip; &#125; public void setTip(String tip) &#123; this.tip = tip; &#125; //Action包含的注册控制逻辑 public String regist() &#123; System.out.println(\"------regist------\"); ActionContext.getContext().getSession().put(\"user\", getUsername()); setTip(\"恭喜您,\"+getUsername()+\"，您已经注册成功\"); return Action.SUCCESS; &#125; //Action包含的登录业务逻辑 public String execute() &#123; System.out.println(\"------login------\"); if(getUsername().equals(\"crazyit.org\") &amp;&amp; getPassword().equals(\"leegang\")) &#123; ActionContext.getContext().getSession().put(\"user\", getUsername()); setTip(\"欢迎,\"+getUsername()+\"，您已经登录成功\"); return Action.SUCCESS; &#125; return Action.ERROR; &#125;&#125; 配置文件 1234567891011121314151617181920212223&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!-- 下面指定struts2配置文件的dtd信息 --&gt;&lt;!DOCTYPE struts PUBLIC \"-//Apache Software Foundation//DTD Struts Configuration 2.5//EN\" \"http://struts.apache.org/dtds/struts-2.5.dtd\"&gt;&lt;struts&gt; &lt;!-- 指定全局国际化资源文件 --&gt; &lt;constant name=\"struts.enable.DynamicMethodInvocation\" value=\"true\"/&gt; &lt;constant name=\"struts.custom.i18n.resources\" value=\"mess\"/&gt; &lt;constant name=\"struts.devMode\" value=\"true\"&gt;&lt;/constant&gt; &lt;package name=\"loginForm\" namespace=\"/\" extends=\"struts-default\" &gt; &lt;action name=\"*\"&gt; &lt;result&gt;/WEB-INF/content/&#123;1&#125;.jsp&lt;/result&gt; &lt;/action&gt; &lt;action name=\"login02\" class=\"org.crazyit.app.action.LoginRegisterAction\"&gt; &lt;!-- 处理结果返回为error,则对应于 /WEB-INF/content/error.jsp视图资源 --&gt; &lt;result name=\"error\"&gt; /WEB-INF/content/error.jsp&lt;/result&gt; &lt;!-- 处理结果返回为success,则对应于 /WEB-INF/content/welcome.jsp视图资源 --&gt; &lt;result name=\"success\"&gt; /WEB-INF/content/welcome.jsp&lt;/result&gt; &lt;allowed-methods&gt;regist&lt;/allowed-methods&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; 成功页面 12345678910111213141516&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@taglib prefix=\"s\" uri=\"/struts-tags\"%&gt;&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt; &lt;title&gt;&lt;s:text name=\"succPage\"/&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 本站访问的次数：$&#123;applicationScope.counter&#125;&lt;br&gt; --&gt; &lt;!-- $&#123;sessionScope.user&#125; --&gt;$&#123;user&#125;，您已登录成功！ $&#123;sessionScope.tip&#125;&lt;/body&gt;&lt;/html&gt; 结果 指定Method属性及其通配符 在配置&lt;action ../&gt;元素时，允许在指定name使用模式字符串，接下来在method，class，以及&lt;result../&gt;子元素中使用{N}的形式来表示前面第N个所匹配的字符串。 在Action的name属性中使用模式通配符后，可以用一个&lt;action../&gt;代替多个逻辑Action。 注意：因为除非请求的URL与action与name属性绝对相同，否则将按先后顺序来决定由哪个action来处理用户请求。因此应该讲name=&quot;*&quot;的Action配置放在最后，否则，Struts2将使用该Action来处理所有希望使用模式字符串匹配的请求。 配置默认的Action与配置默认的处理类 默认Action：&lt;default-action-ref name=&quot;ActionName&quot; /&gt; 默认处理类：&lt;default-class-ref name=&quot;className&quot; /&gt; 配置处理结果 理解处理结果 Action处理完用户的请求后，并未把请求直接转发给任何具体的视图资源，而是返回一个逻辑视图（逻辑视图就是一个简单的字符串），Struts2框架收到这个逻辑视图，，把请求转发到具体的物理视图资源，然后把处理结果展示给用户看。 配置结果 Struts2框架在struts.xml文件中使用&lt;result../&gt;元素来配置结果。 配置&lt;result ../&gt;元素时需要指定如下两个属性: name：该属性指定所配置的逻辑视图名。 type：该属性指定结果类型。 Struts2支持的结果类型 plainText结果类型：将实际的视图资源的源代码显示到客户端浏览器上。 案例: Action实现类 1234567891011121314151617package org.crazyit.app.action;import com.opensymphony.xwork2.ActionSupport;public class LoginAction extends ActionSupport&#123; private static final long serialVersionUID = 1L; //用于封装请求的username private String username; //username属性的getter和setter public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; &#125; struts.xml配置文件 123456789101112131415161718192021&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE struts PUBLIC \"-//Apache Software Foundation//DTD Struts Configuration 2.5//EN\" \"http://struts.apache.org/dtds/struts-2.5.dtd\"&gt;&lt;struts&gt; &lt;constant name=\"struts.devMode\" value=\"true\"&gt;&lt;/constant&gt; &lt;package name=\"loginForm\" namespace=\"/\" extends=\"struts-default\"&gt; &lt;action name=\"*\"&gt; &lt;result&gt;/WEB-INF/content/&#123;1&#125;.jsp&lt;/result&gt; &lt;/action&gt; &lt;action name=\"login\" class=\"org.crazyit.app.action.LoginAction\"&gt; &lt;!-- 指定Result的类型为PlainText --&gt; &lt;result type=\"plainText\"&gt; &lt;!-- 指定实际的视图资源 --&gt; &lt;param name=\"location\"&gt;/WEB-INF/content/welcome.jsp&lt;/param&gt; &lt;!-- 指定使用指定字符串来处理页面代码 --&gt; &lt;param name=\"charSet\"&gt;UTF-8&lt;/param&gt; &lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; 结果页面 12345678910111213&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib prefix=\"s\" uri=\"/struts-tags\" %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;欢迎页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;s:property value=\"username\"/&gt;&lt;/body&gt;&lt;/html&gt; 效果图： 使用plainText结果类型可以指定如下两个参数 location：指定实际的视图资源。 charSet：指定输出页面是所使用的的字符集。 redirect结果类型: 使用该属性之后，会丢失所有的请求参数，请求属性，当然也丢失了action的处理结果。 案例：将上面的配置文件修改一下 1234567891011121314&lt;struts&gt; &lt;constant name=\"struts.devMode\" value=\"true\"&gt;&lt;/constant&gt; &lt;package name=\"loginForm\" namespace=\"/\" extends=\"struts-default\"&gt; &lt;action name=\"*\"&gt; &lt;result&gt;/WEB-INF/content/&#123;1&#125;.jsp&lt;/result&gt; &lt;/action&gt; &lt;action name=\"login\" class=\"org.crazyit.app.action.LoginAction\"&gt; &lt;!-- 指定Result的类型为PlainText --&gt; &lt;result type=\"redirect\"&gt; /welcome.jsp &lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; 配置一个redirect结果类型时，可以为其指定如下两个参数 location：该Action指定Action处理完用户请求后跳转的地址。 parse：该参数指定是否允许location参数值中使用表达式,默认值为 true; redirectAction结果类型 redirectAction实现在一个Action处理结束时，直接将请求重定向到里一个Action。 配置redirectAction结果类型时，可以指定如下两个参数: actionName：该参数指定重定向的Action名。 namespache：该参数指定需要重定向的Action所在的命名空间。 redirect与redirectAction，这两种结果都会产生新的请求，区别在于前者重定向的是实际视频的资源，后者重向定的是另一个Action，两种结果类型都会丢失前一个Action的请求参数，请求属性以及处理的结果。 动态结果 动态结果的含义是指在指定实际视图资源使用了表达式语法。Action属性值决定物理视图资源 配置&lt;result ../&gt;元素时，不仅可以使用${N}表达式来指定实际视图资源，还可以使用${属性名}方法来指定物理视图资源。 案例 业务处理类：MyAction.java 1234567891011121314151617181920package org.crazyit.app.action;import com.opensymphony.xwork2.ActionSupport;public class MyAction extends ActionSupport&#123; private static final long serialVersionUID = 1L; private String target; public String getTarget() &#123; return target; &#125; public void setTarget(String target) &#123; this.target = target; &#125; public String execute() &#123; addActionMessage(\"恭喜您，您已经成功转向!\"); return SUCCESS; &#125;&#125; 配置文件 struts.xml 123456789101112131415161718&lt;struts&gt; &lt;constant name=\"struts.devMode\" value=\"true\"&gt;&lt;/constant&gt; &lt;constant name=\"struts.enable.DynamicMethodInvocation\" value=\"true\"/&gt; &lt;constant name=\"struts.custom.i18n.resources\" value=\"mess\"/&gt; &lt;package name=\"shop\" namespace=\"/\" extends=\"struts-default\" &gt; &lt;action name=\"*\"&gt; &lt;result&gt;/WEB-INF/content/&#123;1&#125;.jsp&lt;/result&gt; &lt;/action&gt; &lt;action name=\"myAction\" class=\"org.crazyit.app.action.MyAction\"&gt; &lt;!-- 配置结果集时，采用OGNL表达式来指定实际视图资源 --&gt; &lt;result&gt;/WEB-INF/content/$&#123;target&#125;.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; JSP页面 ok.jsp 12345678910111213141516&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt; &lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;转向页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=\"myAction\" method=\"post\"&gt; 转入的目标页面：&lt;input type=\"text\" name=\"target\"/&gt;&lt;br/&gt; &lt;input type=\"submit\" value=\"转入\"/&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 成功页面:welcome.jsp 12345678910111213&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib prefix=\"s\" uri=\"/struts-tags\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;成功页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;s:actionmessage/&gt;&lt;/body&gt;&lt;/html&gt; 全局结果 配置全局结果可以采用&lt;global-result ../&gt;标签完成。全局结果集多所有的Action有效。使用PreResultListener PreResultListener是一个监听器接口，它可以在Action完成处理控制后，系统转入实际的物理视图之间被回调。 添加PreResultListener监听器通过Invocation的addPreResultListener()方法完成。 案例，在之前的项目中添加如下代码即可：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package org.crazyit.app.action;import com.opensymphony.xwork2.Action;import com.opensymphony.xwork2.ActionContext;import com.opensymphony.xwork2.ActionInvocation;import com.opensymphony.xwork2.ActionSupport;import com.opensymphony.xwork2.interceptor.PreResultListener;public class LoginRegisterAction extends ActionSupport&#123; private static final long serialVersionUID = 1L; //封装用户请求参数的两个成员变量 private String username; private String password; //封装处理结果的tip成员变量 private String tip; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public String getTip() &#123; return tip; &#125; public void setTip(String tip) &#123; this.tip = tip; &#125; //Action包含的注册控制逻辑 public String regist() &#123; System.out.println(\"------regist------\"); ActionContext.getContext().getSession().put(\"user\", getUsername()); setTip(\"恭喜您,\"+getUsername()+\"，您已经注册成功\"); return Action.SUCCESS; &#125; //Action包含的登录业务逻辑 public String execute() &#123; System.out.println(\"------login------\"); //添加PreResultListener接口监听器 ActionInvocation invocation=ActionContext.getContext().getActionInvocation(); invocation.addPreResultListener(new PreResultListener() &#123; @Override public void beforeResult(ActionInvocation invocation, String resultCode) &#123; // TODO Auto-generated method stub System.out.println(\"返回的逻辑视图名字为：\"+resultCode); //在返回Result之前加入一个额外的数据 invocation.getInvocationContext().put(\"extra\", new java.util.Date()+\"由\"+resultCode+\"逻辑视图名转入\"); &#125; &#125;); if(getUsername().equals(\"crazyit.org\") &amp;&amp; getPassword().equals(\"leegang\")) &#123; ActionContext.getContext().getSession().put(\"user\", getUsername()); setTip(\"欢迎,\"+getUsername()+\"，您已经登录成功\"); return Action.SUCCESS; &#125; return Action.ERROR; &#125;&#125; 配置Struts2的异常处理Struts2的异常处理机制 为了使用Struts2的异常处理机制，必须打开Struts2的异常映射功能,开启异常映射功能需要一个拦截器。下面是struts-default.xml文件中开启异常映射功能的配置文件。12345678&lt;interceptors&gt; &lt;interceptor name=\"exception\" class=\"com.opensymphony.xwork2.interceptor.ExceptionMappingInterceptor\"&gt;&lt;/interceptor&gt; &lt;!--Struts2默认的拦截器栈--&gt; &lt;interceprot-stack name=\"defaultStack\"&gt; &lt;interceptor-ref name=\"exception\" /&gt; &lt;/interceptor-stack&gt;&lt;/interceptors&gt; 声明式异常捕获 Struts2的异常处理机制是通过在struts.xml文件中配置&lt;exception-mapping ../&gt;元素完成的。配置该文件时，需要指定如下两个属性： exception：此属性指定该异常映射所映射所设置的异常类型。 result：此属性指定Action出现异常时，系统返回result属性值对应的逻辑视图名。 根据&lt;exception-mapping&gt;出现位置的不同，异常映射又可以分为如下两种： 局部异常映射：将&lt;exception-mapping&gt;作为Action的子元素配置。 全局异常映射：将&lt;exception-mapping&gt;作为&lt;global-exception-mappings&gt;的子元素配置。 案例123456789101112131415package org.crazyit.app.exception;public class MyException extends Exception&#123; /** * */ private static final long serialVersionUID = 1L; public MyException() &#123; super(); &#125; public MyException(String msg) &#123; super(msg); &#125;&#125; 123456789101112131415161718192021222324252627package org.crazyit.app.exception;import com.opensymphony.xwork2.ActionSupport;public class LoginAction extends ActionSupport&#123; private static final long serialVersionUID = 1L; //封装请求参数的username和password private String username; private String password; private String tip; ... public String execute() throws Exception&#123; System.out.println(\"exception\"); if(getUsername().equalsIgnoreCase(\"user\")) &#123; throw new MyException(\"自定义异常\"); &#125; if(getUsername().equalsIgnoreCase(\"sql\")) &#123; throw new java.sql.SQLException(\"用户名不能为sql\"); &#125; if(getUsername().equals(\"crazyit.org\") &amp;&amp; getPassword().equals(\"leegang\")) &#123; return SUCCESS; &#125; return ERROR; &#125;&#125; 1234567891011121314151617181920212223242526272829 &lt;!-- 配置全局结果集 --&gt;&lt;global-results&gt; &lt;result name=\"sql\"&gt;/WEB-INF/content/exception.jsp&lt;/result&gt; &lt;result name=\"root\"&gt;/WEB-INF/content/exception.jsp&lt;/result&gt;&lt;/global-results&gt; &lt;!-- 配置全局异常映射 --&gt;&lt;global-exception-mappings&gt; &lt;exception-mapping result=\"sql\" exception=\"java.sql.SQLException\"&gt;&lt;/exception-mapping&gt; &lt;exception-mapping result=\"root\" exception=\"java.lang.Exception\"&gt;&lt;/exception-mapping&gt;&lt;/global-exception-mappings&gt;&lt;action name=\"*\"&gt; &lt;result&gt;/WEB-INF/content/&#123;1&#125;.jsp&lt;/result&gt;&lt;/action&gt;&lt;action name=\"login\" class=\"org.crazyit.app.action.LoginAction02\"&gt;&lt;!-- 处理结果返回为error,则对应于 /WEB-INF/content/error.jsp视图资源 --&gt; &lt;result name=\"error\"&gt; /WEB-INF/content/error.jsp&lt;/result&gt; &lt;!-- 处理结果返回为success,则对应于 /WEB-INF/content/welcome.jsp视图资源 --&gt; &lt;result name=\"success\"&gt; /WEB-INF/content/welcome.jsp&lt;/result&gt;&lt;/action&gt;&lt;action name=\"login02\" class=\"org.crazyit.app.exception.LoginAction\"&gt; &lt;!-- 定义局部异常映射 --&gt; &lt;exception-mapping result=\"my\" exception=\"org.crazyit.app.exception.MyException\"&gt;&lt;/exception-mapping&gt; &lt;result name=\"my\"&gt;/my.jsp&lt;/result&gt; &lt;!-- 处理结果返回为error,则对应于 /WEB-INF/content/error.jsp视图资源 --&gt; &lt;result name=\"error\"&gt; /WEB-INF/content/error.jsp&lt;/result&gt; &lt;!-- 处理结果返回为success,则对应于 /WEB-INF/content/welcome.jsp视图资源 --&gt; &lt;result name=\"success\"&gt; /WEB-INF/content/welcome.jsp&lt;/result&gt; &lt;allowed-methods&gt;regist&lt;/allowed-methods&gt; &lt;/action&gt; 输出异常信息 为了在异常页面中显示异常信息，可以使用Struts2的如下标签来输出异常信息 &lt;s:property value=&quot;exception&quot;/&gt;：输出异常对象本身。 &lt;s:property value=&quot;exceptionStack&quot;/&gt;：输出异常堆本身。 还可以使用&lt;s:property value=&quot;exception.message&quot;/&gt;来输出异常message信息。 Convention插件与约定支持Action的搜索和映射约定 convention会把如下两种Java类当成Action类。 所有实现了com.opensymphony.xwork2.Action的Java类 所有类名以Action结尾的Java类。 按约定映射ResultAction链的约定自动重加载映射 Convention完全支持自动重载映射，只要为Struts2配置如下两个常量即可 配置Struts2处于开发者模式：&lt;constant name=&quot;struts.devMode&quot; value=&quot;true&quot;&gt;&lt;/constant&gt; 配置Convention插件自动重加载映射：&lt;constant name=&quot;struts.convention.classes.reloaad&quot; value=&quot;true&quot;&gt;&lt;/constant&gt; Convention插件的相关常量Convention插件的相关注解 使用Struts2的国际化 Struts2的国际化可以按照如下步骤进行： 让系统加载国际化资源文件。加载国家化资源文件有两种方式: 自动加载：Action范围的国际化资源文件，包范围的国家化资源文件由系统自动加载。 手动加载：JSP范围的国际化资源文件、全局范围的国际化资源文件，分别使用标签、配置常量的方式来手动加载。 输出国际化。Struts2输出国家化的消息同样有两种方式： 在视图页面上输出国家化消息，需要使用Struts2的标签库。 在Action类中输出国际化消息，需要使用ActionSupport的getText()方法来完成。 视图页面的国际化 在Jsp页面中指定国际化资源需要借助Struts2的另外一个标签：&lt;s:i18n&gt; 案例实现: 定义两个国际化资源文件，其路径分别为：/JSPResources/src/viewResources/loginForm_en_US与/JSPResources/src/viewResources/loginForm_zh_CN.properties 两个包的内容分别为： 12345# loginForm_en_US.propertiesloginPage=JSP Message:Login Pageuser=JSP Message:User Namepass=JSP Message:User Passlogin=JSP Message:Login 12345# loginForm_zh_CN.propertiesloginPage=JSP Message:Login Pageuser=JSP Message:User Namepass=JSP Message:User Passlogin=JSP Message:Login 定义一个JSP页面，并在其中使用国际化资源文件，其路径为：/JSPResources/WebContent/WEB-INF/content/success.jsp 12345678910111213141516171819202122&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib prefix=\"s\" uri=\"/struts-tags\"%&gt;&lt;!DOCTYPE html&gt;&lt;!-- 加载baseName为viewResource包下的baseName为loginForm的国际化资源文件 --&gt;&lt;s:i18n name=\"viewResources.loginForm\"&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;!-- 使用text标签来输出国际化信息 --&gt; &lt;title&gt;&lt;s:text name=\"loginPage\"&gt;&lt;/s:text&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;s:form action=\"login\"&gt; &lt;!-- 在表单页面中，使用key属性来输出国际化信息 --&gt; &lt;s:textfield name=\"username\" key=\"user\" /&gt; &lt;s:textfield name=\"password\" key=\"pass\" /&gt; &lt;s:submit key=\"login\"/&gt; &lt;/s:form&gt; &lt;/body&gt;&lt;/html&gt;&lt;/s:i18n&gt; 定义配置文件struts.xml来访问页面 12345678910111213141516171819&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE struts PUBLIC \"-//Apache Software Foundation//DTD Struts Configuration 2.5//EN\" \"http://struts.apache.org/dtds/struts-2.5.dtd\"&gt;&lt;struts&gt; &lt;constant name=\"struts.devMode\" value=\"true\"&gt;&lt;/constant&gt; &lt;constant name=\"struts.enable.DynamicMethodInvocation\" value=\"true\"/&gt; &lt;package name=\"shop\" namespace=\"/\" extends=\"struts-default\" &gt; &lt;action name=\"*\"&gt; &lt;result&gt;/WEB-INF/content/&#123;1&#125;.jsp&lt;/result&gt; &lt;/action&gt; &lt;action name=\"login\"&gt; &lt;result&gt;/WEB-INF/content/success.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; 启动服务器，在页面查看效果. Action的国际化 为Action单独指定国际化资源文件的方法是：在Action类文件所在的路径下建立多个文件名为ActionName_language_country.properties. Struts2的国际资源文件是由系统自动加载。 使用包范围的国际化资源 包范围的国际化资源可以被该包下的所有Action使用。 包范围的国际化资源文件的文件名：package_&lt;language&gt;_&lt;country&gt;.properties使用全局国际化资源 不管是在struts.xml文件中配置常量，还是在struts.properties文件中配置常量，只需要配置struts.custom.i18n.resources常量即可加载全局国际化资源文件。输出带占位符的国际化消息 国际化消息可能包含占位符，这些占位符必须使用参数来填充。加载资源文件的顺序 使用Struts2的标签库Struts2标签库概述 Struts2的标签都定义在URI为/struts-tags的空间下。 从大范围上看，可以将Struts2标签分成如下两类： UI(User Interface，用户界面)标签：主要用于生成HTML元素的标签。 非UI标签：主要用于数据访问、逻辑控制等的标签。 对于UI标签，可以分为如下两类： 标签标签：主要用于生成HTML页面的form元素，以及普通表单元素的标签。 非表单标签：主要用于生成页面上的树、Tab页等标签。 对于非UI标签，也可以分为如下两类： 流程控制标签：主要包含用于生成分支、循环等流程控制的标签。 数据访问标签：主要包含用于输出ValueStack中的值，完成国际化等功能的标签。 使用Struts2标签 Struts2的标签库定义文件存放在struts2-core.2.5.20.jar包下的struts-tags.tld文件 在JSP页面中使用Struts2标签的步骤 在JSP页面中导入Struts2的标签库，例如：&lt;%@ taglib prefix=&quot;s&quot; uri=&quot;/struts-tags&quot; %&gt;；其中prefix指定标签的前缀，uri指定使用哪个核心标签库。 在JSP页面中使用相关标签：例如：&lt;s:text name=&quot;hello&quot;/&gt; 。 Struts2的OGNL表达式语言 OGNL(Object-Graph Navigation Language：图像导航语言) OGNL,如果需要访问的对象属于根对象，则可以直接访问该属性，如果不是则需要使用一个前缀# 开发中，可以在页面中添加&lt;s:debug/&gt;标签，来查看属性是为value stack还是stack contextOGNL中的集合操作 很多时候，可能需要一个集合对象（例如List对象，或者Map对象），使用OGNL表达式可以直接创建集合对象。 直接创建List集合的语法：{e1,e2,e3} 直接创建Map集合的语法：#{key1:value1,key2:value2} 对于集合，OGNL提供了两个运算符：in和not in 除此之外，OGNL还允许通过某个规则取得集合的子集。取得集合的子集时有如下三个操作： ?: 取出所有符合选择逻辑的元素。 ^: 取出符合选择逻辑的第一个元素。 $: 取出符合选择逻辑的最后一个元素。 访问静态成员1&lt;constant name=\"struts.ognl.allowStaticMethodAccess\" value=\"true\"&gt;&lt;/constant&gt; 1234访问静态方法：&lt;s:property value=\"@org.crazyit.struts2.action.DemoAction@s()\"/&gt;&lt;br&gt;访问静态属性：&lt;s:property value=\"@org.crazyit.struts2.action.DemoAction@str\"/&gt;&lt;br&gt;生成一个伪随机数:&lt;s:property value=\"@java.lang.Math@random()\"/&gt;&lt;br&gt;圆周率的值:&lt;s:property value=\"@java.lang.Math@PI\"/&gt; Lambda表达式 Lambda表达式支持:&lt;s:property value=&quot;#fib =: [#this == 0?0:#this==1?1:#fib(#this-2)+#fib(#this-1)],#fib(11)&quot;/&gt;控制标签 控制标签有9个 if：用于控制选择输出的标签。 elseIf/elseif：与if标签结合使用，用于控制选择输出的标签。 else：与if标签结合使用，用于控制选择输出的标签。 append：用于将多个集合拼接成一个新的集合。 generator：它是一个字符串解析器，用于讲一个字符串解析成一个集合。 iterator：这是一个迭代器，用于将集合迭代输出。 merge：用于将多个集合合拼成一个新的集合。但与append的拼接方法有所不同。 sort：这个标签用于对集合进行排序。 subset：这个标签用于截取集合的部分元素，形成新的子集合。 if/elseif/else标签 三个标签结合的语法格式如下： 12345678910&lt;s:if test=\"表达式\"&gt; 标签体&lt;/s:if&gt;&lt;s:elseif test=\"表达式\"&gt; 标签体&lt;/s:elseif&gt;...&lt;s:else&gt; 标签体&lt;/s:else&gt; 案列实现: 1234567891011121314151617181920212223242526272829&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib prefix=\"s\" uri=\"/struts-tags\" %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;分支控制&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 向Stack Context中定义一个属性age,并取值为 29 --&gt; &lt;s:set var=\"age\" value=\"29\"&gt;&lt;/s:set&gt; &lt;!-- 如果Stack Context中的age属性大于60 --&gt; &lt;s:if test=\"#age&gt;60\"&gt; 老年人 &lt;/s:if&gt; &lt;!-- 如果Stack Context中的age属性大于35 --&gt; &lt;s:elseif test=\"#age&gt;35\"&gt; 中年人 &lt;/s:elseif&gt; &lt;!-- 如果Stack Context中的age属性大于15 --&gt; &lt;s:elseif test=\"#age&gt;15\"&gt; 青年人 &lt;/s:elseif&gt; &lt;s:else&gt; 少年人 &lt;/s:else&gt;&lt;/body&gt;&lt;/html&gt; iterator标签 主要用于对集合进行迭代。 案例实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib prefix=\"s\" uri=\"/struts-tags\" %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;iterator标签&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;table border=\"1\" width=\"300\"&gt; &lt;s:iterator value=\"&#123;'疯狂java讲义','轻量级Java EE企业应用实战','疯狂IOS讲义'&#125;\" var=\"name\"&gt; &lt;tr&gt; &lt;th&gt;&lt;s:property value=\"#st.count\"/&gt;&lt;s:property value=\"name\"/&gt;&lt;/th&gt; &lt;/tr&gt; &lt;/s:iterator&gt; &lt;/table&gt; &lt;!-- 迭代输出list集合 --&gt; &lt;table border=\"1\" width=\"300\"&gt; &lt;s:iterator value=\"&#123;'疯狂java讲义','轻量级Java EE企业应用实战','疯狂IOS讲义'&#125;\" var=\"name\" status=\"st\"&gt; &lt;tr &lt;s:if test=\"#st.odd\"&gt;style=\"background-color:#bbbbbb\" &lt;/s:if&gt;&gt; &lt;td&gt; &lt;s:property value=\"name\"/&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/s:iterator&gt; &lt;/table&gt; &lt;!-- 对Map集合进行迭代 --&gt; &lt;table border=\"1\" width=\"300\"&gt; &lt;tr&gt; &lt;th&gt;书名&lt;/th&gt; &lt;th&gt;作者&lt;/th&gt; &lt;/tr&gt; &lt;s:iterator value=\"#&#123;'疯狂java讲义':'李刚','轻量级Java EE企业应用实战':'李刚','疯狂IOS讲义':'李刚'&#125;\" var=\"name\" status=\"st\"&gt; &lt;!--根据当前迭代的元素的索引是否为奇数来决定是否使用背景颜色 --&gt; &lt;tr &lt;s:if test=\"#st.odd\"&gt;style=\"background-color:#bbbbbb\" &lt;/s:if&gt;&gt; &lt;td&gt; &lt;!-- 数据Map对象里Entry的key --&gt; &lt;s:property value=\"key\"/&gt; &lt;/td&gt; &lt;td&gt; &lt;!-- 数据Map对象里Entry的value --&gt; &lt;s:property value=\"value\"/&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/s:iterator&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt; append标签 append：用于将多个集合拼接成一个新的集合。 案例实现 1234567891011121314151617181920212223242526272829303132333435363738&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib prefix=\"s\" uri=\"/struts-tags\" %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;append标签&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 使用append标签将两个集合拼接成新的集合，新集合的名字是newList，新集合放入到Stack Context --&gt; &lt;s:append var=\"newList\"&gt; &lt;s:param value=\"&#123;'疯狂java讲义','轻量级Java EE企业应用实战','疯狂IOS讲义'&#125;\"&gt;&lt;/s:param&gt; &lt;s:param value=\"&#123;'http://www.baidu.com','cpws.github.io','qqqqyy.github.io'&#125;\"&gt;&lt;/s:param&gt; &lt;/s:append&gt; &lt;table border=\"1\" width=\"400\"&gt; &lt;s:iterator value=\"#newList\" var=\"name\" status=\"index\"&gt; &lt;tr &lt;s:if test=\"#index.even\"&gt;style=\"background-color:#4dffff\"&lt;/s:if&gt;&gt; &lt;td&gt;&lt;s:property value=\"name\"/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/s:iterator&gt; &lt;/table&gt; &lt;!-- 使用append标签将List集合和Map结合拼接成新的集合，新集合的名字是newList，新集合放入到Stack Context --&gt; &lt;s:append var=\"dd\"&gt; &lt;s:param value=\"#&#123;'疯狂java讲义':'李刚','轻量级Java EE企业应用实战':'李刚','疯狂IOS讲义':'李刚'&#125;\"&gt;&lt;/s:param&gt; &lt;s:param value=\"#&#123;'http://www.baidu.com','cpws.github.io','qqqqyy.github.io'&#125;\"&gt;&lt;/s:param&gt; &lt;/s:append&gt; &lt;!-- 使用迭代器进行迭代 --&gt; &lt;table border=\"1\" width=\"400\"&gt; &lt;s:iterator value=\"#dd\" var=\"name\" status=\"st\"&gt; &lt;tr &lt;s:if test=\"#st.even\"&gt;style=\"background-color:#4dffff\"&lt;/s:if&gt;&gt; &lt;td&gt;&lt;s:property value=\"key\"/&gt;&lt;/td&gt; &lt;td&gt;&lt;s:property value=\"value\"/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/s:iterator&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt; generator标签 generator：它是一个字符串解析器，用于讲一个字符串解析成一个集合. 案例实现： 1234567891011121314151617181920212223242526272829303132333435363738&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib prefix=\"s\" uri=\"/struts-tags\" %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;generator标签&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;table border=\"1\" width=\"300\"&gt; &lt;!-- 使用generator标签将指定字符串解析成iterator集合 --&gt; &lt;!-- 在generator标签内，得到的List集合位于valuestack顶端 --&gt; &lt;s:generator separator=\",\" val=\" '疯狂Java讲义,疯狂Java EE企业应用实战,疯狂IOS讲义' \"&gt; &lt;!-- 没有指定迭代哪个集合，直接迭代栈顶的集合 --&gt; &lt;s:iterator status=\"st\"&gt; &lt;tr &lt;s:if test=\"#st.odd\"&gt;style=\"background-color:#bbbbbb\" &lt;/s:if&gt;&gt; &lt;td&gt;&lt;s:property/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/s:iterator&gt; &lt;/s:generator&gt; &lt;/table&gt; &lt;table border=\"1\" width=\"300\"&gt; &lt;!-- 使用generator标签将指定字符串解析成iterator集合 指定了count和var --&gt; &lt;!-- 在generator标签内，得到的List集合位于valuestack顶端 --&gt; &lt;s:generator separator=\",\" val=\" '疯狂Java讲义,疯狂Java EE企业应用实战,疯狂IOS讲义' \" count=\"2\" var=\"books\"&gt; &lt;!-- 没有指定迭代哪个集合，直接迭代栈顶的集合 --&gt; &lt;!-- 并且把值存入到 stack context中的books集合 --&gt; &lt;s:iterator status=\"st\"&gt; &lt;tr &lt;s:if test=\"#st.odd\"&gt;style=\"background-color:#bbbbbb\" &lt;/s:if&gt;&gt; &lt;td&gt;&lt;s:property/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/s:iterator&gt; &lt;/s:generator&gt; &lt;/table&gt; $&#123;requestScope.books&#125;&lt;/body&gt;&lt;/html&gt; 注意：如果在标签定义了var属性，则该集合将会被存入到Stack Context中，在该标签外部可以访问该标签，否则，该集合会创建一个临时文件存放在Value Stack，可以直接被访问，但是只能在标签中被使用。 merge标签 merge：用于将多个集合合拼成一个新的集合。但与append的拼接方法有所不同。 案例实现: 123456789101112131415161718192021222324&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib prefix=\"s\" uri=\"/struts-tags\" %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;merge标签&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;s:merge var=\"newList\"&gt; &lt;s:param value=\"&#123;'疯狂Java讲义','轻量级Java EE企业应用实战','疯狂IOS讲义'&#125;\"&gt;&lt;/s:param&gt; &lt;s:param value=\"&#123;'hhtp://www.baidu.com','cpws.github.io'&#125;\"&gt;&lt;/s:param&gt; &lt;/s:merge&gt; &lt;table border=\"1\" width=\"400\"&gt; &lt;s:iterator value=\"newList\" status=\"st\"&gt; &lt;tr &lt;s:if test=\"#st.odd\"&gt;style=\"background-color:#bbbbbb\"&lt;/s:if&gt;&gt; &lt;td&gt;&lt;s:property/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/s:iterator&gt; &lt;/table&gt; &lt;/body&gt;&lt;/html&gt; merge标签的效果与append标签一样，只是拼接成新的集合后，两者新集合中的元素顺序不一样而已。 subset标签：这个标签用于截取集合的部分元素，形成新的子集合。 案例实现 12345678910111213141516171819package org.crazyit.app.util;import org.apache.struts2.util.SubsetIteratorFilter;/*** * 用户自定义Decider类，实现了SubsetIteratorFilter.Decider接口 * @author 1huangzewei * */public class MyDecider implements SubsetIteratorFilter.Decider&#123; //实现Decider接口必须实现decide()方法 //该方法决定集合中的元素是否被选入自己 @Override public boolean decide(Object element) throws Exception &#123; String str=(String) element; //如果集合元素中包含JavaEE子串，即可被选入子集 return str.indexOf(\"Java EE\") &gt; 0; &#125;&#125; 12345678910111213141516171819202122232425262728&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib prefix=\"s\" uri=\"/struts-tags\" %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;subset标签&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 定义一个Decider Bean --&gt; &lt;s:bean name=\"org.crazyit.app.util.MyDecider\" var=\"mydecider\"&gt;&lt;/s:bean&gt; &lt;!-- 使用自定义的decider实例来截取目标集合，生成子集 --&gt; &lt;!-- 指定var属性，将生成的集合放入到page范围中 --&gt; &lt;s:subset source=\"&#123;'疯狂Java讲义','轻量级Java EE企业应用实战','经典Java EE企业应用实战','疯狂前端开发讲义','疯狂IOS讲义'&#125;\" decider=\"#mydecider\" var=\"newList\"/&gt; &lt;!--直接输出 page范围的newList属性 --&gt; 直接输出 page范围的newList属性:&lt;br&gt;$&#123;pageScope.newList&#125; &lt;table border=\"1\" width=\"400\"&gt; &lt;!-- 使用迭代器来迭代目标集合，因为没有指定value属性值，所有迭代ValueStack栈顶的值 --&gt; &lt;s:iterator value=\"#attr.newList\" status=\"st\"&gt; &lt;tr &lt;s:if test=\"#st.odd\"&gt;style=\"background-color:#bbbbbb\"&lt;/s:if&gt;&gt; &lt;td&gt;&lt;s:property/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/s:iterator&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt; sort标签 用于对指定集合元素进行排序 案例实现 12345678910111213141516package org.crazyit.app.util;import java.util.Comparator;public class MyComparator implements Comparator&#123; /*** * 决定两个元素大小的方法 */ @Override public int compare(Object o1, Object o2) &#123; //根据元素字符串长度来决定大小 return o1.toString().length() - o2.toString().length(); &#125;&#125; 123456789101112131415161718192021222324252627&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib prefix=\"s\" uri=\"/struts-tags\" %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;sort标签&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 定义一个Comparator实例 --&gt; &lt;s:bean name=\"org.crazyit.app.util.MyComparator\" var=\"myComparator\"/&gt; &lt;!-- 使用自定义的排序规则进行排序 --&gt; &lt;s:sort comparator=\"#myComparator\" source=\"&#123;'疯狂Java讲义','轻量级Java EE企业应用实战','经典Java EE企业应用实战','疯狂前端开发讲义','疯狂IOS讲义'&#125;\" var=\"sortedList\"/&gt; 输出page范围的sortedList属性：&lt;br&gt;$&#123;pageScope.sortedList&#125; &lt;table border=\"1\" width=\"400\"&gt; &lt;!-- 使用迭代器来迭代目标集合，因为没有指定value属性值，所有迭代ValueStack栈顶的值 --&gt; &lt;s:iterator value=\"#attr.sortedList\" status=\"st\"&gt; &lt;tr &lt;s:if test=\"#st.odd\"&gt;style=\"background-color:#bbbbbb\"&lt;/s:if&gt;&gt; &lt;td&gt;&lt;s:property/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/s:iterator&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 数据标签 数据标签主要用于提供各种数据访问的功能，包含显示一个Action里的属性，以及生成国际化输出等功能。数据标签主要包含如下几个： action：该标签用于在JSP页面直接调用一个action，通过指定executeResult参数，还可将该action的处理结果包含到本页面中来。 bean：该标签用于创建一个JavaBean实例。如果指定了var属性，则可以将创建的实例放入到Stack Context中. date：用于格式化输出一个日期。 debug：用于在页面上生成一个调试链接，当点击该链接时，可以看到Stack Context和ValueStack中的内容。 i18n：用于指定国际化资源文件的baseName。 include：用于在JSP页面中包含其他的JSP或Servlet资源。 param：用于设置一个参数，通常是用作bean标签、URL标签的字标签。 push：用于将某个值放入到ValueStack的栈顶。 set：用于设置一个新变量，并可以将新变量放入到指定的范围内。 text：用于输出国际化信息。 url：用于生成一个URL地址。 property：用于输出某个值，包括输出valueStack,Stack Context和Action Context中的值。 action标签：该标签用于在JSP页面直接调用一个action 案例实现 123456789101112131415161718192021&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib prefix=\"s\" uri=\"/struts-tags\" %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;action标签&lt;/title&gt;&lt;/head&gt;&lt;body&gt; 下面调用第一个Action，并将结果包含到本页面&lt;br&gt; &lt;s:action name=\"tag1\" executeResult=\"true\"/&gt;&lt;hr&gt; 下面调用第二个Action，并将结果包含到本页面&lt;br&gt; 但阻止本页面请求参数传入Action。&lt;br&gt; &lt;s:action name=\"tag2\" executeResult=\"true\" ignoreContextParams=\"true\"/&gt;&lt;hr&gt; 下面调用第三个Action，并不将结果包含到本页面&lt;br&gt; &lt;s:action name=\"tag2\" executeResult=\"true\" ignoreContextParams=\"false\"/&gt; 本页面是否可访问：&lt;s:property value=\"author\"/&gt; &lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920212223242526package org.crazyit.app.action;import com.opensymphony.xwork2.ActionContext;import com.opensymphony.xwork2.ActionSupport;public class TagAction extends ActionSupport &#123; private static final long serialVersionUID = 1L; //封装用户请求参数的author成员变量 private String author; public String getAuthor() &#123; return author; &#125; public void setAuthor(String author) &#123; this.author = author; &#125; //定义第一个处理逻辑 public String execute() throws Exception&#123; return \"done\"; &#125; //定义第二个处理逻辑 public String login() throws Exception&#123; ActionContext.getContext().put(\"author\", getAuthor()); return \"done\"; &#125;&#125; 12345678910111213141516171819202122&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE struts PUBLIC \"-//Apache Software Foundation//DTD Struts Configuration 2.5//EN\" \"http://struts.apache.org/dtds/struts-2.5.dtd\"&gt;&lt;struts&gt; &lt;constant name=\"struts.devMode\" value=\"true\"&gt;&lt;/constant&gt; &lt;constant name=\"struts.enable.DynamicMethodInvocation\" value=\"true\"/&gt; &lt;package name=\"default\" namespace=\"/\" extends=\"struts-default\" &gt; &lt;!-- 定义第一个Action，使用TagAction的execute方法作为控制处理逻辑 --&gt; &lt;action name=\"tag1\" class=\"org.crazyit.app.action.TagAction\"&gt; &lt;result name=\"done\"&gt;/WEB-INF/content/succ.jsp&lt;/result&gt; &lt;/action&gt; &lt;!-- 定义第二个Action，使用TagAction的login方法作为控制处理逻辑 --&gt; &lt;action name=\"tag2\" class=\"org.crazyit.app.action.TagAction\" method=\"login\"&gt; &lt;result name=\"done\"&gt;/WEB-INF/content/loginSucc.jsp&lt;/result&gt; &lt;/action&gt; &lt;action name=\"*\"&gt; &lt;result&gt;/WEB-INF/content/&#123;1&#125;.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; bean：该标签用于创建一个JavaBean实例 案例实现 1234567891011121314151617181920212223242526272829303132333435&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib prefix=\"s\" uri=\"/struts-tags\" %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;bean标签&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 使用bean标签创建一个Person实例 --&gt; &lt;s:bean name=\"org.crazyit.app.dto.Person\" &gt; &lt;!-- 使用param标签为Person类的实例传入参数 --&gt; &lt;s:param name=\"name\" value=\"'yeeku'\"/&gt; &lt;s:param name=\"age\" value=\"23\"/&gt; &lt;s:param name=\"aaa\" value=\"10\"/&gt; &lt;!-- 因为在bean标签体内，Person实例位于ValueStack栈顶，故可以直接访问Person实例 --&gt; &lt;!-- Person实例的name为：&lt;s:property value=\"name\"/&gt;&lt;br/&gt; Person实例的age为：&lt;s:property value=\"age\"/&gt;&lt;br/&gt; Person实例的aaa为：&lt;s:property value=\"aaa\"/&gt;&lt;br/&gt; --&gt; &lt;/s:bean&gt; &lt;s:bean name=\"org.crazyit.app.dto.Person\" var=\"p\"&gt; &lt;s:param name=\"name\" value=\"'yeeku'\"/&gt; &lt;s:param name=\"age\" value=\"23\"/&gt; &lt;s:param name=\"aaa\" value=\"10\"/&gt; &lt;/s:bean&gt; &lt;!-- 根据JavaBean实例的var属性来获取JavaBean实例 --&gt; Person实例的name为：&lt;s:property value=\"#p.name\"/&gt;&lt;br/&gt; Person实例的age为：&lt;s:property value=\"#p.age\"/&gt;&lt;br/&gt; Person实例的aaa为：&lt;s:property value=\"#p.aaa\"/&gt;&lt;br/&gt; $&#123;requestScope.p&#125;&lt;/body&gt;&lt;/html&gt; 123456789101112131415package org.crazyit.app.dto;public class Person &#123; private String name; private int age; private int aaa; public Person() &#123;&#125; public Person(String name, int age, int aaa) &#123; super(); this.name = name; this.age = age; this.aaa = aaa; &#125; //省略getter和setter方法&#125; date：用于格式化输出一个日期 案例实现： 123456789101112131415161718192021222324&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib prefix=\"s\" uri=\"/struts-tags\" %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;s:bean var=\"now\" name=\"java.util.Date\"/&gt; nice=false，且指定format=\"dd/MM/YYYY\"&lt;br/&gt; &lt;s:date name=\"#now\" format=\"dd/MM/YYYY\" nice=\"false\"/&gt;&lt;hr/&gt; nice=true，且指定format=\"dd/MM/YYYY\"&lt;br/&gt; &lt;s:date name=\"#now\" format=\"dd/MM/YYYY\" nice=\"true\"/&gt;&lt;hr/&gt; 指定nice=\"true\"&lt;br/&gt; &lt;s:date name=\"#now\" nice=\"true\"/&gt;&lt;hr/&gt; 指定nice=\"false\"，且没有指定formate属性&lt;br/&gt; &lt;s:date name=\"#now\" nice=\"false\"/&gt;&lt;hr/&gt; 指定nice=\"false\"，且没有指定formate属性，但指定var属性&lt;br/&gt; &lt;s:date name=\"#now\" nice=\"false\" var=\"abc\"/&gt;&lt;hr/&gt; $&#123;requestScope.abc&#125; &lt;s:property value=\"#abc\"/&gt;&lt;/body&gt;&lt;/html&gt; debug：用于在页面上生成一个调试链接. 案例实现： 1&lt;s:debug/&gt; include：用于在JSP页面中包含其他的JSP或Servlet资源。 案例实现： 1234567891011121314151617181920&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib prefix=\"s\" uri=\"/struts-tags\" %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;include标签&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;使用s:include标签来包含目标页面&lt;/h2&gt;&lt;!-- 使用include标签来包含其他页面 --&gt;&lt;s:include value=\"include-file.jsp\"/&gt;&lt;!-- 使用include标签来包含其他页面，并且传入参数 --&gt;&lt;s:include value=\"include-file.jsp\"&gt; &lt;s:param name=\"author\" value=\"'yeeku'\"/&gt;&lt;/s:include&gt; &lt;/body&gt;&lt;/html&gt; 12345678910111213&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h3&gt;被包含的页面&lt;/h3&gt; author的参数值：$&#123;param.author&#125;&lt;/body&gt;&lt;/html&gt; param标签：主要用于为其他标签提供参数。 push标签：push标签用于将某个值放到ValueStack的栈顶。 案例实现: 12345678910111213141516171819202122232425&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib prefix=\"s\" uri=\"/struts-tags\" %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;使用s:push标签将某个值放入到Value Stack&lt;/h2&gt; &lt;!-- 使用bean标签来创建一个JavaBean实例，指定var属性，并且将其值放到var属性中 --&gt; &lt;s:bean name=\"org.crazyit.app.dto.Person\" var=\"p\"&gt; &lt;s:param name=\"name\" value=\"'ok'\"&gt;&lt;/s:param&gt; &lt;s:param name=\"age\" value=\"18\"&gt;&lt;/s:param&gt; &lt;s:param name=\"aaa\" value=\"12\"&gt;&lt;/s:param&gt; &lt;/s:bean&gt; &lt;!-- 将Stack Context中的p对象放入到ValueStack --&gt; &lt;s:push value=\"#p\"&gt; ValueStack栈顶对象的name属性：&lt;s:property value=\"name\"/&gt;&lt;br/&gt; ValueStack栈顶对象的age属性：&lt;s:property value=\"age\"/&gt;&lt;br/&gt; ValueStack栈顶对象的aaa属性：&lt;s:property value=\"aaa\"/&gt;&lt;br/&gt; &lt;/s:push&gt;&lt;/body&gt;&lt;/html&gt; set标签：用于将某个值放入到指定的范围中。 案例实现 12345678910111213141516171819202122232425262728293031323334353637&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib prefix=\"s\" uri=\"/struts-tags\" %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;set标签&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;使用s:set设置一个新变量&lt;/h2&gt; &lt;!-- 使用s:bean标签定义一个JavaBean实例 --&gt; &lt;s:bean name=\"org.crazyit.app.dto.Person\" var=\"p\"&gt; &lt;s:param name=\"name\" value=\"'ok'\"&gt;&lt;/s:param&gt; &lt;s:param name=\"age\" value=\"18\"&gt;&lt;/s:param&gt; &lt;s:param name=\"aaa\" value=\"12\"&gt;&lt;/s:param&gt; &lt;/s:bean&gt; 将Stack Context中的p值放入到默认范围（action）内。&lt;br/&gt; &lt;s:set value=\"#p\" var=\"xxx\" /&gt; Stack Context内xxx对象的name属性：&lt;s:property value=\"#xxx.name\"/&gt;&lt;br/&gt; Stack Context内xxx对象的age属性：&lt;s:property value=\"#xxx.age\"/&gt;&lt;br/&gt; Stack Context内xxx对象的aaa属性：&lt;s:property value=\"#xxx.aaa\"/&gt;&lt;br/&gt; request范围的xxx对象的name属性：$&#123;requestScope.xxx.name&#125;&lt;br/&gt; request范围的xxx对象的age属性：$&#123;requestScope.xxx.age&#125;&lt;br/&gt; request范围的xxx对象的aaa属性：$&#123;requestScope.xxx.aaa&#125;&lt;hr/&gt; 将Stack Context中的p值放入application范围内。&lt;br/&gt; &lt;s:set value=\"#p\" var=\"yyy\" scope=\"application\"/&gt; application范围的yyy对象的name属性：$&#123;applicationScope.yyy.name&#125;&lt;br/&gt; application范围的yyy对象的age属性：$&#123;applicationScope.yyy.age&#125;&lt;br/&gt; application范围的yyy对象的aaa属性：$&#123;applicationScope.yyy.aaa&#125;&lt;hr/&gt; 将Stack Context中的p值放入session范围内。&lt;br/&gt; &lt;s:set value=\"#p\" var=\"zzz\" scope=\"session\"/&gt; session范围的zzz对象的name属性：$&#123;sessionScope.zzz.name&#125;&lt;br/&gt; session范围的zzz对象的age属性：$&#123;sessionScope.zzz.age&#125;&lt;br/&gt; session范围的zzz对象的aaa属性：$&#123;sessionScope.zzz.aaa&#125;&lt;hr/&gt;&lt;/body&gt;&lt;/html&gt; url标签：用于生成一个url地址。\\ 案例实现： 12345678910111213141516171819&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib prefix=\"s\" uri=\"/struts-tags\" %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;url标签&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;s：url来生成一个URL地址&lt;/h2&gt; 只指定value属性的形式&lt;br/&gt; &lt;s:url value=\"editGadget.action\"/&gt;&lt;hr/&gt; 指定action属性，且使用param传入参数的形式&lt;br/&gt; &lt;s:url action=\"showBooks\"&gt; &lt;s:param name=\"author\" value=\"'yeeku'\"/&gt; &lt;/s:url&gt;&lt;hr/&gt;&lt;/body&gt;&lt;/html&gt; property标签：输出指定值。 主题和模板自定义主题表单标签 所有表单标签处理类都继承了UIBean类，UIBean包含了一些通用属性，这些通用属性分成三种： 模板相关属性。 JavaScript相关属性。 通用属性。 表单标签的name和value属性。 checkboxlist标签:可以一次创建多个复选框。 案例实现： 1234567891011121314151617181920212223242526272829&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib prefix=\"s\" uri=\"/struts-tags\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;checkboxlist标签&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;s:form&gt; &lt;!-- 使用简单的集合来生成多个复选框 --&gt; &lt;s:checkboxlist name=\"a\" label=\"请选择您喜欢的图书\" labelposition=\"top\" list=\"&#123;'疯狂java讲义','轻量级Java EE企业应用实战','疯狂IOS讲义'&#125;\"&gt;&lt;/s:checkboxlist&gt; &lt;!-- 使用简单Map来生成多个复选框 使用Map的key值作为复选框的value 使用Map的value值作为复选框的标签 --&gt; &lt;s:checkboxlist name=\"b\" label=\"请选择您想出版的日期：\" labelposition=\"top\" list=\"#&#123;'疯狂java讲义':'2008年9月','轻量级Java EE企业应用实战':'2008年12月','疯狂IOS讲义':'2014年1月'&#125;\" listKey=\"key\" listValueKey=\"value\"&gt;&lt;/s:checkboxlist&gt; &lt;!-- 创建一个JavaBean对象，并将其放入Stack Context中--&gt; &lt;s:bean name=\"org.crazyit.app.service.BookService\" var=\"bs\"&gt;&lt;/s:bean&gt; &lt;!-- 使用集合里放多个JavaBean实例来生成多个复选框 集合name作为标签，集合author作为复选框value --&gt; &lt;s:checkboxlist name=\"c\" label=\"请选择您喜欢的图书：\" labelposition=\"top\" list=\"#bs.books\" listKey=\"author\" listValue=\"name\"&gt;&lt;/s:checkboxlist&gt; &lt;/s:form&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314package org.crazyit.app.service;import org.crazyit.app.dto.Book;public class BookService &#123; public Book[] getBooks() &#123; return new Book[] &#123; new Book(\"疯狂Java讲义\",\"李刚\"), new Book(\"疯狂Java EE企业应用实战\",\"李刚\"), new Book(\"疯狂ios讲义\",\"李刚\"), new Book(\"疯狂前端开发讲义\",\"李刚\") &#125;; &#125;&#125; 123456789101112131415161718192021222324252627package org.crazyit.app.dto;public class Book &#123; private String name; private String author; public Book() &#123; // TODO Auto-generated constructor stub &#125; public Book(String name, String author) &#123; super(); this.name = name; this.author = author; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getAuthor() &#123; return author; &#125; public void setAuthor(String author) &#123; this.author = author; &#125; &#125; radio标签：与checkboxlist的用法和属性完全一样，只是该标签生成的是单选按钮。 案例实现 1234567891011121314151617181920212223242526272829&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib prefix=\"s\" uri=\"/struts-tags\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;radio标签&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;s:form&gt; &lt;!-- 使用简单的集合来生成单选按钮--&gt; &lt;s:radio name=\"a\" label=\"请选择您喜欢的图书\" labelposition=\"top\" list=\"&#123;'疯狂java讲义','轻量级Java EE企业应用实战','疯狂IOS讲义'&#125;\"&gt;&lt;/s:radio&gt; &lt;!-- 使用简单Map来生成多个单选按钮 使用Map的key值作为单选按钮的value 使用Map的value值作为单选按钮的标签 --&gt; &lt;s:radio name=\"b\" label=\"请选择您想出版的日期：\" labelposition=\"top\" list=\"#&#123;'疯狂java讲义':'2008年9月','轻量级Java EE企业应用实战':'2008年12月','疯狂IOS讲义':'2014年1月'&#125;\" listKey=\"key\" listValueKey=\"value\"&gt;&lt;/s:radio&gt; &lt;!-- 创建一个JavaBean对象，并将其放入Stack Context中--&gt; &lt;s:bean name=\"org.crazyit.app.service.BookService\" var=\"bs\"&gt;&lt;/s:bean&gt; &lt;!-- 使用集合里放多个JavaBean实例来生成多个单选按钮 集合name作为标签，集合author作为单选按钮value --&gt; &lt;s:radio name=\"c\" label=\"请选择您喜欢的图书：\" labelposition=\"top\" list=\"#bs.books\" listKey=\"author\" listValue=\"name\"&gt;&lt;/s:radio&gt; &lt;/s:form&gt;&lt;/body&gt;&lt;/html&gt; select标签：用于生成一个下拉列表框。 案例实现 123456789101112131415161718192021222324252627&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib prefix=\"s\" uri=\"/struts-tags\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;select标签&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;s:form&gt; &lt;!-- 使用简单的集合来生成下拉选择框 --&gt; &lt;s:select name=\"a\" label=\"请选择您喜欢的图书\" labelposition=\"top\" multiple=\"true\" list=\"&#123;'疯狂java讲义','轻量级Java EE企业应用实战','JavaScript:The Definitive Guide'&#125;\"&gt;&lt;/s:select&gt; &lt;!-- 使用简单Map来生成下拉选择框 --&gt; &lt;s:select name=\"b\" label=\"请选择您想出版的日期：\" labelposition=\"top\" list=\"#&#123;'疯狂java讲义':'2008年9月','轻量级Java EE企业应用实战':'2008年12月','疯狂IOS讲义':'2014年1月'&#125;\" listKey=\"key\" listValueKey=\"value\"&gt;&lt;/s:select&gt; &lt;!-- 创建一个JavaBean对象，并将其放入Stack Context中--&gt; &lt;s:bean name=\"org.crazyit.app.service.BookService\" var=\"bs\"&gt;&lt;/s:bean&gt; &lt;!-- 使用集合里放多个JavaBean实例来生成下拉选择框 --&gt; &lt;s:select name=\"c\" label=\"请选择您喜欢的图书：\" labelposition=\"top\" multiple=\"true\" list=\"#bs.books\" listKey=\"author\" listValue=\"name\"&gt;&lt;/s:select&gt; &lt;/s:form&gt;&lt;/body&gt;&lt;/html&gt; optgroup标签：用于生成一个下拉列表框的选项组，因此该标签需要在&lt;s:select&gt;中使用。 案例实现 12345678910111213141516171819202122&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib prefix=\"s\" uri=\"/struts-tags\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;optgroup标签&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;s:form&gt; &lt;!-- 使用简单Map为列表框生成选项 --&gt; &lt;s:select name=\"b\" label=\"请选择你喜欢的书：\" size=\"7\" labelposition=\"top\" list=\"#&#123;'疯狂java讲义':'李刚','轻量级Java EE企业应用实战':'李刚','疯狂IOS讲义':'李刚'&#125;\" listKey=\"key\" listValueKey=\"value\"&gt; &lt;!-- 使用Map对象生成选项组 --&gt; &lt;s:optgroup label=\"Rod Johnson\" list=\"#&#123;'Expert One-on-one J2EE Design and Development':'Johnson'&#125;\"&gt;&lt;/s:optgroup&gt; &lt;s:optgroup label=\"David Flanagan\" list=\"#&#123;'JavaScript :The Definitive Guide':'David'&#125;\"&gt;&lt;/s:optgroup&gt; &lt;/s:select&gt; &lt;/s:form&gt;&lt;/body&gt;&lt;/html&gt; head标签：该标签主要用于生成HTML的&lt;head ../&gt;部分。 updownselect标签：该标签的用法非常相思雨select标签的使用，区别在于该标签生成的列表框可以上下移动。 案例实现 12345678910111213141516171819202122232425&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib prefix=\"s\" uri=\"/struts-tags\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;updownselect标签&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;s:form&gt; &lt;!-- 使用简单集合来生成上下移动选项的下拉列表框 --&gt; &lt;s:updownselect name=\"a\" label=\"请选择您喜欢的书：\" labelposition=\"top\" list=\"&#123;'疯狂java讲义','轻量级Java EE企业应用实战','疯狂IOS讲义'&#125;\" moveUpLabel=\"向上移动\"&gt;&lt;/s:updownselect&gt; &lt;!-- 使用简单Map为列表框生成选项 emptyOption=\"true\"增加空白选项--&gt; &lt;s:updownselect name=\"b\" label=\"请选择您想出版的日期：\" labelposition=\"top\" moveDownLabel=\"向下移动\" list=\"#&#123;'疯狂java讲义':'2008年9月','轻量级Java EE企业应用实战':'2008年12月','疯狂IOS讲义':'2014年1月'&#125;\" listKey=\"key\" listValueKey=\"value\" emptyOption=\"true\"&gt;&lt;/s:updownselect&gt; &lt;s:bean name=\"org.crazyit.app.service.BookService\" var=\"bs\"&gt;&lt;/s:bean&gt; &lt;s:updownselect name=\"c\" label=\"请选择您喜欢的图书：\" labelposition=\"top\" selectAllLabel=\"全选\" multiple=\"true\" list=\"#bs.books\" listKey=\"author\" listValue=\"name\"&gt;&lt;/s:updownselect&gt; &lt;/s:form&gt;&lt;/body&gt;&lt;/html&gt; doubleselect标签：会生成一个级联列表框。 案例实现1: 1234567891011121314151617&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib prefix=\"s\" uri=\"/struts-tags\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;doubleselect标签&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;s:form action=\"x\"&gt; &lt;s:doubleselect label=\"请选择您喜欢的书\" labelposition=\"top\" name=\"author\" list=\"&#123;'李刚','David'&#125;\" doubleList=\"top=='李刚'?&#123;'轻量级Java EE企业级应用实战','疯狂IOS讲义','疯狂Java讲义'&#125;:&#123;'JavaScript:the definitive guide'&#125;\" doubleName=\"book\"/&gt; &lt;/s:form&gt;&lt;/body&gt;&lt;/html&gt; 案例实现2: 1234567&lt;h3&gt;使用s:doubleselect生成级联列表框&lt;/h3&gt;&lt;s:set var=\"bs\" value=\"#&#123;'李刚':&#123;'疯狂java讲义','轻量级Java EE企业应用实战','疯狂IOS讲义'&#125;,'Johnson':&#123;'Expert One-on-one J2EE Design and Development'&#125;,'David':&#123;'JavaScript :The Definitive Guide'&#125;&#125;\"/&gt;&lt;s:form action=\"x\"&gt; &lt;s:doubleselect label=\"请选择您喜欢的书\" name=\"author\" list=\"#bs.keySet()\" size=\"3\" doubleList=\"#bs[top]\" doubleSize=\"3\" doubleName=\"book\"/&gt;&lt;/s:form&gt; optiontransferselect标签：会生成两个列表选择框，并生成系列按钮控制各选框之间的移动、升降等。 12345678910111213141516171819202122232425262728293031323334353637&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib prefix=\"s\" uri=\"/struts-tags\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;s:form&gt; &lt;!-- 使用简单的集合对象生成可移动的下拉框 --&gt; &lt;s:optiontransferselect label=\"请选择你喜欢的书\" name=\"cnbook\" leftTitle=\"中文图书\" rightTitle=\"外文图书\" list=\"&#123;'疯狂java讲义','轻量级Java EE企业应用实战','疯狂IOS讲义'&#125;\" multiple=\"true\" addToLeftLabel=\"向左移动\" addToRightLabel=\"向右移动\" selectAllLabel=\"全部选择\" addAllToRightLabel=\"全部右移\" addAllToLeftLabel=\"全部左移\" headerKey=\"cnKey\" headerValue=\"--- 选择中文图书 ---\" emptyOption=\"true\" doubleList=\"&#123;'Expert One-on-one J2EE Design and Development','JavaScript :The Definitive Guide'&#125;\" doubleName=\"enBook\" doubleHeaderKey=\"enKey\" doubleHeaderValue=\"--- 选择外文图书 ---\" doubleEmptyOption=\"true\" doubleMultiple=\"true\" /&gt; &lt;/s:form&gt;&lt;/body&gt;&lt;/html&gt; token标签：防止重复提交表单的标签。 案例实现： 1234567891011121314151617181920&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib prefix=\"s\" uri=\"/struts-tags\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;token标签&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h3&gt;使用s:token防止重复提交&lt;/h3&gt; &lt;s:form action=\"pro\"&gt; &lt;!-- 普通表单域 --&gt; &lt;s:textfield name=\"book\" label=\"书名\" /&gt; &lt;!-- 用于防刷新的token标签 --&gt; &lt;s:token/&gt; &lt;s:submit value=\"提交\"&gt;&lt;/s:submit&gt; &lt;/s:form&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920212223package org.crazyit.app.action;import com.opensymphony.xwork2.ActionSupport;public class ProAction extends ActionSupport&#123; private static final long serialVersionUID = 1L; private String book; public String getBook() &#123; return book; &#125; public void setBook(String book) &#123; this.book = book; &#125; //处理用户的业务逻辑 public String execute() &#123; System.out.println(getBook()); return NONE; &#125; &#125; 12345678910111213141516171819202122&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE struts PUBLIC \"-//Apache Software Foundation//DTD Struts Configuration 2.5//EN\" \"http://struts.apache.org/dtds/struts-2.5.dtd\"&gt;&lt;struts&gt; &lt;constant name=\"struts.devMode\" value=\"true\"&gt;&lt;/constant&gt; &lt;constant name=\"struts.enable.DynamicMethodInvocation\" value=\"true\"/&gt; &lt;package name=\"default\" namespace=\"/\" extends=\"struts-default\" &gt; &lt;action name=\"pro\" class=\"org.crazyit.app.action.ProAction\"&gt; &lt;!-- 使用系统默认的拦截器 --&gt; &lt;interceptor-ref name=\"basicStack\"&gt;&lt;/interceptor-ref&gt; &lt;!-- 使用防止刷新的拦截器 --&gt; &lt;interceptor-ref name=\"token\"/&gt; &lt;!-- 定义重复提交的转向视图，该逻辑视图名必须是：invalid.token --&gt; &lt;result name=\"invalid.token\"&gt;/WEB-INF/content/refresh.jsp&lt;/result&gt; &lt;/action&gt; &lt;action name=\"*\"&gt; &lt;result&gt;/WEB-INF/content/&#123;1&#125;.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; 使用token标签需要注意两点: 在页面中添加&lt;s:token/&gt;标签。 在配置文件中添加拦截器并且配置invalid.token结果集 非表单标签 非表单标签主要用于显示action里封装的信息。非表单标签主要有如下几个: actionerror：如果Action实例的getActionErrors()方法不返回null，则该标签负责输出该方法返回的系列错误。 actionmessage：如果Action实例的getActionMessages()方法不返回null，则该标签负责输出该方法返回的系列错误。 component：使用此标签可以生成一个自定义组件。 fielderror：如果Action实例存在表单域的类型转换错误、校验错误，则该标签负责输出错误信息。 actionerror和actionmessage标签 component标签：用于创建自定义组件 案例实现： 123456789101112131415161718192021222324&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib prefix=\"s\" uri=\"/struts-tags\" %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;使用s:component标签&lt;/h2&gt; 使用默认主题(xHTML)，默认主题目录(template)&lt;br&gt; 使用mytemplate作为视图组件 &lt;s:component template=\"mytemplate.jsp\"&gt; &lt;s:param name=\"list\" value=\"&#123;'疯狂Java讲义','疯狂IOS讲义','轻量级 Java EE企业应用实战'&#125;\"&gt;&lt;/s:param&gt; &lt;/s:component&gt;&lt;hr&gt; 使用自定义主题，自定义主题目录&lt;br&gt; 使用myAnotherTemplate.jsp作为视图组件 &lt;s:component template=\"myAnotherTemplate.jsp\" templateDir=\"myTemplateDir\" theme=\"myTheme\"&gt; &lt;s:param name=\"list\" value=\"&#123;'疯狂Java讲义','疯狂IOS讲义','轻量级 Java EE企业应用实战'&#125;\"&gt;&lt;/s:param&gt; &lt;/s:component&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"back-end","slug":"back-end","permalink":"https://CPWS.github.io/categories/back-end/"}],"tags":[{"name":"Struts2.5","slug":"Struts2-5","permalink":"https://CPWS.github.io/tags/Struts2-5/"}]},{"title":"Struts2","slug":"Struts2","date":"2019-09-10T03:05:26.000Z","updated":"2019-12-05T09:02:32.268Z","comments":true,"path":"2019/09/10/Struts2/","link":"","permalink":"https://CPWS.github.io/2019/09/10/Struts2/","excerpt":"","text":"Struts2框架学习第一讲：回顾 Web开发的进程有两种模式，model1开发模式和model2开发模式。 Model1模式 优点：执行效率高，开发效率高，适合中小型项目。 缺点：逻辑比较混乱，页面混乱，维护困难，扩展不容易。 Model2 优点：解耦，将试图层和业务层分离。结构清晰，分工明确，维护方便，适合中大型项目。 缺点：执行效率相对Model1低,代码量大，重复代码比较多。 Model2又称为MVC设计模式。 M:model模型 V:view试图 C：controller控制 使用Servlet的MVC存在一些问题，有重复的代码—通过MVC框架来解决。 Servlet解决了什么问题 将url映射到一个java类的处理方法上。 接收请求的数据。 如何将处理结果显示到页面。 如何进行页面的跳转。第二讲：框架 Java学习路线 基础语法—-&gt;方法（目的：减少代码，代码重复利用）—-&gt;类（目的：代码复用，OOP：面向对象）—-&gt; jar包（多个类封装为jar包。目的：代码复用）—-&gt; 框架（一个或多个jar包。目的：代码重用） 从中体现最多的思想是：封装 什么是框架？ framework 框架是模板，模型，模子。 专业语言描述：框架是一个可重用的半成品。 为什么要学框架？ 提高开发效率，降低学习难度。 如何学习框架？ 框架是别人提供的，那么使用框架时，要遵守框架提供的规。 学习框架就是学习框架的规则。 框架有两个部分组成：可变的部分和不可变的部分。 常见的框架有哪些 struts2,strut1,spring,hibernate,Mybatis,Shiro,nutz等待。第三讲：Struts入门 什么是struts？ Apache Struts is a free, open-source, MVC framework for creating elegant, modern Java web applications. It favors convention over configuration, is extensible using a plugin architecture, and ships with plugins to support REST, AJAX and JSON. Struts2是一个开源、免费、轻量级的mvc框架 轻量级：如果一个框架没有侵入性，就说该框架是轻量级的。 侵入性：如果使用一个框架必须实现框架提供的接口，或者继承框架提供的类。 在Struts2之前是Struts1。Struts1出现很早，市场占有率比较高，所以不支持一些新的试图层展示技术，逐渐被淘汰。Struts2=Struts1+webwork Struts2是基于请求的mvc框架。 Struts2的目录结构 apps：应用案例。 docs：文档。 lib：使用的库包。 src：源码。 Struts2的Hello World案例 新建web项目 导入jar包 编写web.xml文件–配置struts2的前端控制器（分发器） 123456789&lt;!-- 配置struts2的前端控制器 --&gt;&lt;filter&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;url-pattern&gt;*.action&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 编写业务处理类 123456789101112131415161718package demo;/**** struts2的第一个案例* @author 朱楚利**/public class HelloWorld &#123; /*** * 在Struts2中，所有的业务方法都是public * 返回值都为String类，所有的业务方法都没有参数 * 方法名可以自定义，默认是execute() * @return */ public String execute() &#123; System.out.println(\"Hello struts2\"); return \"success\"; &#125;&#125; 在src下，添加strut2的配置文件，名称为为struts.xml，该配置文件名不能更改，并进行配置。 123456789101112131415&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE struts PUBLIC \"-//Apache Software Foundation//DTD Struts Configuration 2.3//EN\" \"http://struts.apache.org/dtds/struts-2.3.dtd\"&gt;&lt;struts&gt; &lt;package name=\"default\" namespace=\"/\" extends=\"struts-default\"&gt; &lt;!-- 配置action 配置url和处理类的方法进行映射 --&gt; &lt;action name=\"hello\" class=\"demo.HelloWorld\"&gt; &lt;result&gt;/hello.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; 编写hello.jsp页面 123456789101112&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt; &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Insert title here&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;hello world struts2&lt;/h1&gt; &lt;/body&gt; &lt;/html&gt; 发布项目并进行测试。 第四讲 配置讲解 web.xml 123456789101112131415 &lt;!-- 配置struts2的前端控制器 struts2框架开始工作的入口 接管请求 --&gt;&lt;filter&gt; &lt;!-- 名称自定义 --&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;!-- Struts2提供的控制器类 --&gt; &lt;filter-class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;url-pattern&gt;*.action&lt;/url-pattern&gt;&lt;/filter-mapping&gt; struts2.xml 该配置文件的文件名固定，并且只能放在src目录下。 1234567891011121314151617181920212223242526272829303132333435363738 &lt;struts&gt;&lt;!-- package 分模块管理 name属性属性值自定义但是不能重复，在一个项目中是唯一的 namespace属性命名空间与url请求路径直接相关 如：“/” 请求为 /hello.action; 如：\"/user\"，则请求路径为/user/hello.action extends 继承 必须直接或间接继承struts-default result的请求路径是相对namespace的属性值 --&gt;&lt;package name=\"default\" namespace=\"/\" extends=\"struts-default\"&gt; &lt;!-- 配置action 配置url和处理类的方法进行映射 name为请求名称 不加后缀 class 处理类的完全限定名称 包名+类名，如果不配置，由默认类来处理 com.opensymphony.xwork2.ActionSupport method指定处理请求的方法，默认是execute()方法 --&gt; &lt;action name=\"hello\" class=\"demo.HelloWorld\" method=\"hello\"&gt; &lt;!-- result结果集配置 name 结果集名称，和处理方法的返回之匹配 默认为success，可以自定义。 Struts2提供了5个返回结果： Action.SUCCESS： 执行成功，跳转到下一个试图 Action.NONE：执行成功，不需要试图展示 Action.ERRPR:执行失败，显示失败页面 Action.INPUT：要执行该Action需要更多的输入条件 Action.LOGIN：需要登陆后才能执行 type指定响应结果类型 dispatcher 请求转发，默认使用 redirect 请求重定向 redirectAction 重定向到另一个action result的值为跳转页面 不加\"/\"为相对namespace路径，建议使用绝对路径 --&gt; &lt;result name=\"\" type=\"\"&gt;/hello.jsp&lt;/result&gt; &lt;/action&gt;&lt;/package&gt; 第五讲 Struts2的执行流程 浏览器发起请求 –&gt; 服务器接收请求并交给Struts2的前端控制器 —–&gt; 根据请求的url查看struts.xml中的namespace+actionName是否存在 –&gt; 执行action所对应的类的对应方法 —&gt; 根据方法的执行结果到action的结果集进行匹配 –&gt; 响应结果。 Struts2 第六讲 Struts2的数据处理一 在struts2中，对表单数据的处理有三种：属性驱动，对象驱动，模型驱动 使用Strut2获取表达数据：只需要表单域数据名称和Action处理类的属性名称一致，并且提供属性的set方法，那么在Action处理类中即可获取表单数据。这种获取数据的方式称为属性驱动。 处理类： 1234567891011121314151617181920212223242526272829package demo;import com.opensymphony.xwork2.Action;/*** * Struts2数据处理案列 * @author 1huangzewei * */public class LoginAction &#123; private String username; private String password; //登陆处理业务 public String login() &#123; System.out.println(\"username=\"+username+\";password=\"+password); return Action.SUCCESS; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public void setPassword(String password) &#123; this.password = password; &#125; &#125; 12345678910111213141516&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Struts2的数据处理&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=\"login.action\" method=\"post\"&gt; username:&lt;input type=\"text\" name=\"username\"/&gt;&lt;br&gt; password:&lt;input type=\"password\" name=\"password\"/&gt;&lt;br&gt; &lt;input type=\"button\" value=\"登录\"/&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 123456789&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE struts PUBLIC \"-//Apache Software Foundation//DTD Struts Configuration 2.3//EN\" \"http://struts.apache.org/dtds/struts-2.3.dtd\"&gt;&lt;struts&gt; &lt;package name=\"login\" namespace=\"/\" extends=\"struts-default\"&gt; &lt;action name=\"login\" class=\"demo.LoginAction\" method=\"login\"&gt; &lt;result&gt;/success.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; 如果数据需要显示在页面上，那么该数据可以作为处理类的数据，处理方法后该属性有值，并且有该属性的get方法，那么在页面上可以直接通过el表达式获取。 1234567891011121314151617181920212223242526272829303132333435package demo;import com.opensymphony.xwork2.Action;/*** * Struts2数据处理案列 * @author 1huangzewei * */public class LoginAction &#123; private String username; private String password; //登陆处理业务 public String login() &#123; System.out.println(\"username=\"+username+\";password=\"+password); return Action.SUCCESS; &#125; public String getUsername() &#123; return username; &#125; public String getPassword() &#123; return password; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public void setPassword(String password) &#123; this.password = password; &#125; &#125; 12345678910111213&lt;%@ page language=\"java\" contentType=\"text/html; charset=utf-8\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"utf-8\"&gt;&lt;title&gt;成功页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;My First Struts Demo&lt;/h1&gt; &lt;h3&gt;恭喜$&#123;username&#125;登录成功&lt;h3&gt; &lt;h2&gt;$&#123;password&#125;&lt;h2&gt;&lt;/body&gt;&lt;/html&gt; 第七讲 数据处理二 IOC：控制反转 对象驱动方式获取属性：（重点） 在action的处理类中，属性以对象的形式存在，该属性对象只需声明并为其提供get方法和set方法即可，需要保证该属性对象有无参构造方法。 在表单域中的表单域名称以属性对象.属性对象的属性来命名。 这种方式比较重要 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//User类package entity;public class User &#123; //如果要提供构造函数，要提供一个无参构造方法 private String username; private String password; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; &#125;//处理类package demo;import com.opensymphony.xwork2.Action;import entity.User;/*** * Struts2数据处理案列 * @author 1huangzewei` * */public class LoginAction02 &#123; //保证对象要有无参的构造方法 private User user; //IOC方式 //登陆处理业务 public String login() &#123; System.out.println(\"username=\"+user.getUsername()+\"\\tpassword=\"+user.getPassword()); return Action.SUCCESS; &#125; public User getUser() &#123; return user; &#125; public void setUser(User user) &#123; this.user = user; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435&lt;!--显示成功页面--&gt;&lt;%@ page language=\"java\" contentType=\"text/html; charset=utf-8\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"utf-8\"&gt;&lt;title&gt;成功页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;My First Struts Demo&lt;/h1&gt; &lt;!-- 属性驱动 --&gt; &lt;!--&lt;h3&gt;恭喜$&#123;username&#125;登录成功&lt;h3&gt; &lt;h2&gt;$&#123;password&#125;&lt;h2&gt;--&gt; &lt;!-- 对象驱动 --&gt; &lt;h3&gt;恭喜$&#123;user.username&#125;登录成功&lt;h3&gt; &lt;h2&gt;$&#123;user.password&#125;&lt;h2&gt;&lt;/body&gt;&lt;/html&gt;&lt;!--登录页面--&gt;&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Struts2的数据处理&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=\"login02.action\" method=\"post\"&gt; username:&lt;input type=\"text\" name=\"user.username\"/&gt;&lt;br&gt; password:&lt;input type=\"password\" name=\"user.password\"/&gt;&lt;br&gt; &lt;input type=\"button\" value=\"登录\"/&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 模式驱动：在对象驱动中，页面的表单域名称比较复杂，如果对象属性比较多的情况下，代码量比较大。通过模式驱动可以解决这个问题。 模式驱动需要实现ModelDriver接口，并且主动将对象创建好。 12345678910111213141516171819202122232425262728293031323334//处理类package demo;import com.opensymphony.xwork2.Action;import com.opensymphony.xwork2.ModelDriven;import entity.User;/*** * Struts2数据处理案列：模型驱动 * @author 1huangzewei * */public class LoginAction03 implements ModelDriven&lt;User&gt;&#123; //保证对象要有无参的构造方法 private User user=new User(); //IOC方式 //登陆处理业务 public String login() &#123; System.out.println(\"username=\"+user.getUsername()+\"\\tpassword=\"+user.getPassword()); return Action.SUCCESS; &#125; public User getUser() &#123; return user; &#125; public void setUser(User user) &#123; this.user = user; &#125; @Override public User getModel() &#123; // TODO Auto-generated method stub return user; &#125;&#125; 12345678910111213141516171819202122232425262728293031&lt;!--登录页面--&gt;&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Struts2的数据处理&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=\"login02.action\" method=\"post\"&gt; username:&lt;input type=\"text\" name=\"username\"/&gt;&lt;br&gt; password:&lt;input type=\"password\" name=\"password\"/&gt;&lt;br&gt; &lt;input type=\"button\" value=\"登录\"/&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;&lt;!--显示页面--&gt;&lt;%@ page language=\"java\" contentType=\"text/html; charset=utf-8\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"utf-8\"&gt;&lt;title&gt;成功页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;My First Struts Demo&lt;/h1&gt; &lt;h3&gt;恭喜$&#123;username&#125;登录成功&lt;h3&gt; &lt;h2&gt;$&#123;password&#125;&lt;h2&gt;&lt;/body&gt;&lt;/html&gt; 第七讲 数据处理二 IOC：控制反转 对象驱动方式获取属性：（重点） 在action的处理类中，属性以对象的形式存在，该属性对象只需声明并为其提供get方法和set方法即可，需要保证该属性对象有无参构造方法。 在表单域中的表单域名称以属性对象.属性对象的属性来命名。 这种方式比较重要 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//User类package entity;public class User &#123; //如果要提供构造函数，要提供一个无参构造方法 private String username; private String password; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; &#125;//处理类package demo;import com.opensymphony.xwork2.Action;import entity.User;/*** * Struts2数据处理案列 * @author 1huangzewei * */public class LoginAction02 &#123; //保证对象要有无参的构造方法 private User user; //IOC方式 //登陆处理业务 public String login() &#123; System.out.println(\"username=\"+user.getUsername()+\"\\tpassword=\"+user.getPassword()); return Action.SUCCESS; &#125; public User getUser() &#123; return user; &#125; public void setUser(User user) &#123; this.user = user; &#125;&#125; 123456789101112131415161718&lt;!--显示成功页面--&gt;&lt;%@ page language=\"java\" contentType=\"text/html; charset=utf-8\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"utf-8\"&gt;&lt;title&gt;成功页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;My First Struts Demo&lt;/h1&gt; &lt;!-- 属性驱动 --&gt; &lt;!--&lt;h3&gt;恭喜$&#123;username&#125;登录成功&lt;h3&gt; &lt;h2&gt;$&#123;password&#125;&lt;h2&gt;--&gt; &lt;!-- 对象驱动 --&gt; &lt;h3&gt;恭喜$&#123;user.username&#125;登录成功&lt;h3&gt; &lt;h2&gt;$&#123;user.password&#125;&lt;h2&gt;&lt;/body&gt;&lt;/html&gt; 第八讲 action的几种创建方式 在Struts2中有三种方式来创建action处理类 实现action接口的方式来创建处理类,好处: 可以直接使用Action类提供的常量 必须重写默认的处理方法。 这种方法使用比较少。 123456789101112131415161718192021package com.zhuchuli.action;import com.opensymphony.xwork2.Action;/*** * 通过实现Action接口来创建处理类：好处 *实现action接口的方式可以使用Action提供的常量 *必须重写默认处理方法 *这种方式使用的比较少 * @author 1huangzewei * */public class HelloAction implements Action&#123; @Override public String execute() throws Exception &#123; System.out.println(\"action execute\"); return SUCCESS; &#125;&#125; 通过继承ActionSupport类来创建Action的处理类，Strut2推荐使用这种方式。 1234567891011121314151617package com.zhuchuli.action;import com.opensymphony.xwork2.ActionSupport;/*** * 通过继承ActionSupport创建Action处理类：好处 * 并且ActionSupport类提供了很多其他Struts2的功能。 * 比如：数据校验，国际化 * 内部已经提供了默认实现方法 * * @author 1huangzewei * */public class HelloAction02 extends ActionSupport&#123;&#125; 无侵入性的实现方式 12345678910111213141516package com.zhuchuli.action;import com.opensymphony.xwork2.Action;/*** * 无侵入性的实现方式 * @author 1huangzewei * */public class Hello02Action &#123; public String execute() &#123; System.out.println(\"无侵入性的实现方式\"); return Action.SUCCESS; &#125;&#125; 第九讲 Struts2配置讲解2 constant标签 1234567 &lt;!-- strut2的常量配置 --&gt;&lt;!-- 扩展名的配置 --&gt;&lt;constant name=\"struts.action.extension\" value=\"do,zhangsan,,action\"&gt;&lt;/constant&gt;&lt;!-- 设置页面字符集，页面解决 --&gt;&lt;constant name=\"struts.i18n.encoding\" value=\"utf-8\"&gt;&lt;/constant&gt;&lt;!-- 开发模式 --&gt;&lt;constant name=\"struts.devMode\" value=\"true\"&gt;&lt;/constant&gt; include标签：引入其他的配置文件，在团队开发中使用 1234567&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE struts PUBLIC \"-//Apache Software Foundation//DTD Struts Configuration 2.3//EN\" \"http://struts.apache.org/dtds/struts-2.3.dtd\"&gt;&lt;struts&gt; &lt;include file=\"struts2/conguration/system.xml\"&gt;&lt;/include&gt; &lt;/struts&gt; 第十讲 action的优化配置 在Struts2中，随着业务的增加，action的配置文件会急剧增加，导致了配置文件膨胀的问题。struts2中提供了三种方式来解决这个问题。 通过动态方法调用来解决。 通过通配符来解决。 通过注解来解决。 传统的action方式，配置文件会变得很庞大 1234567891011121314151617181920&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE struts PUBLIC \"-//Apache Software Foundation//DTD Struts Configuration 2.3//EN\" \"http://struts.apache.org/dtds/struts-2.3.dtd\"&gt;&lt;struts&gt; &lt;package name=\"default\" namespace=\"/\" extends=\"struts-default\"&gt; &lt;action name=\"save\" class=\"com.zhuchuli.action.UserAction\" method=\"save\"&gt; &lt;result type=\"redirectAction\"&gt;find&lt;/result&gt; &lt;/action&gt; &lt;action name=\"delete\" class=\"com.zhuchuli.action.UserAction\" method=\"delete\"&gt; &lt;result type=\"redirectAction\"&gt;find&lt;/result&gt; &lt;/action&gt; &lt;action name=\"update\" class=\"com.zhuchuli.action.UserAction\" method=\"update\"&gt; &lt;result type=\"redirectAction\"&gt;find&lt;/result&gt; &lt;/action&gt; &lt;action name=\"query\" class=\"com.zhuchuli.action.UserAction\" method=\"query\"&gt; &lt;result&gt;/list.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt; &lt;/struts&gt; 12345678910111213141516171819202122package com.zhuchuli.action;import com.opensymphony.xwork2.Action;public class UserAction &#123; //增加 public String save() &#123; return Action.SUCCESS; &#125; //删除 public String delete() &#123; return Action.SUCCESS; &#125; //修改 public String update() &#123; return Action.SUCCESS; &#125; //查询 public String query() &#123; return Action.SUCCESS; &#125;&#125; 通过动态方法解决该问题 在常量中开启动态方法调用。&lt;constant name=&quot;struts.enable.DynamicMethodInvocation&quot; value=&quot;true&quot;&gt;&lt;/constant&gt; 配置action,一个Action处理类，只需配置一次。不需要配置处理方法。 123456&lt;action name=\"userAction\" class=\"com.zhuchuli.action.UserAction\"&gt; &lt;result type=\"redirect\"&gt;userAction!query.action&lt;/result&gt; &lt;result type=\"redirect\"&gt;userAction!delete.action&lt;/result&gt; &lt;result name=\"list\"&gt;/list.jsp&lt;/result&gt; &lt;result name=\"delete\"&gt;/delete.jsp&lt;/result&gt;&lt;/action&gt; 调用处理方法，ActionName!method.action，例如:http://localhost:8080/Struts_study02/userAction!delete.action 注意：使用动态方法调用需要不同处理方法的返回值是否一致问题。会配置多个结果集。这种方式不推荐使用，不安全。 12345678&lt;!-- *表示一个或多个字符 --&gt;&lt;!-- 占位符&#123;1&#125;表示匹配第一个“*”的内容 --&gt;&lt;!-- 使用通配符配置时，需要注意如果有不是通配符的action，先匹配action再匹配通配符--&gt;&lt;!-- 在实际应用开发中，使用通配符比较常见 --&gt;&lt;action name=\"*\" class=\"com.zhuchuli.action.UserAction\" method=\"&#123;1&#125;\"&gt; &lt;result type=\"redirect\"&gt;query&lt;/result&gt; &lt;result&gt;/list.jsp&lt;/result&gt;&lt;/action&gt; 注意如果使用通配符配置，那么需要注意不同处理方法的返回值的问题。 使用注解来解决。 使用注解需要导入struts2-convention-plugin-2.3.37.jar、asm-3.3.jar、asm-commons-3.3.jar、asm-tree-3.3.jar 在处理类上填写相关注解 123456789101112131415161718192021222324252627282930313233343536373839package com.zhuchuli.action;import org.apache.struts2.convention.annotation.Action;import org.apache.struts2.convention.annotation.Namespace;import org.apache.struts2.convention.annotation.ParentPackage;import org.apache.struts2.convention.annotation.Result;@ParentPackage(value=\"struts-default\")@Namespace(value=\"/\")public class UserAction &#123; //增加 @Action(value=\"save\",results= &#123; @Result(location=\"/list.jsp\") &#125;) public String save() &#123; System.out.println(\"save\"); return \"success\"; &#125; //删除 public String delete() &#123; System.out.println(\"delete\"); return \"success\"; &#125; //修改 public String update() &#123; System.out.println(\"update\"); return \"success\"; &#125; // //查询 @Action(value=\"query\",results= &#123; @Result(name=\"list\",location=\"/list.jsp\") &#125;) public String query() &#123; System.out.println(\"query\"); return \"list\"; &#125;&#125; 第十一讲 ThreadLocal和ActionContext ThreadLocal是一个容器，存放在容器中的数据是线程安全的。 123456789101112131415161718package threadlocal;public class ThreadLocalDemo &#123; public static void main(String[] args) &#123; final ThreadLocal&lt;Integer&gt; th=new ThreadLocal&lt;Integer&gt;(); //向ThreadLocal中存放数据 th.set(23); new Thread(() -&gt; &#123; th.set(12); System.out.println(\"====================\"); //获取存放在容器中的数据 System.out.println(\"thread--&gt;\"+th.get());//12 &#125;) .start(); System.out.println(\"main --&gt;\"+th.get()); //23 &#125;&#125; ActionContext：是Struts2的上下文对象，它的本质是一个容器，也是一个Map结构的对象。ActionContext贯穿于整个Action生命周期，每次接受请求后都会新建一个ActionContext对象，将ServletAPI中的数据存入到ActionContext中，实现了struts2和Servlet的解耦，使得测试可以不依赖容器。而且ActionContext是线程安全的。由于每次请求都会重新创建ActionContext，导致执行效率比Servlet低。 ActionContext有六个对象： request：存放的是HttpServletRequest域中的数据。 session：存放的是HttpSession域中的数据。 application：存放的是ServletContext域中的数据。 parameters：存放的是请求参数 attr：存放的是request、session、application中的数据。 ValueStacke：业务处理类的相关数据。 12345678// helpers to get access to request/session/application scopeextraContext.put(\"request\", requestMap);extraContext.put(\"session\", sessionMap);extraContext.put(\"application\", applicationMap);extraContext.put(\"parameters\", parameterMap);AttributeMap attrMap = new AttributeMap(extraContext);extraContext.put(\"attr\", attrMap); ServletContext:是一个容器，是一个对象，相当于map。 第十二讲 ognl ognl：Object graph navigation language，对象导航图语言。 在Struts2中，ognl完成数据设置和类型转换两个功能。 在struts2中是通过ognl来设值和取值的。ActionContext作为ognl的上下文，ValueStack作为ognl的root对象 在struts2中使用ognl表达式获取数据需要使用struts2的标签库，使用struts2的标签库，需要注意一定是通过过滤器后才能解析struts2的标签 123456789101112131415161718192021222324252627282930313233343536373839package demo;import com.opensymphony.xwork2.Action;import com.opensymphony.xwork2.ActionContext;/*** * Struts2数据处理案列：属性驱动 * @author 1huangzewei * */public class LoginAction &#123; private String username; private String password; //登陆处理业务 public String login() &#123; System.out.println(\"username=\"+username+\";password=\"+password); ActionContext.getContext().getApplication().put(\"address\", \"北京尚学堂\"); return Action.SUCCESS; &#125; public String getUsername() &#123; return username; &#125; public String getPassword() &#123; return password; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public void setPassword(String password) &#123; this.password = password; &#125; &#125; 12345678910111213141516&lt;%@ page language=\"java\" contentType=\"text/html; charset=utf-8\"%&gt;&lt;%@ taglib prefix=\"s\" uri=\"/struts-tags\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"utf-8\"&gt;&lt;title&gt;成功页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;My First Struts Demo&lt;/h1&gt; 登录成功，欢迎&lt;s:property value=\"username\"/&gt;&lt;br&gt; &lt;h2&gt;$&#123;password&#125;&lt;h2&gt; &lt;h3&gt;&lt;s:property value=\"#application.address\"/&gt;&lt;/h3&gt; &lt;h3&gt;&lt;s:property value=\"#parameters.username\"/&gt;&lt;/h3&gt;&lt;/body&gt;&lt;/html&gt; ognl获取各种域中的数据如下： application：#application.username、#application[&#39;username&#39;]； session：#session.username、#session[&#39;username&#39;]； request：#request.username、#request[&#39;username&#39;]； parameters：#parameters.username、#parameter[&#39;username&#39;]； attr：#attr.username、#attr[&#39;username&#39;]，按pageContext、request、session、application顺序查找。 第十三讲 ServletAPI 在Struts2的开发中，依然需要使用到ServletAPI，比如用户登录之后，需要将用户信息保存到session中.在Struts2中有两种方式可以获取ServletAPI,一种解耦方式，一种是耦合方式。 解耦的实现方式 12345678910111213141516171819202122232425262728293031package com.zhuchuli.action;import com.opensymphony.xwork2.Action;import com.opensymphony.xwork2.ActionContext;import cn.zhuchuli.vo.User;public class LoginAction &#123; //保证对象要有无参的构造方法 private User user; public User getUser() &#123; return user; &#125; public void setUser(User user) &#123; this.user = user; &#125; public String login() &#123; System.out.println(\"username=\"+user.getUsername()+\"\\tpassword=\"+user.getPassword()); if(\"possible\".equals(user.getUsername()) &amp;&amp; \"123456\".equals(user.getPassword())) &#123; //用户登录成功，将用户信息写入到session ActionContext.getContext().getSession().put(\"currentUser\", user); //获取request Map&lt;String,Object&gt; req=(Map&lt;String,Object&gt;)ActionContext.getContext().get(\"request\"); return Action.SUCCESS; &#125; return Action.LOGIN; &#125;&#125; 耦合的方式 直接通过ServletContext获取 12345678910public String login() &#123; System.out.println(\"username=\"+user.getUsername()+\"\\tpassword=\"+user.getPassword()); if(\"possible\".equals(user.getUsername()) &amp;&amp; \"123456\".equals(user.getPassword())) &#123; //直接获取ServletAPI,所以是耦合的方式 HttpServletRequest req=ServletActionContext.getRequest(); req.getSession().setAttribute(\"currentUser\", user); return Action.SUCCESS; &#125; return Action.LOGIN;&#125; 通过ActionContext获取 1234567891011public String login() &#123; System.out.println(\"username=\"+user.getUsername()+\"\\tpassword=\"+user.getPassword()); if(\"possible\".equals(user.getUsername()) &amp;&amp; \"123456\".equals(user.getPassword())) &#123; //通过ActionContext方式获取ServletAPI System.out.println(\"通过ActionContext方式获取ServletAPI\"); HttpServletRequest req=(HttpServletRequest) ActionContext.getContext().get(StrutsStatics.HTTP_REQUEST); req.getSession().setAttribute(\"currentUser\", user); return Action.SUCCESS; &#125; return Action.LOGIN; &#125; 通过IOC方式直接获取到ServletAPI 12345678910111213141516171819202122232425262728public class LoginAction03 implements ServletRequestAware&#123; //保证对象要有无参的构造方法 private User user; private HttpServletRequest req; public User getUser() &#123; return user; &#125; public void setUser(User user) &#123; this.user = user; &#125; public String login() &#123; System.out.println(\"username=\"+user.getUsername()+\"\\tpassword=\"+user.getPassword()); if(\"possible\".equals(user.getUsername()) &amp;&amp; \"123456\".equals(user.getPassword())) ; //通过IOC方法获取ServletAPI对象 System.out.println(\"通过IOC方法获取ServletAPI对象\"); req.getSession().setAttribute(\"currentUser\", user); return Action.SUCCESS; &#125; return Action.LOGIN; &#125; @Override public void setServletRequest(HttpServletRequest request) &#123; this.req=request; &#125;&#125; 第十四讲 类型转换 在Struts2中，对常用的数据类型已经自动进行了类型装换工作。但是对于自定义类型，Struts2没法去做类型转换工作。需要自定义类型转换器来实现类型的转换。 类型转换的实现步骤： 新建一个类型转换并继承StrutsTypeConverter 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package cn.zhuchuli.pointconverter;import java.util.Map;import org.apache.struts2.util.StrutsTypeConverter;import cn.zhuchuli.vo.Point;/*** * 自定义类型转换器 * @author 1huangzewei * */public class PointConverter extends StrutsTypeConverter &#123; /** * 将表单提交的数据在这个方法中被转换。 * 返回值是目标点对象 * Converts one or more String values to the specified class. * * @param context the action context * @param values the String values to be converted, such as those submitted from an HTML form * @param toClass the class to convert to * @return the converted object */ @Override public Object convertFromString(Map context, String[] values, Class toClass) &#123; System.out.println(\"将String转化为指定类型\"); String value=values[0]; Point point=new Point(); point.setX(Integer.parseInt(value.substring(1,value.indexOf(\",\")))); point.setY(Integer.parseInt(value.substring(value.indexOf(\",\")+1,value.indexOf(\")\")))); return point; &#125; /** * Converts the specified object to a String. * * @param context the action context * @param o the object to be converted * @return the converted String * 使用ognl表达式获取值会调用该方法 */ @Override public String convertToString(Map context, Object o) &#123; // TODO Auto-generated method stub System.out.println(\"将指定的类型转化为String\"); Point p=(Point) o; return \"(\"+p.getX()+\",\"+p.getY()+\")\"; &#125;&#125; 在src下添加xwork-conversion.properties配置文件 # be converted type=converter cn.zhuchuli.vo.Point = cn.zhuchuli.pointconverter.PointConverter 第十五讲 数据校验一 （硬编码实现） 数据校验分为2类，一类是前端的数据校验，一般通过js实现，一类是后端的数据验证。在对一些安全级别较高项目都需要对其进行后台验证。Struts2提供了两种后台校验方法，一种是硬编码实现，一种是校验框架实现。 如果要使用struts2的数据校验功能，action需要继承ActionSupport类。在该类中提供了validate方法，可以将验证规则写在该方法中，只有方法执行通过之后，才会执行业务方法。 实现步骤 业务处理类 123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.zhuchuli.action;import java.util.regex.Matcher;import java.util.regex.Pattern;import com.opensymphony.xwork2.ActionSupport;import cn.zhuchuli.vo.User;/*** * 数据校验 * @author 1huangzewei * */public class UserAction extends ActionSupport&#123; private User user; //限制validate方法，方法通过执行后执行execute发明方法。 //默认该方法是通过的。 //在validate方法中，添加了FieldError或者ActionError那么该方法将执行不能通过，并且返回结果集为INPUT // @Override public void validate() &#123; System.out.println(\"-------validate-------\"); Pattern p=Pattern.compile(\"[\\\\w]+[A-Za-z0-9]&#123;6,16&#125;\"); Matcher m=p.matcher(user.getName()); if(!m.find()) &#123; //用户名不合法，添加错误信息 this.addFieldError(\"user.name\", \"用户名不合法\"); &#125; super.validate(); &#125; public String execute() &#123; System.out.println(\"------execute---------\"); System.out.println(user); return SUCCESS; &#125; public User getUser() &#123; return user; &#125; public void setUser(User user) &#123; this.user = user; &#125; &#125; 在配置文件中配置input结果集 1234&lt;action name=\"user\" class=\"com.zhuchuli.action.UserAction\"&gt; &lt;result&gt;/success.jsp&lt;/result&gt; &lt;result name=\"input\"&gt;/save.jsp&lt;/result&gt;&lt;/action&gt; 在页面中添加struts2的标签库，并且添加错误标签 123456789101112131415161718&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib prefix=\"s\" uri=\"/struts-tags\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=\"user.action\" method=\"post\"&gt; name:&lt;input type=\"text\" name=\"user.name\"/&gt;&lt;s:fielderror fieldName=\"user.name\"&gt;&lt;/s:fielderror&gt;&lt;br&gt; sex:&lt;input type=\"text\" name=\"user.sex\"/&gt;&lt;br&gt; age:&lt;input type=\"text\" name=\"user.age\"/&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"登录\"/&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 通过上述方法来实现数据校验会有一个问题。一个业务类中有多个业务方法，并且每个业务方法的验证规则可能不一致，但是所有的业务方法都会通过validate。导致功能不能实现。在struts2中，如果一个业务类中有多个业务方法，那么需要为每个业务方法添加自己的验证方法。验证方法的命名规则为validate+业务方法名(首字母大写)。这样执行业务方法时，执行顺序为validateXxxx ---&gt; validate ---&gt; xxxx。这样的话，validate方法中填写的公共的验证方法。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package com.zhuchuli.action;import java.util.regex.Matcher;import java.util.regex.Pattern;import com.opensymphony.xwork2.ActionSupport;import cn.zhuchuli.vo.User;/*** * 数据校验 * @author 1huangzewei * */public class UserAction extends ActionSupport&#123; private User user; //限制validate方法，方法通过执行后执行execute发明方法。 //默认该方法是通过的。 //在validate方法中，添加了FieldError或者ActionError那么该方法将执行不能通过，并且返回结果集为INPUT // @Override public void validate() &#123; System.out.println(\"-------validate-------\"); Pattern p=Pattern.compile(\"[\\\\w]+[A-Za-z0-9]&#123;6,16&#125;\"); Matcher m=p.matcher(user.getName()); if(!m.find()) &#123; //用户名不合法，添加错误信息 this.addFieldError(\"user.name\", \"用户名不合法\"); &#125; super.validate(); &#125; public void validateExecute() &#123; System.out.println(\"-------validateExecute-------\"); Pattern p=Pattern.compile(\"[\\\\w]+[A-Za-z0-9]&#123;6,16&#125;\"); Matcher m=p.matcher(user.getName()); if(!m.find()) &#123; //用户名不合法，添加错误信息 this.addFieldError(\"user.name\", \"用户名不合法\"); &#125; super.validate(); &#125; public String execute() &#123; System.out.println(\"------execute---------\"); System.out.println(user); return SUCCESS; &#125; public User getUser() &#123; return user; &#125; public void setUser(User user) &#123; this.user = user; &#125; &#125; 第十五讲 数据校验二（使用Struts2提供的校验框架实现数据校验） 实现步骤 创建jsp页面 123456789101112131415161718&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib prefix=\"s\" uri=\"/struts-tags\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=\"user.action\" method=\"post\"&gt; name:&lt;input type=\"text\" name=\"user.name\"/&gt;&lt;s:fielderror fieldName=\"user.name\"&gt;&lt;/s:fielderror&gt;&lt;br&gt; sex:&lt;input type=\"text\" name=\"user.sex\"/&gt;&lt;br&gt; age:&lt;input type=\"text\" name=\"user.age\"/&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"登录\"/&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 创建Action类 12345678910111213141516171819202122232425package com.zhuchuli.action;import com.opensymphony.xwork2.ActionSupport;import cn.zhuchuli.vo.User;public class UserFormAction extends ActionSupport&#123; private User user; public String execute() &#123; System.out.println(\"------execute---------\"); System.out.println(user); return SUCCESS; &#125; public User getUser() &#123; return user; &#125; public void setUser(User user) &#123; this.user = user; &#125;&#125; 在Action类所在包下，添加校验规则文件以ActionClassName-validation.xml命名 123456789101112131415161718&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;!DOCTYPE validators PUBLIC \"-//Apache Struts//XWork Validator 1.0//EN\" \"http://struts.apache.org/dtds/xwork-validator-1.0.dtd\"&gt; &lt;validators&gt; &lt;!--field表示对哪个表单域进行验证 --&gt; &lt;field name=\"user.name\"&gt; &lt;!-- 字段验证器 Struts2默认提供了很多验证器 --&gt; &lt;field-validator type=\"requiredstring\"&gt; &lt;message&gt;你必须输入姓名。&lt;/message&gt; &lt;/field-validator&gt; &lt;field-validator type=\"stringlength\"&gt; &lt;param name=\"maxLength\"&gt;10&lt;/param&gt; &lt;param name=\"minLength\"&gt;4&lt;/param&gt; &lt;message&gt;你必须输入姓名在$&#123;maxLength&#125;和$&#123;minLength&#125;之间&lt;/message&gt; &lt;/field-validator&gt; &lt;/field&gt; &lt;/validators&gt; 配置Struts.xml文件 12345678910111213141516171819&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE struts PUBLIC \"-//Apache Software Foundation//DTD Struts Configuration 2.3//EN\" \"http://struts.apache.org/dtds/struts-2.3.dtd\"&gt;&lt;struts&gt; &lt;package name=\"default\" namespace=\"/\" extends=\"struts-default\"&gt; &lt;!-- &lt;action name=\"point\" class=\"com.zhuchuli.action.PointAction\"&gt; &lt;result&gt;/success.jsp&lt;/result&gt; &lt;/action&gt; &lt;action name=\"user\" class=\"com.zhuchuli.action.UserAction\"&gt; &lt;result&gt;/success.jsp&lt;/result&gt; &lt;result name=\"input\"&gt;/save.jsp&lt;/result&gt; &lt;/action&gt; --&gt; &lt;action name=\"user\" class=\"com.zhuchuli.action.UserFormAction\"&gt; &lt;result&gt;/success.jsp&lt;/result&gt; &lt;result name=\"input\"&gt;/save.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt; &lt;/struts&gt; 第十七讲 Struts2拦截器 struts2中的所有功能都是由拦截器来实现的。拦截器是Struts2的核心。拦截器和过滤器非常相似，过滤器过滤的是所有的请求，拦截器纸过滤action，并且在struts2中所有的功能都是可插拔的。在struts2中还可以自定义拦截器来实现一些struts2没有提供的功能。在struts2中拦截器的实现是通过代理来实现的。（AOP）在Struts2中拦截器都是单列的，所有的action共享相同的拦截器，所以在拦截器定义常量时要注意线程安全问题。 Struts2中提供很多拦截器来实现各种功能，在开发中可以根据不同的应用选择不同的拦截器来实现功能。Struts2提供了一系列默认的拦截器（拦截器栈）来实现功能。 默认拦截器说明 alias：对于HTTP请求包含的参数设置别名 autowiring：将某些JavaBean实例自动绑定到其他Bean对应的属性中。有点类似Spring的自动绑定，在Spring部分会详细说明。 Chain：在Web项目开发中，以前使用Struts开发时候经常碰到两个Action互相传递参数或属性的情况。该拦截器就是让前一Action的参数可以在现有Action中使用。 conversionError：从ActionContext中将转化类型时候发生的错误添加到Action的值域错误中，在校验时候经常被使用到来显示类型转化错误的信息。 cookie：从Struts&lt; xmlnamespace prefix=&quot;ST1&quot; &gt;2.0.7版本开始，可以把cookie注入Action中可设置的名字或值中。 createSession：自动创建一个HTTP的Session，尤其是对需要HTTP的Session的拦截器特别有用。比如下面介绍的TokenInterceptor。 debugging：用来对在视图间传递的数据进行调试。 ExecAndWait：不显式执行Action，在视图上显示给用户的是一个正在等待的页面，但是Action其实是在“背后”正在执行着。该拦截器尤其在对进度条进行开发的时候特别有用。 exception：将异常和Action返回的result相映射。 fileUpload：支持文件上传功能的拦截器。 i18n：支持国际化的拦截器。 logger：拥有日志功能的拦截器。 modelDriven：Action执行该拦截器时候，可以将getModel方法得到的result值放入值栈中 scopedModelDriven：执行该拦截器时候，它可以从一个scope范围检索和存储model值，通过调用setModel方法去设置model值。 params：将HTTP请求中包含的参数值设置到Action中。 prepare：假如Action继承了Preparable接口，则会调用prepare方法。 staticParams：对于在struts.xml文件中Action中设置的参数设置到对应的Action中。 scope：在session或者application范围中设置Action的状态 servletConfig：该拦截器提供访问包含HttpServletResquest和HttpServletResponse对象的Map的方法。 timer：输出Action的执行时间。 token：避免重复提交的校验拦截器 tokenSession：和token拦截器类似，但它还能存储提交的数据到session里。 validation：运行在action-validation.xml(校验章节将介绍)文件中定义的校验规则。 workflow：在Action中调用validate校验方法。如果Action有错误则返回到input视图。 store：执行校验功能时候，该拦截器提供存储和检索Action的所有错误和正确信息的功能。 checkbox：视图中如果有checkbox存在的情况，该拦截器自动将unchecked的checkbox当作一个参数（通常值为“false”）记录下来。这样可以用一个隐藏的表单值来记录所有未提交的checkbox，而且缺省unchecked的checkbox值是布尔类型的，如果视图中checkbox的值设置的不是布尔类型，它就会被覆盖成布尔类型的值。 profiling：通过参数来激活或不激活分析检测功能，前提是Web项目是在开发模式下。（涉及到调试和性能检验时使用） roles：进行权限配置的拦截器，如果登录用户拥有相应权限才去执行某一特定Action。 Struts2中的默认拦截器是定义在struts-default.xml中。这些拦截器都是定义在struts-default包下的。所以在使用struts2时定义的package要直接或间接继承struts-default 常见内置拦截器的使用，使用内置拦截器是需要引用拦截器。 Timer拦截器的使用 创建action类 12345678package com.zhuchuli.interceptor;public class TimerAction &#123; public String execute() &#123; System.out.println(\"Hello action\"); return \"none\"; &#125;&#125; 在配置文件中进行配置 1234567891011&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE struts PUBLIC \"-//Apache Software Foundation//DTD Struts Configuration 2.3//EN\" \"http://struts.apache.org/dtds/struts-2.3.dtd\"&gt;&lt;struts&gt; &lt;package name=\"default\" namespace=\"/\" extends=\"struts-default\"&gt; &lt;action name=\"interceptor\" class=\"com.zhuchuli.interceptor.TimerAction\"&gt; &lt;result&gt;&lt;/result&gt; &lt;!-- 使用拦截器时，需要在指定的action中引用拦截器 --&gt; &lt;interceptor-ref name=\"timer\"&gt;&lt;/interceptor-ref&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; token拦截器的使用 创建Action类 12345678910111213141516171819202122232425package com.zhuchuli.interceptor;import com.opensymphony.xwork2.Action;import com.opensymphony.xwork2.ActionSupport;import com.zhuchuuli.vo.User;public class UserAction extends ActionSupport&#123; private User user; public String toSave() &#123; return Action.SUCCESS; &#125; public String save() &#123; System.out.println(\"add user to database\"); System.out.println(user); return Action.SUCCESS; &#125; public User getUser() &#123; return user; &#125; public void setUser(User user) &#123; this.user = user; &#125; &#125; 在页面中添加token标签 123456789101112131415161718&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib prefix=\"s\" uri=\"/struts-tags\" %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;提交页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=\"interceptor.action\" method=\"post\"&gt; &lt;s:token&gt;&lt;/s:token&gt; name:&lt;input type=\"text\" name=\"user.name\"/&gt;&lt;br&gt; age:&lt;input type=\"text\" name=\"user.age\"/&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"save\" /&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 在action中引用token 1234567891011121314&lt;action name=\"save\" class=\"com.zhuchuli.interceptor.UserAction\" method=\"save\"&gt; &lt;interceptor-ref name=\"token\"&gt;&lt;/interceptor-ref&gt; &lt;interceptor-ref name=\"basicStack\"/&gt; &lt;result&gt;/success.jsp&lt;/result&gt; &lt;result name=\"invalid.token\"&gt;/invalid.jsp&lt;/result&gt; &lt;!-- 使用拦截器时，需要在指定的action中引用拦截器 --&gt; &lt;!-- &lt;interceptor-ref name=\"timer\"&gt;&lt;/interceptor-ref&gt; --&gt; &lt;!-- 当用户重复提交时，会返回invalid.token结果集 --&gt; &lt;/action&gt; &lt;action name=\"toSave\" class=\"com.zhuchuli.interceptor.UserAction\" method=\"toSave\"&gt; &lt;result&gt;/save.jsp&lt;/result&gt; &lt;/action&gt; 编写失效页面。 123456789101112&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;表单不能重复提交&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 第十八讲 自定义拦截器 在开发中，经常会使用到struts2中没有提供的一些功能，这时需要我们自定义拦截器来实现。当引用自定义拦截器后，struts2提供的默认拦截器将不起作用，需要重新引入。 自定义拦截器的实现步骤： 定义拦截器 123456789101112131415161718192021222324252627282930313233343536373839package com.zhuchuli.myinterceptor;import com.opensymphony.xwork2.ActionInvocation;import com.opensymphony.xwork2.interceptor.Interceptor;/*** * 自定义拦截器 * 有两种实现方式 * 实现Interceptor接口 * 继承AbstractInterceptor类 * @author 1huangzewei * */public class MyInterceptor implements Interceptor&#123; @Override public void destroy() &#123; // TODO Auto-generated method stub &#125; @Override public void init() &#123; // TODO Auto-generated method stub &#125; //拦截器的主体实现 /*** * 当拦截器的方法被调用执行后，需要调用 invocation.invoke调用下一个拦截器。 * 如果没有拦截器，那么执行action中的业务方法。 */ @Override public String intercept(ActionInvocation invocation) throws Exception &#123; System.out.println(\"-------------------自定义拦截器被执行了o-------------------\"); //返回值为结果集 return invocation.invoke(); &#125;&#125; 在package中配置拦截器 1234&lt;!-- 拦截器的配置 --&gt;&lt;interceptors&gt; &lt;interceptor name=\"MyIntercept\" class=\"com.zhuchuli.myinterceptor.MyInterceptor\"&gt;&lt;/interceptor&gt;&lt;/interceptors&gt; 在使用action中引用拦截器 123456&lt;action name=\"timer\" class=\"com.zhuchuli.interceptor.TimerAction\"&gt; &lt;interceptor-ref name=\"timer\"&gt;&lt;/interceptor-ref&gt; &lt;!-- 使用自定义拦截器 --&gt; &lt;interceptor-ref name=\"MyIntercept\"&gt;&lt;/interceptor-ref&gt; &lt;result&gt;/success.jsp&lt;/result&gt;&lt;/action&gt; 登录拦截器的实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.zhuchuli.myinterceptor;import com.opensymphony.xwork2.Action;import com.opensymphony.xwork2.ActionInvocation;import com.opensymphony.xwork2.interceptor.Interceptor;/*** * 登录拦截器的实现 * @author 1huangzewei * */public class LoginInterceptor implements Interceptor&#123; @Override public void destroy() &#123; // TODO Auto-generated method stub &#125; @Override public void init() &#123; // TODO Auto-generated method stub &#125; /** * 判断是否是登录的action，如果是，继续执行 * 如果不是 判断session中是否存在用户， * 如果没有，跳转到登录界面 * 如果有继续执行 */ @Override public String intercept(ActionInvocation invocation) throws Exception &#123; String actionName= invocation.getProxy().getActionName(); if(\"login\".equals(actionName)) &#123; return invocation.invoke(); &#125; Object currentUser=invocation.getInvocationContext().getSession().get(\"currentUser\"); if(currentUser!=null) &#123; return invocation.invoke(); &#125; return Action.LOGIN; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839&lt;package name=\"default\" namespace=\"/\" extends=\"struts-default\"&gt; &lt;!-- 拦截器的配置 --&gt; &lt;interceptors&gt; &lt;interceptor name=\"MyIntercept\" class=\"com.zhuchuli.myinterceptor.MyInterceptor\"&gt;&lt;/interceptor&gt; &lt;interceptor name=\"loginIntercept\" class=\"com.zhuchuli.myinterceptor.LoginInterceptor\"&gt;&lt;/interceptor&gt; &lt;/interceptors&gt; &lt;!-- 配置全局结果集 --&gt; &lt;!-- 当前action结果集找不到，就去找全局结果集，如果再找不到，返回404 --&gt; &lt;global-results&gt; &lt;result name=\"login\"&gt;/login.jsp&lt;/result&gt; &lt;result name=\"input\"&gt;/login.jsp&lt;/result&gt; &lt;/global-results&gt; &lt;action name=\"timer\" class=\"com.zhuchuli.interceptor.TimerAction\"&gt; &lt;interceptor-ref name=\"timer\"&gt;&lt;/interceptor-ref&gt; &lt;!-- 使用自定义拦截器 --&gt; &lt;interceptor-ref name=\"MyIntercept\"&gt;&lt;/interceptor-ref&gt; &lt;result&gt;/success.jsp&lt;/result&gt; &lt;interceptor-ref name=\"loginIntercept\"/&gt; &lt;/action&gt; &lt;action name=\"save\" class=\"com.zhuchuli.interceptor.UserAction\" method=\"save\"&gt; &lt;!-- 使用拦截器时，需要在指定的action中引用拦截器 --&gt; &lt;!-- &lt;interceptor-ref name=\"timer\"&gt;&lt;/interceptor-ref&gt; --&gt; &lt;!-- 当用户重复提交时，会返回invalid.token结果集 --&gt; &lt;interceptor-ref name=\"token\"&gt;&lt;/interceptor-ref&gt; &lt;interceptor-ref name=\"basicStack\"/&gt; &lt;interceptor-ref name=\"loginIntercept\"/&gt; &lt;result&gt;/success.jsp&lt;/result&gt; &lt;result name=\"invalid.token\"&gt;/invalid.jsp&lt;/result&gt; &lt;/action&gt; &lt;action name=\"toSave\" class=\"com.zhuchuli.interceptor.UserAction\" method=\"toSave\"&gt; &lt;result&gt;/save.jsp&lt;/result&gt; &lt;interceptor-ref name=\"loginIntercept\"/&gt; &lt;/action&gt; &lt;action name=\"login\" class=\"com.zhuchuli.interceptor.UserAction02\" method=\"login\"&gt; &lt;result&gt;/success.jsp&lt;/result&gt; &lt;interceptor-ref name=\"loginIntercept\"/&gt; &lt;interceptor-ref name=\"basicStack\"/&gt; &lt;/action&gt; &lt;/package&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.zhuchuli.interceptor;import java.util.regex.Matcher;import java.util.regex.Pattern;import org.apache.struts2.ServletActionContext;import com.opensymphony.xwork2.Action;import com.opensymphony.xwork2.ActionSupport;import com.zhuchuuli.vo.User02;public class UserAction02 extends ActionSupport&#123; private User02 user; //进行数据校验 public void validate() &#123; Pattern p=Pattern.compile(\"[\\\\w]+[A-Za-z0-9]&#123;6,16&#125;\"); Matcher m=p.matcher(user.getPwd()); if(!((user.getName().length()&gt;=4||user.getName().length()&lt;=10)&amp;&amp; m.find())) &#123; //用户名不合法，添加错误信息 this.addFieldError(\"user.name\", \"用户名或密码不合法\"); &#125; &#125; public String toSave() &#123; return Action.SUCCESS; &#125; public String login() &#123; System.out.println(\"------login---------\"); //ServletActionContext.getRequest().getSession().setAttribute(\"currentUser\", user); //采用解耦的方式进行SevletAPI操作 if(\"possible\".equals(user.getName())&amp;&amp;\"123456\".equals(user.getPwd())) &#123; ServletActionContext.getContext().getSession().put(\"currentUser\", user); System.out.println(ServletActionContext.getContext().getSession().get(\"currentUser\")); return Action.SUCCESS; &#125;else &#123; return Action.LOGIN; &#125; &#125; public User02 getUser() &#123; return user; &#125; public void setUser(User02 user) &#123; this.user = user; &#125; &#125; 12345678910111213141516171819package com.zhuchuuli.vo;public class User02 &#123; private String name; private String pwd; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getPwd() &#123; return pwd; &#125; public void setPwd(String pwd) &#123; this.pwd = pwd; &#125; &#125; 12345678910111213141516171819&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib prefix=\"s\" uri=\"/struts-tags\" %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=\"login.action\" method=\"post\"&gt; 用户名：&lt;input type=\"text\" name=\"user.name\"/&gt;&lt;br&gt; 密码：&lt;input type=\"password\" name=\"user.pwd\"/&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"登录\"/&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 第十九讲 拦截器栈和方法拦截器 拦截器栈：就是一组拦截器，放在一个配置中，在拦截器栈中可以引用多个拦截器，在真正需要调用时只需要一个栈即可,方便引用,拦截器中可以引用另外一个拦截器栈, 1234567891011&lt;!-- 拦截器的配置 --&gt;&lt;interceptors&gt; &lt;interceptor name=\"MyIntercept\" class=\"com.zhuchuli.myinterceptor.MyInterceptor\"&gt;&lt;/interceptor&gt; &lt;interceptor name=\"loginIntercept\" class=\"com.zhuchuli.myinterceptor.LoginInterceptor\"&gt;&lt;/interceptor&gt; &lt;!-- 拦截器栈 --&gt; &lt;interceptor-stack name=\"myStack\"&gt; &lt;interceptor-ref name=\"basicStack\"/&gt; &lt;interceptor-ref name=\"loginIntercept\"/&gt; &lt;interceptor-ref name=\"basicStack\"/&gt; &lt;/interceptor-stack&gt;&lt;/interceptors&gt; 拦截器栈的引用，与拦截器引用一致，可以将拦截器栈当做拦截器来使用 1&lt;interceptor-ref name=\"myStack\"&gt;&lt;/interceptor-ref&gt; 设置默认拦截器栈 12&lt;!-- 设置默认拦截器--&gt;&lt;!-- &lt;default-action-ref name=\"myStack\"&gt;&lt;/default-action-ref&gt;--&gt; Struts2定义了默认的拦截器栈是defaultStack，里面有默认的18个拦截器。 拦截器拦截的是整个action，action中的所有业务方法都会被拦截。比较粗粒度。有时只需拦截action中某个方法或某几个方法就能实现功能，那么拦截器就会造成效率降低。这时可以通过方法拦截器来解决这个问题。 方法拦截器的实现 123456789101112131415161718192021222324package com.zhuchuli.myinterceptor;import com.opensymphony.xwork2.ActionInvocation;import com.opensymphony.xwork2.interceptor.MethodFilterInterceptor;/*** * 方法拦截器的实现 继承 MethodFilterInterceptor * @author 1huangzewei * */public class MethodInterceptor extends MethodFilterInterceptor&#123; /** * */ private static final long serialVersionUID = 1L; @Override protected String doIntercept(ActionInvocation invocation) throws Exception &#123; System.out.println(\"方法拦截器被执行\"); return invocation.invoke(); &#125;&#125; 12345678910111213141516&lt;interceptors&gt; &lt;interceptor name=\"MyIntercept\" class=\"com.zhuchuli.myinterceptor.MyInterceptor\"&gt;&lt;/interceptor&gt; &lt;interceptor name=\"loginIntercept\" class=\"com.zhuchuli.myinterceptor.LoginInterceptor\"&gt;&lt;/interceptor&gt; &lt;interceptor name=\"methodInterceptor\" class=\"com.zhuchuli.myinterceptor.MethodInterceptor\"&gt;&lt;/interceptor&gt; &lt;!-- 拦截器栈 --&gt; &lt;interceptor-stack name=\"myStack\"&gt; &lt;interceptor-ref name=\"basicStack\"/&gt; &lt;interceptor-ref name=\"loginIntercept\"/&gt; &lt;interceptor-ref name=\"basicStack\"/&gt; &lt;interceptor-ref name=\"methodInterceptor\"&gt; &lt;!-- 配置哪些方法被拦截 --&gt; &lt;param name=\"includeMethods\"&gt;timer,toSave&lt;/param&gt; &lt;!-- 配置哪些方法不被拦截 --&gt; &lt;param name=\"excludeMethods\"&gt;timer,toSave&lt;/param&gt; &lt;/interceptor-ref&gt; &lt;/interceptor-stack&gt;&lt;/interceptors&gt; 第二十讲 内置拦截器的使用情况。第二十一讲 struts 文件上传（使用默认的内置拦截器） 在大部分应用中都有文件上传的功能。servlet中可以使用第三方插件来实现文件上传：smartfileupload、commons-fileuoload 文件上传步骤 添加jsp页面，注意表单提交必须是post提交，并且设置`enctype=”multipart/form-data” 1234567891011121314&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;文件上传&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=\"upload.action\" method=\"post\" enctype=\"multipart/form-data\"&gt; 文件:&lt;input type=\"file\" name=\"file\"/&gt;&lt;input type=\"submit\" value=\"上传\"&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 添加文件上传处理类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package com.zhuchuli.action;import java.io.File;import java.io.IOException;import org.apache.commons.io.FileUtils;import org.apache.struts2.ServletActionContext;import com.opensymphony.xwork2.Action;/*** * 文件上传处理类 * @author 1huangzewei * */public class UploadAction &#123; //File属性名与表单域相同 类型为File private File file; //上传文件的名称，也是由struts2设置好 //属性名=表单域名+FileName private String fileFileName; //文件类型 = 表单域名+ContentType private String fileContentType; //上传文件的业务方法 public String upload() &#123; //获取上传文件目录 String path=ServletActionContext.getServletContext().getRealPath(\"/upload\"); try &#123; FileUtils.copyFile(file, new File(path,fileFileName)); return Action.SUCCESS; &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; return Action.ERROR; &#125; public File getFile() &#123; return file; &#125; public void setFile(File file) &#123; this.file = file; &#125; public String getFileFileName() &#123; return fileFileName; &#125; public void setFileFileName(String fileFileName) &#123; this.fileFileName = fileFileName; &#125; public String getFileContentType() &#123; return fileContentType; &#125; public void setFileContentType(String fileContentType) &#123; this.fileContentType = fileContentType; &#125; &#125; 添加配置文件 12345678910111213141516171819&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE struts PUBLIC \"-//Apache Software Foundation//DTD Struts Configuration 2.3//EN\" \"http://struts.apache.org/dtds/struts-2.3.dtd\"&gt;&lt;struts&gt; &lt;!-- 设置文件上传的临时目录 --&gt; &lt;constant name=\"struts.multipart.saveDir\" value=\"d:/\"&gt;&lt;/constant&gt; &lt;!-- 常量设置 --&gt;&lt;!-- 设置上传文件总大小 --&gt; &lt;constant name=\"struts.multipart.maxSize\" value=\"67388135\"&gt;&lt;/constant&gt; &lt;package name=\"default\" namespace=\"/\" extends=\"struts-default\"&gt; &lt;action name=\"upload\" class=\"com.zhuchuli.action.UploadAction\" method=\"upload\"&gt; &lt;result&gt;/success.jsp&lt;/result&gt; &lt;result name=\"error\"&gt;/error.jsp&lt;/result&gt; &lt;interceptor-ref name=\"fileupload\"&gt; &lt;!-- 设置上传单个文件的大小 --&gt; &lt;param name=\"maximumSize\"&gt;67388135&lt;/param&gt; &lt;/interceptor-ref&gt; &lt;interceptor-ref name=\"basicStack\"&gt;&lt;/interceptor-ref&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; 第二十二讲 批量文件上传 批量文件下载 Jsp页面 123456789101112131415&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;文件上传&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=\"batch.action\" method=\"post\" enctype=\"multipart/form-data\"&gt; 文件1:&lt;input type=\"file\" name=\"file\"/&gt;&lt;br&gt;文件2:&lt;input type=\"file\" name=\"file\"/&gt;&lt;br&gt;&lt;input type=\"submit\" value=\"上传\"&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;&gt;&gt;* 批量下载业务处理方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package com.zhuchuli.action;import java.io.File;import java.io.IOException;import org.apache.commons.io.FileUtils;import org.apache.struts2.ServletActionContext;import com.opensymphony.xwork2.Action;import com.opensymphony.xwork2.ActionSupport;/*** * 文件上传处理类 * @author 1huangzewei * */public class BatchUploadAction extends ActionSupport&#123; /** * */ private static final long serialVersionUID = 1L; //File属性名与表单域相同 类型为File private File file[]; //上传文件的名称，也是由struts2设置好 //属性名=表单域名+FileName private String fileFileName[]; //文件类型 = 表单域名+ContentType private String fileContentType[]; //上传文件的业务方法 public String upload() &#123; //System.out.println(file+\";\"+fileFileName); //获取上传文件目录 String path=ServletActionContext.getServletContext().getRealPath(\"/upload\"); try &#123; for(var i=0;i&lt;file.length;i++) &#123; FileUtils.copyFile(file[i], new File(path,fileFileName[i])); &#125; return Action.SUCCESS; &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; return Action.ERROR; &#125; public File[] getFile() &#123; return file; &#125; public void setFile(File[] file) &#123; this.file = file; &#125; public String[] getFileFileName() &#123; return fileFileName; &#125; public void setFileFileName(String[] fileFileName) &#123; this.fileFileName = fileFileName; &#125; public String[] getFileContentType() &#123; return fileContentType; &#125; public void setFileContentType(String[] fileContentType) &#123; this.fileContentType = fileContentType; &#125; &#125; struts.xml配置文件 12345678&lt;action name=\"batch\" class=\"com.zhuchuli.action.BatchUploadAction\" method=\"upload\"&gt; &lt;result&gt;/success.jsp&lt;/result&gt; &lt;result name=\"error\"&gt;/error.jsp&lt;/result&gt; &lt;interceptor-ref name=\"fileUpload\"&gt; &lt;param name=\"maximumSize\"&gt;67388135&lt;/param&gt; &lt;/interceptor-ref&gt; &lt;interceptor-ref name=\"basicStack\"&gt;&lt;/interceptor-ref&gt;&lt;/action&gt; 第二十三讲 文件下载 文件下载可以通过超链接直接实现，但是通过超链接直接下载的文件不安全。任何用户得到超链接都可以下载，没法权限的控制。浏览器如果能打开文件，那么浏览会直接将文件打开。 通过流的方式来实现文件下载 业务处理方法 1234567891011121314151617181920212223242526272829303132333435363738394041package com.zhuchuli.action;import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.InputStream;import org.apache.struts2.ServletActionContext;import com.opensymphony.xwork2.Action;/*** * 实现文件下载 * @author 1huangzewei *高等数学 水以v立方厘米/秒的输的灌入圆锥形水箱.水箱尖点朝下 */public class DownloadAction &#123; private String fileName; public String execute() &#123; System.out.println(\"Download\"); return Action.SUCCESS; &#125; public InputStream getInputStream() &#123; String path=ServletActionContext.getServletContext().getRealPath(\"/download\"); try &#123; return new FileInputStream(new File(path,fileName)); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); return null; &#125; &#125; public String getFileName() &#123; return fileName; &#125; public void setFileName(String fileName) &#123; this.fileName = fileName; &#125; &#125; 配置文件 12345&lt;action name=\"download\" class=\"com.zhuchuli.action.DownloadAction\"&gt; &lt;result type=\"stream\"&gt; &lt;param name=\"contentDisposition\"&gt;attachment;filename=$&#123;fileName&#125;&lt;/param&gt; &lt;/result&gt;&lt;/action&gt; jsp页面 123456789101112&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Struts2文件下载&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;a href=\"download.action?fileName=jiaoben5614.rar\"&gt;文件下载&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 第二十四讲 ajax 在Struts2中依然可以使用Servlet中的ajax 12345678910111213141516171819202122232425262728293031package com.zhuchuli.ajax;import java.io.IOException;import javax.servlet.http.HttpServletResponse;import org.apache.struts2.ServletActionContext;public class AjaxAction &#123; private String username; //ajax public String checkName() throws IOException &#123; HttpServletResponse resp=ServletActionContext.getResponse(); System.out.println(\"checkName ---&gt;\" + username); if(\"possible\".equals(username)) &#123; resp.getWriter().print(\"true\"); &#125;else &#123; resp.getWriter().print(\"false\"); &#125; return \"none\"; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; &#125; Struts2对ajax也提供了异步支持，使用步骤 导入相关jar包 编写jsp页面 12345678910111213141516171819202122232425262728293031323334353637383940&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;ajax&lt;/title&gt; &lt;script type=\"text/javascript\" src=\"js/jquery-3.2.1.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; $(function()&#123; $(\"#btn\").click(function()&#123; $.post(\"list.action\",function(data)&#123; console.log(data); var html=\"\"; for(var i=0;i&lt;data.length;i++)&#123; html+=\"&lt;tr&gt;&lt;td&gt;\"+data[i].id+\"&lt;/td&gt;&lt;td&gt;\"+data[i].name+\"&lt;/td&gt;&lt;td&gt;\"+data[i].age+\"&lt;/td&gt;&lt;/tr&gt;\"; &#125; $(\"#content\").html(html); &#125;,'json') &#125;) &#125;) &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;button id=\"btn\"&gt;获取数据&lt;/button&gt; &lt;table width=\"80%\" align=\"center\"&gt; &lt;thead&gt; &lt;tr&gt; &lt;td&gt;编号&lt;/td&gt; &lt;td&gt;姓名&lt;/td&gt; &lt;td&gt;年龄&lt;/td&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody id=\"content\"&gt; &lt;/tbody&gt; &lt;tfoot&gt;&lt;/tfoot&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 编写业务处理方法 123456789101112131415161718192021222324252627282930package com.zhuchuli.ajax;import java.util.ArrayList;import java.util.List;import com.opensymphony.xwork2.Action;import com.zhuchuli.vo.User;public class JsonAction &#123; private List&lt;User&gt; list; //获取数据 public String list() &#123; list=new ArrayList&lt;User&gt;(); list.add(new User(1,\"张三\",19)); list.add(new User(2,\"李四\",20)); list.add(new User(3,\"possible\",16)); for(User u:list) &#123; System.out.println(u.getId()+\"--&gt;\"+u.getName()+\"--&gt;\"+u.getAge()); &#125; return Action.SUCCESS; &#125; public List&lt;User&gt; getList() &#123; return list; &#125; public void setList(List&lt;User&gt; list) &#123; this.list = list; &#125; &#125; 配置文件 12345678910111213&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE struts PUBLIC \"-//Apache Software Foundation//DTD Struts Configuration 2.3//EN\" \"http://struts.apache.org/dtds/struts-2.3.dtd\"&gt;&lt;struts&gt; &lt;package name=\"default\" namespace=\"/\" extends=\"json-default\"&gt; &lt;action name=\"checkName\" class=\"com.zhuchuli.ajax.AjaxAction\" method=\"checkName\"&gt;&lt;/action&gt; &lt;action name=\"hello\" class=\"com.zhuchuli.ajax.HelloAction\"&gt;&lt;/action&gt; &lt;action name=\"list\" class=\"com.zhuchuli.ajax.JsonAction\" method=\"list\"&gt; &lt;result type=\"json\"&gt; &lt;param name=\"root\"&gt;list&lt;/param&gt; &lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; 第二十五讲 异常处理 异常处理在实际的应用开发中必不可少。比如：开发中不能直接将错误信息展示给用户看，需要对其进行处理，给用户一个更友好的提示。 异常处理类 123456789101112131415package com.zhuchuli.action;import com.opensymphony.xwork2.Action;import com.zhuchuli.exception.UserException;import com.zhuchuli.service.UserServiceImpl;import com.zhuchuli.service.Userserivce;public class UserAction &#123; private Userserivce userService=new UserServiceImpl(); //try-catch 需要通过异步进行处理ss public String delete() throws UserException &#123; userService.delete(0); return Action.SUCCESS; &#125;&#125; 配置文件 12345&lt;action name=\"delete\" class=\"com.zhuchuli.action.UserAction\" method=\"delete\"&gt; &lt;result&gt;/success.jsp&lt;/result&gt; &lt;result name=\"userexp\"&gt;/exp.jsp&lt;/result&gt; &lt;exception-mapping result=\"userexp\" exception=\"com.zhuchuli.exception.UserException\"&gt;&lt;/exception-mapping&gt; &lt;/action&gt; 第二十六讲 Struts最新版","categories":[{"name":"back-end","slug":"back-end","permalink":"https://CPWS.github.io/categories/back-end/"}],"tags":[{"name":"Struts2","slug":"Struts2","permalink":"https://CPWS.github.io/tags/Struts2/"}]},{"title":"Log4j与Junit测试","slug":"Log4j与Junit测试","date":"2019-09-09T08:28:00.000Z","updated":"2019-12-05T09:00:22.308Z","comments":true,"path":"2019/09/09/Log4j与Junit测试/","link":"","permalink":"https://CPWS.github.io/2019/09/09/Log4j与Junit测试/","excerpt":"","text":"Log4j的作用和级别 什么是日志 日志是系统运行过程中的后台输出信息，方便程序员进行系统运行的管控以及Bug查找 什么是Log4j Log4j是一个日志输出插件，专门用来进行日志的管理的。 传统方式获取日志 使用System.out.println(); 问题： 日志信息无法保存。 无法显示完整日志信息。 日志的显示没有级别所有日志混杂在一起显示（无法进行日志信息筛选）。 日志显示格式不友好。 解决：使用Log4j 使用Log4j进行日志管理特点: 日志可以单独保存在文件。 可以获取完整的日志信息。 可以进行日志显示的筛选。 格式友好。 Log4j的使用流程 导入log4j的jar包 配置Log4j的配置文件 log4j的日志级别 FATAL 致命的错误 Error 错误级 WARM 警告级 INFO 信息级 DEBUG 调试级 日志记录器（Logger）org.apache.log4j.Logger类实例的作用是用来取代System.ou或者System.err的日志写出器，主要用来输出日志信息。 可以通过如下几个方式来获取Logger类的实例 根据指定名称来获取一个日志记录器的实例：Logger logger=Logger.getLogger(String name); 根据指定的类信息中的类名来获取一个日志记录器的实例：Logger logger=Logger.getLogger(Class clazz); 获取(Logger)日志实例之后，就可以使用它提供的以下方法来记录日志了： public void debug(Object msg) public void debug(Object msg,Throwable t) public void info(Object msg) public void info(Object msg,Throwable t) public void warn(Object msg) public void warn(Object msg,Throwable t) public void error(Object msg) public void error(Object msg,Throwable t) log4j的日志级别 FATAL 致命的错误 对应的level为0 使用方法logger.fatal() Error 错误级 对应的level为3 使用方法logger.error() WARM 警告级 对应的level为4 使用方法logger.warn() INFO 信息级 对应的level为6 使用方法logger.info() DEBUG 调试级 对应的level为7 使用方法logger.debug() 日志级别的设置是通过在Log4j的配置文件中指定的。 日志输出目的地（Appender）Appender的功能是把格式好的日志信息输出到指定的目的地。 日志目的地通过Log4j配置文件来指定的。 对于不同的日志目的地，Log4j提供不同的Appender实现类，常用的Appender实现类包括： 用于控制台的org.apache.log4j.ConsoleAppender。 用于文件的org.apache.log4j.FileAppender。 org.apache.log4j.RollingFileAppender–文件到达指定大小时产生一个新的文件。 org.apache.log4j.DailyRollingFileAppender – 每天产生一个日志文件。 用于以流格式发送到任意位置的org.apache.log4j.WriterAppender。 用于添加到数据库的org.apache.log4j.jdbc.JDBCAppender。 用于邮件发送的org.apache.log4j.net.SMTPAppender。 通过在配置文件中指定不同的Appender实现类，就可以让日志内容输出到相应的目的地。 日志格式化器（Layout）Layout用来把日志信息按指定的格式格式化字符串。而具体的格式是通过log4j的配置文件来配置的。 Log4j中提供用来格式化输出结果的各种布局实现类，包括： org.apache.log4j.SimpleLayout：简单输出。此布局的输出中仅包含日志消息的层次，紧跟着“-”，然后是日志消息字符串。 org.apache.log4j.PatternLayout：模式布局。可以根据指定的模式字符串来决定消息的输出格式。它是一种最常用的一种格式化字符串。 org.apache.log4j.TTCCLayout：日志的格式包含产生的日期，线程，类别等信息。 org.apache.log4j.HTMLLayout：以HTML表格形式布局。 org.apache.xml.XMLLayout：以XML形式布局。 Log4j的使用 Log4j的配置文件：“XMl格式的文件”，“Java属性文件:log4j.properties(键=值)” Log4j.properties log4j.xml 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE log4j:configuration SYSTEM \"log4j.dtd\"&gt;&lt;!--日志级别以及优先级排序: OFF &gt; FATAL &gt; ERROR &gt; WARN &gt; INFO &gt; DEBUG &gt; TRACE &gt; ALL --&gt;&lt;!--Configuration后面的status，这个用于设置log4j2自身内部的信息输出，可以不设置，当设置成trace时，你会看到log4j2内部各种详细输出--&gt;&lt;!--monitorInterval：Log4j能够自动检测修改配置 文件和重新配置本身，设置间隔秒数--&gt;&lt;configuration status=\"WARN\" monitorInterval=\"30\"&gt; &lt;!--先定义所有的appender--&gt; &lt;!--设置日志目的地类型和日志格式化器--&gt; &lt;appenders&gt; &lt;!--这个输出控制台的配置--&gt; &lt;console name=\"Console\" target=\"SYSTEM_OUT\"&gt; &lt;!--输出日志的格式--&gt; &lt;PatternLayout pattern=\"[%d&#123;HH:mm:ss:SSS&#125;] [%p] - %l - %m%n\"/&gt; &lt;/console&gt; &lt;!--文件会打印出所有信息，这个log每次运行程序会自动清空，由append属性决定，这个也挺有用的，适合临时测试用--&gt; &lt;File name=\"log\" fileName=\"log/test.log\" append=\"false\"&gt; &lt;PatternLayout pattern=\"%d&#123;HH:mm:ss.SSS&#125; %-5level %class&#123;36&#125; %L %M - %msg%xEx%n\"/&gt; &lt;/File&gt; &lt;!-- 这个会打印出所有的info及以下级别的信息，每次大小超过size，则这size大小的日志会自动存入按年份-月份建立的文件夹下面并进行压缩，作为存档--&gt; &lt;RollingFile name=\"RollingFileInfo\" fileName=\"$&#123;sys:user.home&#125;/logs/info.log\" filePattern=\"$&#123;sys:user.home&#125;/logs/$$&#123;date:yyyy-MM&#125;/info-%d&#123;yyyy-MM-dd&#125;-%i.log\"&gt; &lt;!--控制台只输出level及以上级别的信息（onMatch），其他的直接拒绝（onMismatch）--&gt; &lt;ThresholdFilter level=\"info\" onMatch=\"ACCEPT\" onMismatch=\"DENY\"/&gt; &lt;PatternLayout pattern=\"[%d&#123;HH:mm:ss:SSS&#125;] [%p] - %l - %m%n\"/&gt; &lt;Policies&gt; &lt;TimeBasedTriggeringPolicy/&gt; &lt;SizeBasedTriggeringPolicy size=\"100 MB\"/&gt; &lt;/Policies&gt; &lt;/RollingFile&gt; &lt;RollingFile name=\"RollingFileWarn\" fileName=\"$&#123;sys:user.home&#125;/logs/warn.log\" filePattern=\"$&#123;sys:user.home&#125;/logs/$$&#123;date:yyyy-MM&#125;/warn-%d&#123;yyyy-MM-dd&#125;-%i.log\"&gt; &lt;ThresholdFilter level=\"warn\" onMatch=\"ACCEPT\" onMismatch=\"DENY\"/&gt; &lt;PatternLayout pattern=\"[%d&#123;HH:mm:ss:SSS&#125;] [%p] - %l - %m%n\"/&gt; &lt;Policies&gt; &lt;TimeBasedTriggeringPolicy/&gt; &lt;SizeBasedTriggeringPolicy size=\"100 MB\"/&gt; &lt;/Policies&gt; &lt;!-- DefaultRolloverStrategy属性如不设置，则默认为最多同一文件夹下7个文件，这里设置了20 --&gt; &lt;DefaultRolloverStrategy max=\"20\"/&gt; &lt;/RollingFile&gt; &lt;RollingFile name=\"RollingFileError\" fileName=\"$&#123;sys:user.home&#125;/logs/error.log\" filePattern=\"$&#123;sys:user.home&#125;/logs/$$&#123;date:yyyy-MM&#125;/error-%d&#123;yyyy-MM-dd&#125;-%i.log\"&gt; &lt;ThresholdFilter level=\"error\" onMatch=\"ACCEPT\" onMismatch=\"DENY\"/&gt; &lt;PatternLayout pattern=\"[%d&#123;HH:mm:ss:SSS&#125;] [%p] - %l - %m%n\"/&gt; &lt;Policies&gt; &lt;TimeBasedTriggeringPolicy/&gt; &lt;SizeBasedTriggeringPolicy size=\"100 MB\"/&gt; &lt;/Policies&gt; &lt;/RollingFile&gt; &lt;/appenders&gt; &lt;!--设置根记录器--&gt; &lt;root&gt; &lt;!--设置级别--&gt; &lt;level value=\"DEBUG\" /&gt; &lt;!--设置目的地--&gt; &lt;appender-ref ref=\"STDOUT\"/&gt; &lt;appender-ref ref=\"File\"&gt; &lt;/root&gt; &lt;!--然后定义logger，只有定义了logger并引入的appender，appender才会生效--&gt; &lt;loggers&gt; &lt;!--过滤掉spring和mybatis的一些无用的DEBUG信息--&gt; &lt;logger name=\"org.springframework\" level=\"INFO\"&gt;&lt;/logger&gt; &lt;logger name=\"org.mybatis\" level=\"INFO\"&gt;&lt;/logger&gt; &lt;root level=\"all\"&gt; &lt;appender-ref ref=\"Console\"/&gt; &lt;appender-ref ref=\"RollingFileInfo\"/&gt; &lt;appender-ref ref=\"RollingFileWarn\"/&gt; &lt;appender-ref ref=\"RollingFileError\"/&gt; &lt;/root&gt; &lt;/loggers&gt; &lt;/configuration&gt; Log4j在默认的情况下，会首先查找使用log4j.xml的配置，然后再去查找log4j.properties。 log4j的配置文件必须放置于项目的类路径（ClassPath）下。 在Java中使用Log4j打印日志信息的步骤如下： 得到记录器。 public static Logger logger=Logger.getLogger(String name); static Logger logger=Logger.getLogger(Test.class.getName()); 读取配置文件。 BasicConfigurator.configure(); //自动快速的使用默认的log4j环境 PropertyConfigurator.configure(String configFileName);//读取使用Java的特性文件编写的配置文件。 插入记录信息。 Logger.debug(Object message);Junit单元测试Junit-概述Junit-环境设置Junit-基本用法Junit-APIJunit-编写测试Junit-使用断言Junit-执行过程Junit-执行测试Junit-囊括测试Junit-忽略测试","categories":[{"name":"back-end","slug":"back-end","permalink":"https://CPWS.github.io/categories/back-end/"}],"tags":[{"name":"Log4j与Junit测试","slug":"Log4j与Junit测试","permalink":"https://CPWS.github.io/tags/Log4j与Junit测试/"}]},{"title":"正则表达式","slug":"正则表达式","date":"2019-09-08T01:36:32.000Z","updated":"2019-12-05T08:57:59.005Z","comments":true,"path":"2019/09/08/正则表达式/","link":"","permalink":"https://CPWS.github.io/2019/09/08/正则表达式/","excerpt":"","text":"正则表达式基本知识 基本语法 高级语法 练习 editplus,notpad++,ultraedit,eclipse中使用正则表达式 正则表达式（Regular Expression）简介 为什么需要使用正则表达式？ 文本的复杂处理。 正则表达式的优势和用途 一种强大而灵活的文本处理工具。 大部分编程语言、数据库、文本编辑器、开发环境都支持正则表达式。 正则表达式定义 正如他的名字一样是描述一种规则，通过这个规则可以匹配一类字符串。 学习正则表达式很大程度上就是学习正则表达式的语法规则。 开发中使用正则表示的流程 分析所要匹配的数据，写出测试用的典型数据。 在工具软件中进行匹配测试。 在程序中调用通过测试的正则表达式。 正则表达式基本语法 普通字符 字母、数字、汉字、下划线、以及没有特殊定义的标点符号，都是“普通字符”。表达式中的普通字符，在匹配一个字符串的时候，匹配与之相同的一个字符。 简单转义字符 \\n 代表换行符 \\t 制表符 \\ 代表\\本身 ^,$,.,{,},?,+,*,|,[,] 匹配这些字符创本身 标准字符集合： 能够与“多种字符”匹配的表达式 主义区分大小写，大写是相反的意思。 \\d 任意一个数字，0-9中的任意一个。 \\w 任意一个字母或数字或下划线，也就是A-Z,a-z,0-9,_中任意一个。 \\s 包括空格、制表符、换行符等空白字符的其中任意一个。 . 小数点可以匹配任意一个字符（除了换行符）如果要匹配在”\\n”在内的所有字符，一般用[\\s\\S]。 [\\s\\S] 匹配包含“\\n”在内所有字符串 自定义字符集合 []方括号匹配方式，能够匹配方括号中任意一个字符. [ab5@]：匹配”a”或”b”或”5”或”@” [^abc]：匹配”a”，”b”，”c”之外的任意一个字符 [f-k]：匹配日”f”-“k”之间的任意一个字符 [^A-f0-3]：匹配”A”-“F”，”0”-“3’之外的任意一个字符 正则表达式的特殊符号，被包含到中括号中，则失去特殊意义，除了^,-之外。 标准字符集合，处理小数点之外，如果被包含于中括号，自定义字符集合将包含该集合。 [\\d.-+]讲匹配数组，小数点 + - 量词（Quantifier） 修饰匹配次数的特殊符号 {n} 表达重复n次 {m，n} 表达至少重复m次，最多重复n次 {m,} 表达至少重复m次 ? 匹配表达式0次或1次，相当于{0,1} + 表达式至少出现1线，相当{1,} * 表达式不会出现或出现任意次，{0，} 匹配次数中的贪婪模式（匹配字符越多越好，默认！）。 匹配次数中的非贪婪模式（匹配字符越少越好，修饰匹配次数的特殊符号后再加上一个”?”号）。 字符边界 （本组编辑匹配的不是字符而是位置，符合某种条件的位置）() ^ 与字符串开始的位置匹配 $ 与字符串结束的地方配置 \\b 匹配一个当前的边界 \\b匹配这样一个位置，前面的字符和后面的字符不全是\\w 选择符和分组 表达式 作用 ` `分支结构 ()捕获组 (1)在被修饰匹配次数的时候，括号中的表达式可以作为整体被修饰(2)取得匹配结果的时候，括号中的表达式匹配到的内容可以被单独得到(3)每个括号会分配一个编号，使用（）的捕获根据左括号的顺序从1开始自动编号。捕获元素编号为0的第一个捕获是由整个正则表达式模式匹配的文本 非捕获组（?:Exception）（?:([a-z]{2})） 一些表达式中，不得不使用()，但又不需要保存()中子表达式匹配的内容，这时候可以使用非捕获组来抵消使用()带来的副作用。 反向引用（\\nnn）： 每一个()都会分配一个编号，使用（）的捕获根据左括号的顺序从1开始自动编导。 通过反向作用，可以对分组已捕获的字符串进行引用。 正则表达式的匹配模式 INGORECASE 忽略大小写模式 匹配时忽略大小写。 默认情况下，正则表达式是要区分大小写的。 SIGNLELINE 单行模式 整个文本看做是一个字符串，只有一个开头，一个结尾。 使小数点“.”可以匹配包含“\\n”在内的任意字符。 MULTILINE 多行模式 每行都是一个字符串，都有开头和结尾。 在指定了MULTILINE之后，如果需要仅匹配字符串开始和结束位置，可以使用\\A和\\Z 预搜索（零宽断言）（环视） 占有字符还是零宽度，是针对匹配的内容是否保存到最终的匹配结果中而言的。 零宽断言的几种方式 (?=exp)：断言自身出现的位置的后面能匹配表达式exp。 (?&lt;=exp&gt;):断言自身出现的位置的前面能匹配表达式exp。 (?!exp):断言此位置的后面不能匹配exp。 (?&lt;!exp&gt;):断言此位置的前面不能匹配表达式exp。 正则表达式的应用 电话号码的应用 电话号码有数字和”-“构成。 电话号码为7到8位。 如果电话号码中包含有取号，那么区号为三位或四位，首位为0。 区号用”-“和其它部分隔开。 移动电话号码为11位 11位一定电话号码的第一位和第二位为”13“、”15“、”18“ 结果：(0\\d{2,3}-\\d{7,9})|(1[35789]\\d{9}) 电子邮件的地址验证 用户名：字母，数字，下划线，中划线组成 @ 网址：字母、数字组成 小数点 . 组织域名：2-4字母组成 不区分大小写 结果 [\\w-]+@[a-z0-9A-Z]+(.[A-Za-z]{2,3}){1,2} Java程序中使用正则表达式 相关类位于：java.util.regex包下面 类pattern： 正则表达式的编译表示形式。 Pattern p=Pattern.compile(r,int);//建立正则表达式，并启动响应模式 类matcher： 通过解释Pattern对character sequence执行匹配操作的引擎。 Matcher m=p.matcher(str);//匹配str字符串 Java模拟编程的原理123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package regular;import java.io.BufferedReader;import java.io.InputStreamReader;import java.net.URL;import java.util.ArrayList;import java.util.List;import java.util.regex.Matcher;import java.util.regex.Pattern;/*** * 网络爬虫取连接 * @author 1huangzewei * */public class webSpiderTest &#123; //获得urlStr网页的源代码 public static String getURLContent(String urlStr) &#123; StringBuilder sb=new StringBuilder(); try &#123; URL url=new URL(urlStr); BufferedReader reader=new BufferedReader(new InputStreamReader(url.openStream())); String temp=\"\"; while((temp=reader.readLine())!=null) &#123; sb.append(temp); &#125; &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; return sb.toString(); &#125; public static List&lt;String&gt; getMatcher(String destStr,String regex) &#123; List&lt;String&gt; result=new ArrayList&lt;String&gt;(); //Pattern p=Pattern.compile(\"&lt;a[\\\\s\\\\S]+?&lt;/a&gt;\");//找到超链接 Pattern p = Pattern.compile(regex);//找到a href; Matcher m = p.matcher(destStr); while (m.find()) &#123; result.add(m.group(1)); &#125; return result; &#125; public static void main(String[] args) &#123; String destStr=getURLContent(\"http://163.com\"); //List&lt;String&gt; list=getMatcher(destStr,\"href=\\\"([\\\\s\\\\S]+?)\\\"\"); //List&lt;String&gt; list=getMatcher(destStr,\"(&lt;img+[\\\\S\\\\s]+?)&gt;\"); List&lt;String&gt; list=getMatcher(destStr,\"data-original=\\\"([\\\\s\\\\S]+?)\\\"\"); for(String temp:list) &#123; System.out.println(temp); &#125; &#125;&#125;","categories":[{"name":"back-end","slug":"back-end","permalink":"https://CPWS.github.io/categories/back-end/"}],"tags":[{"name":"正则表达式","slug":"正则表达式","permalink":"https://CPWS.github.io/tags/正则表达式/"}]},{"title":"注解与反射","slug":"注解与反射","date":"2019-09-02T08:08:40.000Z","updated":"2019-12-05T08:58:13.729Z","comments":true,"path":"2019/09/02/注解与反射/","link":"","permalink":"https://CPWS.github.io/2019/09/02/注解与反射/","excerpt":"","text":"注解入门 Annotation是JDK5.0开始引入的新技术 Annotation的作用 不是程序本身，可以对程序作出解释。 可以被其他程序（比如：编译器等）读取。（注解信息处理流程，是注解和注释的重大区别。如果没有注解信息处理流程，则注解毫无意义）。 Annotation格式 注解是以“@注释名”在代码中存在的，可以添加一些参数值，例如：@SeppressWarnings(value=”unchecked”)。 Annotation在哪里使用？ 可以附加在package，class，method，field等上面，相当于它它们添加了额外的辅助信息，我们可以通过反射机制编程实现对这些数据的访问。 内置注解 @Override：定义在java.lang.Override中，此注释只适用修饰方法，表示一个方法声明打算重写超类中的另一个方法声明。 @Deprecated：定义在java.lang.Deprecated中，此注释可以用于修饰方法、属性、类，表示不鼓励程序员使用这样的元素，通常是因为它很危险吗或存在更好的选择。（一般不建议使用） @SuppressWarnings：用来抑制编译器运行时的警告信息。 @SuppressWarnings(&quot;unchecked&quot;)告诉编译器忽略 unchecked 警告信息，如使用List，ArrayList等未进行参数化产生的警告信息。 @SuppressWarnings(&quot;serial&quot;)如果编译器出现这样的警告信息：The serializable class WmailCalendar does not declare a static final serialVersionUID field of type long 使用这个注释将警告信息去掉。 @SuppressWarnings(&quot;deprecation&quot;)如果使用了使用@Deprecated注释的方法，编译器将出现警告信息。 使用这个注释将警告信息去掉。 @SuppressWarnings(&quot;unchecked&quot;, &quot;deprecation&quot;)告诉编译器同时忽略unchecked和deprecation的警告信息。 @SuppressWarnings(value={&quot;unchecked&quot;, &quot;deprecation&quot;})等同于@SuppressWarnings(“unchecked”, “deprecation”) 自定义注解、元注解元注解 @Target 作用：用于描述注解的使用范围 |所修饰的范围|取值ElemnetType||-|-|-||package包|PACKAGE||类、接口、枚举、Annotation类型|TYPE||类型成员（方法、构造器、成员变量、枚举值）|CONSTRUCTOR：用于描述构造器。FIELD：用于描述域METHOD：用于描述方法||方法参数和本地变量|LOCAL_VALUE：用于描述局部变量PARANETER：用于描述参数| @Target(value=ElementType.Type) @Retention 作用：表示需要在什么级别保存该注解，用于描述注解的生命周期。 取值 RetentionPolicy 作用 SOURCE 在源文件中有效（即源文件保存） CLASS 在class文件中有效（即class保留） RUNTIME 在运行时有效（即运行时保留）为Runtime可以被反射机制读取 注意： 注解元素的参数的默认值一般设置为0或空字符窜； 也可能是-1，表示什么也没有 @Documented 作用：用于描述其它类型的annotation应该被作为被标注的程序成员的公共API，因此可以被例如javadoc此类的工具文档化。它是一个标记注解，没有成员。 @Inherited 作用：用于表示某个被标注的类型是被继承的。如果一个使用了@Inherited修饰的annotation类型被用于一个class，则这个annotation将被用于该class的子类 反射机制读取注解 什么是ORM（Object Relationship Mapping） 类和表结构对应 属性和字段对应 对象和记录对应 使用注解完成类和表结构的映射关系 学了反射机制后，我们可以定义注解的执行流程读取这些注解，实现更复杂的功能 123456789101112package annotation;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target; @Target(value = ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)public @interface Table &#123; String value();&#125; 1234567891011121314package annotation;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Target(value = ElementType.FIELD)@Retention(RetentionPolicy.RUNTIME)public @interface Field &#123; String columnName(); String type(); int length();&#125; 123456789101112131415161718192021222324252627282930package annotation;@Table(\"tb_student\")public class Student &#123; @Field(columnName=\"id\",type=\"int\",length=3) private int id; @Field(columnName=\"sname\",type=\"varchar\",length=10) private String studentName; @Field(columnName=\"age\",type=\"int\",length=10) private int age; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getStudentName() &#123; return studentName; &#125; public void setStudentName(String studentName) &#123; this.studentName = studentName; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; &#125; 1234567891011121314151617181920212223242526272829303132package annotation;import java.lang.annotation.Annotation;/** * 使用反射处理注解信息，模拟处理注解信息的流程 * @author 1huangzewei * */public class Demo3 &#123; public static void main(String[] args) &#123; try &#123; Class clazz=Class.forName(\"annotation.Student\"); //获取类所有有效的注解 Annotation[] annotations=clazz.getAnnotations(); for(Annotation a:annotations) &#123; System.out.println(a); &#125; //获取指定的注解 Table table=(Table) clazz.getAnnotation(Table.class); System.out.println(table.value()); //获取类的属性的注解 Field f=clazz.getDeclaredField(\"studentName\").getAnnotation(Field.class); System.out.println(f.columnName() + \"---&gt;\" + f.type() + \"---&gt;\" + f.length()); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125; Java的动态性 动态语言：程序运行时，可以改变程序结果或变量类。 Java可以称为准动态语言。 反射机制 reflection 指的是可以于运行时加载、探知、使用编译期间完全未知的类。 程序在运行状态中，可以动态加载一个只有名称的类，对于任意一个已加载的类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性。 1Class c=Class.forName(\"包名.类名\"); 加载完类之后，在堆内存中，就产生了一个Class类型的对象（一个类只有一个Class对象），这个对象就包含了完整的类的结构信息。我们可以通过这个对象看到类的结构。这个对象就像一面镜子，通过这个镜子可以看到类的结构，所以我们形象的称之为：反射。 Class类的对象如何获取 运用getClass() 运用Class.forName()（最常被使用） 运用类.class 123456789101112131415161718192021222324252627282930313233343536package com.zhuchuli.reflection;import com.zhuchuli.testBean.User;/*** * 测试java.lang.Class对象的获取方式。 * 测试各种数据类型java.lang.Class对象的获取方式。 * 1.利用类.class * 2.利用类.getClass() * 3.利用Class.forName() * @author 1huangzewei * */@SuppressWarnings(\"all\")public class Demo01 &#123; public static void main(String[] args) &#123; String path= \"com.zhuchuli.testBean.User\"; try &#123; Class clazz = Class.forName(path); //对象是表示或封装一些数据。一个类被加载之后，Jvm会创建一个对应该类的Class对象，类的整个结构信息会放到对象的Class对象中。 //这个Class对象就像一面镜子一样，通过这个镜子，我们可以看到类的全部信息。 System.out.println(clazz.hashCode()); //获取Class对象的三种方式 Class strClazz=String.class; Class strClazz2=path.getClass(); System.out.println(strClazz==strClazz2); //基本数据类型 Class intClaszz=int.class; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 反射机制的常见作用 动态加载类、动态获取类的信息（属性、方法、构造器） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package com.zhuchuli.reflection;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.Method;/*** * 应用反射API，获取类的信息（类的名字、属性、方法、构造器等） * @author 1huangzewei * */public class Demo02 &#123; public static void main(String[] args) &#123; String path= \"com.zhuchuli.testBean.User\"; try &#123; Class clazz = Class.forName(path); //获取类的名字 System.out.println(\"---------------------------------通过反射获取类名---------------------------------\"); System.out.println(clazz.getName());//获得包名+类名 com.zhuchuli.testBean.User System.out.println(clazz.getSimpleName());//获得类名 User System.out.println(\"------------------------------------------------------------------------------\"); //获取属性信息 System.out.println(\"---------------------------------通过反射获取属性---------------------------------\"); //Field[] fields=clazz.getFields();//只能获取public的属性 Field[] fields=clazz.getDeclaredFields();//获得所有的field Field f=clazz.getDeclaredField(\"uname\"); System.out.println(f); for(Field field:fields) &#123; System.out.println(\"属性：\"+field); &#125; System.out.println(\"------------------------------------------------------------------------------\"); //获取方法信息 System.out.println(\"---------------------------------通过反射获取方法---------------------------------\"); Method[] methods=clazz.getMethods();//只能获取public修饰的方法 Method[] methodss=clazz.getDeclaredMethods();//获取所有的方法 Method m01=clazz.getDeclaredMethod(\"getUname\", null); System.out.println(m01); Method m02=clazz.getDeclaredMethod(\"setUname\", String.class);//如果方法有参数，则必须指明参数的类型，即参数类型.class System.out.println(m02); for(Method method:methodss) &#123; System.out.println(\"方法：\"+method); &#125; System.out.println(\"------------------------------------------------------------------------------\"); //获取构造器信息 System.out.println(\"---------------------------------通过反射获取构造器---------------------------------\"); Constructor[] constructors=clazz.getConstructors();//获取public修饰的构造器 Constructor[] constructorss=clazz.getDeclaredConstructors(); for(Constructor constructor:constructorss) &#123; System.out.println(\"构造器：\"+constructor); &#125; System.out.println(\"根据参数类型获取构造器\"); Constructor c=clazz.getDeclaredConstructor(null); System.out.println(\"构造器：\"+c); Constructor cc=clazz.getConstructor(int.class,String.class,int.class); System.out.println(\"构造器：\"+cc); System.out.println(\"------------------------------------------------------------------------------\"); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 动态构造对象 动态调用类和对象的任意方法、构造器 动态调用和处理属性 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.zhuchuli.reflection;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.Method;import com.zhuchuli.testBean.User;/*** * 通过反射API动态的操作：构造器，方法和属性 * @author 1huangzewei * */public class Demo03 &#123; public static void main(String[] args) &#123; //动态操作构造器 String path= \"com.zhuchuli.testBean.User\"; try &#123; Class clazz = Class.forName(path); //通过反射API调用构造方法，构造对象 User u=(User) clazz.getConstructor().newInstance();//其实调用JavaBean的无参数构造器 System.out.println(u); Constructor&lt;User&gt; c=clazz.getConstructor(int.class,String.class,int.class); User u2=c.newInstance(1001,\"lee\",18); System.out.println(u2.getId()+\"--\"+u2.getUname()+\"--\"+u2.getAge()); //通过反射API调用普通方法 User u3=(User) clazz.getConstructor().newInstance(); Method method=clazz.getDeclaredMethod(\"setUname\", String.class); method.invoke(u3, \"lee2\");//类似于u3.setUname=\"lee2\" System.out.println(u3.getUname()); //通过反射API调用属性 User u4=(User) clazz.getConstructor().newInstance(); Field f=clazz.getDeclaredField(\"uname\"); f.setAccessible(true);//这个属性不需要做安全检查，可以直接访问。 f.set(u4, \"lee3\");//通过放射获取属性的值 System.out.println(u4.getUname()); System.out.println(f.get(u4));//通过反射读取对象的值 &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 获取泛型信息（Generic） Java使用泛型擦除机制来引入泛型。Java中的泛型仅仅是给编译器JavaC使用的，确保数据的安全性和免去强制类型转换的麻烦。但是编译一旦完成，所有和泛型有关的类全部被擦除。 为了通过反射操作这些类型以迎合实际开发的需要，Java新增了PatameterType，GenericArrayType，TypeVariable，和WildCardType几种类型来代表不能被归一到Class类中的类型但是又和原始类型齐名的类型。 ParameterizedType:表示一种参数化的类型，比如Collection&lt; String &gt;. GenericArrayType:表示一种元素类型是参数化类型或者类型变量的数组类型. TypeVariable:是各种类型变量的公共父接. WildcardType:代表一种通配符类型表达式，比如？、？ extends Number、？ super Integer。（wildcard是一个单词：就是”通配符“）. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package com.zhuchuli.reflection;import java.lang.reflect.Method;import java.lang.reflect.ParameterizedType;import java.lang.reflect.Type;import java.util.List;import java.util.Map;import com.zhuchuli.testBean.User;/*** * 通过反射获取泛型信息 * @author 1huangzewei * */public class Demo04 &#123; public void test01(Map&lt;String,User&gt; map,List&lt;User&gt; list) &#123; System.out.println(\"Demo04 test01()\"); &#125; public Map&lt;Integer,User&gt; test02()&#123; System.out.println(\"Demo01 test02()\"); return null; &#125; public static void main(String[] args) &#123; try &#123; //获取执行方法参数的泛型信息 Method method = Demo04.class.getDeclaredMethod(\"test01\", Map.class, List.class); Type[] t=method.getGenericParameterTypes(); for(Type paramType:t) &#123; System.out.println(\"#\"+paramType); if(paramType instanceof ParameterizedType) &#123; //获取泛型中的具体信息 Type[] genericTypes = ((ParameterizedType) paramType).getActualTypeArguments(); for(Type genericType:genericTypes) &#123; System.out.println(\"泛型类型：\" + genericType); &#125; &#125; &#125; //获取指定方法返回值泛型信息 Method method2=Demo04.class.getDeclaredMethod(\"test02\",null); Type returnType=method2.getGenericReturnType(); if(returnType instanceof ParameterizedType) &#123; //获取泛型中的具体信息 Type[] genericTypes = ((ParameterizedType) returnType).getActualTypeArguments(); for(Type genericType:genericTypes) &#123; System.out.println(\"泛型类型：\" + genericType); &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 处理注解：功能与案例代码与上面雷同。 反射机制的性能问题 setAccessible 启动和禁用访问安全检查的机关，值为true则指示反射的对象在使用时应该取消Java语言访问检查。值为false则指示表明反射的对象应该实施Java语言访问检查。并不是为true就能访问为false就不能访问。 禁止安全检查，可以提高反射的运行速度。 可以考虑使用：cglib/javaassist字节码操作 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.zhuchuli.reflection;import java.lang.reflect.Method;import com.zhuchuli.testBean.User;public class Demo05 &#123; public static void test01() &#123; User user=new User(); long before=System.currentTimeMillis(); for(var i=0;i&lt;1000000000L;i++) &#123; user.getUname(); &#125; long after=System.currentTimeMillis(); System.out.println(\"没有反射，共消耗：&lt;\"+(after-before)+\"&gt;毫秒\"); &#125; public static void test02() throws Exception &#123; User user=new User(); Method method=Class.forName(\"com.zhuchuli.testBean.User\").getDeclaredMethod(\"getUname\", null); long before=System.currentTimeMillis(); for(var i=0;i&lt;1000000000L;i++) &#123; method.invoke(user, null); &#125; long after=System.currentTimeMillis(); System.out.println(\"加安全检查，共消耗：&lt;\"+(after-before)+\"&gt;毫秒\"); &#125; public static void test03() throws Exception &#123; User user=new User(); Method method=Class.forName(\"com.zhuchuli.testBean.User\").getDeclaredMethod(\"getUname\", null); method.setAccessible(true); long before=System.currentTimeMillis(); for(var i=0;i&lt;1000000000L;i++) &#123; method.invoke(user, null); &#125; long after=System.currentTimeMillis(); System.out.println(\"不加安全检查，共消耗：&lt;\"+(after-before)+\"&gt;毫秒\"); &#125; public static void main(String[] args) throws Exception &#123; test01(); test02(); test03(); &#125;&#125; 动态编译 Java6.0引入了动态编译机制 动态编译的应用场景 可以做一个浏览器端编写java代码，上传服务器编译和运行的在线测评系统。 服务器动态加载某些类文件进行编译。 动态编译的两种方式 通过Runtime调用javac，启动新的进程去操作 Runtime run=Runtime.getRuntime(); Process process=run.exec(javac -cp d:/myjava/ HelloWorld.java); 通过JavaCompiler动态编译 123456789101112131415161718192021222324package com.zhuchuli.test;import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.FileReader;import java.io.FileWriter;import java.io.IOException;import javax.tools.JavaCompiler;import javax.tools.ToolProvider;public class Demo01 &#123; public static void main(String[] args) throws IOException &#123; String str=\"public class Hi&#123;public static void main(String[] args[]) &#123;System.out.println(\\\"Hello Hi haha\\\");&#125;&#125;\"; BufferedWriter br=new BufferedWriter(new FileWriter(\"d:/MyJava/Hi.java\")); br.write(str); br.flush(); //获得系统编译器，如果使用jre（运行环境）则无法获得编译器 JavaCompiler complier=ToolProvider.getSystemJavaCompiler(); int result=complier.run(null, null, null,\"d:/MyJava/Hi.java\"); System.out.println(result==0?\"编译成功\":\"编译失败\"); br.close(); &#125;&#125; 编译结果 1234567891011121314151617181920212223242526272829303132package com.zhuchuli.test;import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.FileReader;import java.io.FileWriter;import java.io.IOException;import java.io.InputStreamReader;import javax.tools.JavaCompiler;import javax.tools.ToolProvider;public class Demo02 &#123; public static void main(String[] args) throws IOException &#123; String str=\"public class Hi&#123;public static void main(String[] args) &#123;System.out.println(\\\"Hello Hi haha\\\");&#125;&#125;\"; BufferedWriter bw=new BufferedWriter(new FileWriter(\"d:/MyJava/Hi.java\")); bw.write(str); bw.flush(); //获得系统编译器，如果使用jre（运行环境）则无法获得编译器 JavaCompiler complier=ToolProvider.getSystemJavaCompiler(); int result=complier.run(null, null, null,\"d:/MyJava/Hi.java\"); System.out.println(result==0?\"编译成功\":\"编译失败\"); Runtime run=Runtime.getRuntime(); Process process=run.exec(\"java -cp d:/MyJava Hi\"); BufferedReader br=new BufferedReader(new InputStreamReader(process.getInputStream())); String info=\"\"; while((info=br.readLine())!=null) &#123; System.out.println(info); &#125; &#125;&#125; 编译结果 通过反射机制，启动新的线程去执行 12345678910111213141516171819202122232425262728293031323334353637383940414243package com.zhuchuli.test;import java.io.BufferedWriter;import java.io.FileWriter;import java.io.IOException;import java.lang.reflect.Method;import java.net.URL;import java.net.URLClassLoader;import javax.tools.JavaCompiler;import javax.tools.ToolProvider;/** * 通过反射机制调用执行类 * @author 1huangzewei * */public class Demo03 &#123; public static void main(String[] args) throws IOException &#123; String str=\"public class Hi&#123;public static void main(String[] args) &#123;System.out.println(\\\"Hello Hi haha\\\");&#125;&#125;\"; BufferedWriter bw=new BufferedWriter(new FileWriter(\"d:/MyJava/Hi.java\")); bw.write(str); bw.flush(); //获得系统编译器，如果使用jre（运行环境）则无法获得编译器 JavaCompiler complier=ToolProvider.getSystemJavaCompiler(); int result=complier.run(null, null, null,\"d:/MyJava/Hi.java\"); System.out.println(result==0?\"编译成功\":\"编译失败\"); try &#123; URL[] urls=new URL[] &#123;new URL(\"file:/\"+\"d:/MyJava/\")&#125;; URLClassLoader loader=new URLClassLoader(urls); Class c=loader.loadClass(\"Hi\"); Method m=c.getMethod(\"main\", String[].class); m.invoke(null, (Object)new String[] &#123;&#125;); //m.invoke(null,new String[] &#123;\"a\",\"b\"&#125;); //由于可变参数是Java5.0之后才有。上面的代码会被运行成;m.invoke(null,\"a\",\"b\")，就发生了参数个数不匹配，从而出现错误,因此要加上(Object)转型，避免出现出错; //public static void mmm(String[] a,String[] b) //public static void main(String[] args); &#125;catch(Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 编译结果 动态执行javascript代码 Java脚本引擎是从JDK6.0之后添加的新功能 脚本引擎介绍 使得Java应用程序可以通过一套固定的接口与各种脚本引擎交互，从而达到在Java平台上调用各种脚本语言的目的。 Java脚本API是连通Java平台和脚本语言的桥梁。 可以把一些复杂异变的业务逻辑交给与脚本语言处理，这又大大提高了开发效率。 获得脚本引擎 ScriptEngineManager sem=new ScriptEngineManager(); ScriptEngine engine=sem.getEngineByName(“javascript”); Java脚本API为开发者提供了如下功能： 获取脚本程序输入，通过脚本引擎运行脚本并返回运行结果，这是最核心的接口。 注意是：接口。Java可以使用各种不同的表现，从而通用的调用js、groovy、python等脚本 js使用了:Rhino，Rhino是一种使用Java语言编写的JavaScript的开源实现，原先是由Mozilla开发，现在被集成进入JDK6.0 通过脚本引擎的运行上下文在脚本和Java平台间交换数据。 通过Java应用程序调用脚本函数。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970package com.zhuchuli.rhino;import java.io.FileNotFoundException;import java.io.FileReader;import java.net.URL;import java.util.List;import javax.script.Invocable;import javax.script.ScriptEngine;import javax.script.ScriptEngineManager;import javax.script.ScriptException;/*** * 测试脚本引擎执行JavaScript代码 * @author 1huangzewei * */public class Demo01 &#123; public static void main(String[] args) throws ScriptException, NoSuchMethodException &#123; //获取脚本引擎对象 ScriptEngineManager sem=new ScriptEngineManager(); ScriptEngine engine=sem.getEngineByName(\"javascript\"); //定义变量，存储到引擎上下文中 engine.put(\"msg\", \"lee is a good student\"); String str=\"var user= &#123;name:'aaa',age:18,schools:['gdaib','dgef']&#125;;\"; str += \"print(user.schools);\"; //执行脚本 engine.eval(str); //修改msg的值 engine.eval(\"msg='very happy today'\"); System.out.println(engine.get(\"msg\")); System.out.println(\"--------------------\"); //定义函数 engine.eval(\"function add(a,b)&#123;var sum=a+b;return sum;&#125;\"); //执行js函数 取得调用接口 Invocable jsInvoke=(Invocable) engine; //执行脚本中定义的方法 Object i=jsInvoke.invokeFunction(\"add\", new Object[] &#123;10,20&#125;); System.out.println(i); //导入其他java包，使用其他包中的java类 String jsCode=\"var list=java.util.Arrays.asList([\\\"北京尚学堂\\\",\\\"北京大学\\\"]);\"; engine.eval(jsCode); List&lt;String&gt; list2=(List&lt;String&gt;) engine.get(\"list\"); for(String temp:list2) &#123; System.out.println(temp); &#125; //执行一个JS文件 URL url=Demo01.class.getClassLoader().getResource(\"a.js\"); try &#123; FileReader fr = new FileReader(url.getPath()); engine.eval(fr); fr.close(); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125; 运行结果 动态字字节码操作：javaassist Java动态性的两种常见实现方式： 字节码操作 反射 运行时操作字节码可以让我们实现如下功能 动态生成新的类。 动态改变某个类的结构（添加、删除、修改 新的属性、方法 ） 优势 比反射开销小，性能高。 Javaassist性能高于反射，低于ASM 常见的字节码操作类库 BCEL 基于底层Jvm的操作和指令 ASM 基于底层Jvm的操作和指令 CGLIB 基于ASM实现 Javaassist Javaassist库的API详解 javaassist的最外层的API和java的反射包中的API颇为类似。 它主要有CtClass,CtMethod，以及CtField几个类组成。用以执行和JDK反射API中java.lang.Class,java.lang.reflection.Method，java.lang.reflection.Field相同的操作。 JAVAassist库的简单使用。 创建一个全新的类 使用XJAD反编译工具，将生成的class文件反编译成Java文件\\ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.zhuchuli.javaassist;import java.io.IOException;import javassist.CannotCompileException;import javassist.ClassPool;import javassist.CtClass;import javassist.CtConstructor;import javassist.CtField;import javassist.CtMethod;import javassist.NotFoundException;/*** * 测试 使用javaassist动态生成一个新类 * @author 1huangzewei * */public class Demo01 &#123; public static void main(String[] args) throws CannotCompileException, NotFoundException, IOException &#123; //创建一个类池 ClassPool pool=ClassPool.getDefault(); CtClass cc=pool.makeClass(\"com.zhuchuli.bean.Emp\"); //创建属性 CtField f1=CtField.make(\"private String ename;\",cc); CtField f2=CtField.make(\"private int empno;\",cc); cc.addField(f1); cc.addField(f2); //创建方法 CtMethod c1=CtMethod.make(\"public String getEname()&#123;return ename;&#125; \", cc); CtMethod c2=CtMethod.make(\"public void setEname(String ename)&#123;this.ename=ename;&#125; \", cc); cc.addMethod(c1); cc.addMethod(c2); CtMethod c3=CtMethod.make(\"public int getEmpno()&#123;return empno;&#125; \", cc); CtMethod c4=CtMethod.make(\"public void setEmpno(int empno)&#123;this.empno=empno;&#125; \", cc); cc.addMethod(c3); cc.addMethod(c4); //创建构造器 CtConstructor constructor=new CtConstructor(new CtClass[] &#123;pool.get(\"java.lang.String\"), CtClass.intType&#125;, cc); constructor.setBody(\"&#123;this.ename=ename;this.empno=empno;&#125;\"); CtConstructor constructor2=new CtConstructor(null,cc); cc.addConstructor(constructor); cc.addConstructor(constructor2); cc.writeFile(\"d:/MyJava/Emp.java\");//将创建的这一类存放到指定位置上 &#125;&#125; Javaassist的AIP使用 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package com.zhuchuli.javaassist;import java.lang.reflect.Method;import java.util.Arrays;import javassist.ClassPool;import javassist.CtClass;import javassist.CtMethod;import javassist.Modifier;/*** * 测试Javaassist的API * @author 1huangzewei * */public class Demo02 &#123; //处理类的基本用法 public static void test01() &#123; ClassPool pool=ClassPool.getDefault(); try &#123; CtClass cc = pool.get(\"com.zhuchuli.javaassist.Emp\"); //将类转换成字节数组 byte[] bytes=cc.toBytecode(); System.out.println(Arrays.toString(bytes)); System.out.println(cc.getName());//获取类名 System.out.println(cc.getSuperclass());//获取父类 System.out.println(cc.getInterfaces());//获取接口 System.out.println(cc.getSimpleName ());//获得简要类名 &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; //处理方法的基本用法 产生新的方法 public static void test02() &#123; ClassPool pool=ClassPool.getDefault(); try &#123; CtClass cc = pool.get(\"com.zhuchuli.javaassist.Emp\"); //CtMethod method=CtMethod.make(\"public int add(int a,int b)&#123;System.out.println(\\\"test02\\\");return a+b;&#125;\", cc); //第一个参数为返回值类型,第二个参数为方法名 第三个参数为方法参数 第四个参数为所要加入的对象 CtMethod m=new CtMethod(CtClass.intType, \"add\", new CtClass[] &#123;CtClass.intType,CtClass.intType&#125;,cc); //设置方法的修饰符 m.setModifiers(Modifier.PUBLIC); //设置方法体 $1代表参数位置 m.setBody(\"&#123;System.out.println(\\\"test02\\\");return $1+$2;&#125;\"); cc.addMethod(m); Class&lt;?&gt; clazz=cc.toClass(); Object obj=clazz.getConstructor().newInstance(); Method method=clazz.getDeclaredMethod(\"add\", int.class,int.class); Object result=method.invoke(obj, 200,300); System.out.println(result); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; //... 还有注解 构造器 和 属性 public static void main(String[] args) &#123; test01(); &#125;&#125; JVM运行和类加载全过程 为什么要研究加载全过程？ 有助于了解JVM运行过程 更深入了解Java动态性（解耦部署，动态加载），提高程序的灵活性。 类加载全过程 （如下图所示） 加载 链接 （验证 准备 解析）:将Java类的二进制代码合并到JVM的运行状态之中的过程。 初始化：静态属性或静态方法或静态块只会被初始化一次。 使用 卸载 类的主动引用（一定会发生类初始化） new一个类的对象。 调用类的静态成员（除了final常量）和静态方法。 使用java.lang.reflect包的方法对类进行反射调用。 当虚拟机启动，java hello则一定会初始化Hello类，说白了就是先启动main方法所在的类。 当初始化一个类，如果其父类没有被初始化，则会先初始化他的父类。 类的被动引用 当访问一个静态域时，只有真正声明这个域的类才会被初始化。 通过子类引用父类的静态变量，不会导致子类初始化。 通过数组定义类引用，不会触发此类的初始化 引用常量不会触发此类的初始化（常量在编译阶段就存入调用类的常量池中了）。 深入类加载器 类加载器原理 类加载器的作用：将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区中的运行时数据结构，在堆中生成一个代表这个类的java.lang.Class对象，作为方法区类数据的访问入口。 类缓存：标准的JavaSE类加载器可以按要求查找类，但一旦某个类被加载到类加载器中，它将维持加载（缓存）一段时间。不过JVM垃圾集成器可以回收这些Class对象。 类加载器树状结构，双亲委托（代理）机制 引导类加载器（bootstrap class loader） 扩展类加载器（extensions class loader） 应用程序类加载器（application clasas loader） 自定义类加载器 双亲委托机制是为了保证Java核心库的类型安全。（请求 —&gt; 交给父类 —&gt; 交给爷爷辈） tomcat则与此相反 自定义类加载器（文件、网络、加密） 注意：同一个类被不同的加载器加载，JVM也会认为他们不是相同的类 线程上下文类加载器 服务器类加载器原理和OSGI介绍(面向Java的动态模块系统) Eclipse是基于OSGI技术来构建的","categories":[{"name":"back-end","slug":"back-end","permalink":"https://CPWS.github.io/categories/back-end/"}],"tags":[{"name":"注解与反射","slug":"注解与反射","permalink":"https://CPWS.github.io/tags/注解与反射/"}]},{"title":"文件上传","slug":"文件上传","date":"2019-06-28T01:51:14.000Z","updated":"2019-12-05T08:57:43.851Z","comments":true,"path":"2019/06/28/文件上传/","link":"","permalink":"https://CPWS.github.io/2019/06/28/文件上传/","excerpt":"","text":"1. 文件上传功能的实现上传和下载是Web应用开发需求中出现频率较高的词汇。在JSP应用开发过程中，编写“文件上传”功能代码主要有三种方式： 采用自编写的JavaBean组件 采用JspSmart公司自己编写的JspSmartUnload组件 采用O’Reilly公司的Cos组件 1.1 采用自编写的JavaBean组件 要编写一个实现文件上传功能的组件，首先需要先了解数据传输的原理，根据数据处理的规律来完成相关的编码。步骤为： 1.获取上传数据的规律。案列如下： 12&lt;!--如果要实现文件上传功能 需要添加 enctype=\"MULTIPART/FORM-DATA\"--&gt;&lt;form enctype=\"MULTIPART/FORM-DATA\"&gt;&lt;/form&gt; 12//js版给form添加属性，实现文件上传form.encding=\"multipart/form-data\" 1234567891011121314151617181920212223242526272829&lt;!--index.jsp--&gt;&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;文件上载&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=\"up.jsp\" enctype=\"multipart/form-data\" method=\"post\"&gt; 作者： &lt;input type=\"text\" name=\"author\"&gt;&lt;br&gt; 公司： &lt;input type=\"text\" name=\"company\"&gt;&lt;br&gt; 选择要上传的文件 &lt;input type=\"file\" name=\"filename\"&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"上载\"&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;&lt;!--up.jsp--&gt;&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;jsp:useBean id=\"TheBean\" scope=\"page\" class=\"org.xmh.demo.UploadBean\" /&gt; &lt;% TheBean.doUpload(request); %&gt;&lt;/body&gt;&lt;/html&gt; 12345678910111213141516171819package org.xmh.demo;import javax.servlet.ServletInputStream;import javax.servlet.http.HttpServletRequest;import java.io.BufferedWriter;import java.io.FileWriter;import java.io.IOException;import java.io.PrintWriter;public class UploadBean &#123; public void doUpload(HttpServletRequest request) throws IOException &#123; PrintWriter pw=new PrintWriter(new BufferedWriter(new FileWriter(\"d:\\\\xmh.txt\"))); ServletInputStream in=request.getInputStream(); int i=in.read(); while(i!=-1)&#123; pw.print((char)i); i=in.read(); &#125; pw.close(); &#125;&#125; 编写上传组件。 根据上文所述，如果想要获取表单提取的数据，需要设计一个功能类来处理相关的数据信息。下面设计了一个FileUploadBean.java的类，他就是自定义处理上传功能的类。 使用自编写的上传组件。 案例2 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;自编写上传组件--文件上传示例&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=\"selfBean.jsp\" enctype=\"multipart/form-data\" method=\"post\"&gt; 作者：&lt;input type=\"text\" name=\"author\"&gt;&lt;br&gt; 公司：&lt;input type=\"text\" name=\"company\"&gt;&lt;br&gt; 说明: &lt;textarea name=\"comment\" &gt;&lt;/textarea&gt;&lt;br&gt; 选择要上载的文件: &lt;input type=file name=\"filename\"&gt;&lt;br&gt; 文件描述: &lt;input type=\"text\" name=\"description\"&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"Upload\"&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;jsp:useBean id=\"TheBean\" class=\"org.xmh.demo.FileUploadBean\" scope=\"page\"&gt; &lt;% TheBean.setSavePath(\"d:/\"); TheBean.doUpload(request); out.println(\"Filename:\"+TheBean.getFilename()); out.println(\"&lt;BR&gt;内容类型:\"+TheBean.getContentType()); out.println(\"&lt;BR&gt;作者:\"+TheBean.getFieldValue(\"author\")); out.println(\"&lt;BR&gt;公司:\"+TheBean.getFieldValue(\"company\")); out.println(\"&lt;BR&gt;说明:\"+TheBean.getFieldValue(\"comment\")); %&gt; &lt;/jsp:useBean&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123package org.xmh.demo;import javax.servlet.ServletInputStream;import javax.servlet.http.HttpServletRequest;import java.io.*;import java.util.Hashtable;public class FileUploadBean &#123; private String savePath; private String filepath; private String filename; private String contentType; private Hashtable&lt;String, String&gt; fields; // 返回filename私有域的值 public String getFilename() &#123; return filename; &#125; // 返回filepath私有域的值 public String getFilepath() &#123; return filepath; &#125; // 返回savePath私有域的值 public void setSavePath(String savePath) &#123; this.savePath = savePath; &#125; // 返回contentType私有域的值 public String getContentType() &#123; return contentType; &#125; // 返回HTML表单中指定输入元素的值，元素的名字通过fieldName参数指定 public String getFieldValue(String fieldName) &#123; if (fields == null || fieldName == null) return null; return (String) fields.get(fieldName); &#125; private void setFilename(String s) &#123; if (s == null) return; int pos = s.indexOf(\"filename=\\\"\"); if (pos != -1) &#123; filepath = s.substring(pos + 10, s.length() - 1);// Windows浏览器发送完整的文件路径和名字// 但Linux/Unix和Mad浏览器只发送文件名字 pos = filepath.lastIndexOf(\"\\\\\"); if (pos != -1) filename = filepath.substring(pos + 1); else filename = filepath; &#125; &#125; private void setContentType(String s) &#123; if (s == null) return; int pos = s.indexOf(\": \"); if (pos != -1) contentType = s.substring(pos + 2, s.length()); &#125; //处理请求数据的方法 public void doUpload(HttpServletRequest request) throws IOException &#123; ServletInputStream in = request.getInputStream(); // 创建字节数组充当缓冲容器的作用 byte[] line = new byte[128]; int i = in.readLine(line, 0, 128); if (i &lt; 3) return; // -2丢弃换行字符 int boundaryLength = i - 2; String boundary = new String(line, 0, boundaryLength); fields = new Hashtable&lt;String, String&gt;(); while(i!=-1)&#123; String newLine=new String(line,0,i); if(newLine.startsWith(\"Content-Disposition: form-data; name=\\\"\"))&#123; //判断文件类型 if(newLine.indexOf(\"filename=\\\"\") != -1)&#123; setFilename(new String(line,0,i-2)); if(filename == null)&#123; return; &#125; i=in.readLine(line,0,128); setContentType(new String(line,0,i-2)); i=in.readLine(line,0,128); newLine=new String(line,0,i); PrintWriter pw=new PrintWriter(new BufferedWriter(new FileWriter((savePath == null ? \"\":savePath)+filename))); while(i!=-1 &amp;&amp; !newLine.startsWith(boundary))&#123; //文件的最后一行包含换行符 //因此必须检查当前行是否是最后一行 i=in.readLine(line,0,128); if( (i == boundaryLength+2 || i==boundaryLength+4) &amp;&amp; (new String(line,0,i).startsWith(boundary)))&#123; pw.print(newLine.substring(0,newLine.length()-2)); &#125;else&#123; pw.print(newLine); &#125; newLine=new String(line,0,i); &#125; pw.close(); &#125;else&#123; //普通表单输入元素 //获取输入元素名字 int pos=newLine.indexOf(\"name=\\\"\"); String fieldName=newLine.substring(pos+6,newLine.length()-3); i=in.readLine(line,0,128); newLine=new String(line,0,i); StringBuffer fieldValue=new StringBuffer(128); while(i!=-1 &amp;&amp; !newLine.startsWith(boundary))&#123; //最后一行包含换行符 //因此必须检查当前行是否是最后一行 i=in.readLine(line,0,128); if( (i==boundaryLength+2 || i==boundaryLength+4) &amp;&amp;(new String(line,0,i).startsWith(boundary)))&#123; fieldValue.append(newLine.substring(0,newLine.length()-2)); &#125;else fieldValue.append(newLine); newLine=new String(line,0,i); &#125; fields.put(fieldName,fieldValue.toString()); &#125; &#125; i=in.readLine(line,0,128); &#125; &#125;&#125; 1.2 JspSmartUpload上传组件JspSmartUpload是由JspSmart公司开发的，它可以免费下载，下载地址:https://pan.baidu.com/s/10OTcN5GOwNly-Ty9oybwQQ，提取码：4fzf因为要反馈给用户上传成功与否，所以需要将上传功能的执行顺序优先于表单的文本数据执行。 12345678910111213141516171819202122232425&lt;!--上传界面--&gt;&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;上传图片&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=\"upload_pic.jsp\" method=\"post\" enctype=\"multipart/form-data\" name=\"form1\"&gt; &lt;table border=\"1\" align=\"center\" cellpadding=\"1\" cellspacing=\"1\"&gt; &lt;tr&gt; &lt;td height=\"45\" align=\"center\" valign=\"middle\"&gt; 请选择上传的图片 &lt;input type=\"file\" name=\"file\" /&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td align=\"center\"&gt; &lt;input type=\"submit\" name=\"submit\" value=\"上传\" /&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109&lt;!--处理图片 ， 获取上传图图片，然后生成缩略图 --&gt;&lt;%@ page language=\"java\" pageEncoding=\"utf-8\" import=\"java.util.*,java.io.*\"%&gt;&lt;%@ page import=\"com.jspsmart.upload.SmartUpload\"%&gt;&lt;%@ page import=\"javax.servlet.jsp.tagext.TryCatchFinally\"%&gt;&lt;%@ page import=\"javax.imageio.ImageIO\"%&gt;&lt;%@ page import=\"java.awt.image.BufferedImage\"%&gt;&lt;%@ page import=\"javax.servlet.*\"%&gt;&lt;%@ page import=\"javax.servlet.http.*\"%&gt;&lt;%@ page import=\"java.awt.*\" %&gt;&lt;% String path = request.getContextPath(); String basePath = request.getScheme() + \"://\" + request.getServerName() + \":\" + request.getServerPort() + path + \"/\";%&gt;&lt;% SmartUpload mySmartUpload = new SmartUpload();//实例SmartUpload对象 long file_size_max = 4000000; String fileName2;//文件名 String ext;//文件扩展名 String url = \"D:/\";//应保证在WebRoot目录下有此目录的存在 //初始化 mySmartUpload.initialize(pageContext); //只允许上载此类文件 try &#123; //支持上载文件的后缀名 //mySmartUpload.setAllowedFilesList(\"jpg,gif\"); //mySmartUpload.setAllowedFilesList(\"jpg,gif,jpeg,png\"); //不支持指定的后缀 mySmartUpload.setDeniedFilesList(\"exe\"); //上载文件 mySmartUpload.upload();//不指定编码的upload()方法 //mySmartUpload.upload(\"utf-8\");//指定编码的upload()方法 &#125; catch (Exception e) &#123; out.print(\"&lt;script type=\\\"text/javascript\\\"&gt;\"); out.print(\"window.alert(\\\"文件格式不符\\\");\"); out.print(\"window.location=\\\"upload.html;\\\"\"); out.print(\"&lt;/script&gt;\"); &#125; try &#123; com.jspsmart.upload.File myFile = mySmartUpload.getFiles().getFile(0); if (myFile.isMissing()) &#123;//如果没有拿到文件，提示 out.print(\"&lt;script type=\\\"text/javascript\\\"&gt;\"); out.print(\"window.alert(\\\"请先选择要上传的文件\\\");\"); out.print(\"window.location=\\\"upload.html;\\\"\"); out.print(\"&lt;/script&gt;\"); &#125; else &#123; String myFileName = myFile.getFileName();//取得上载的文件的文件名 ext = myFile.getFileExt();//取得后缀名 if (!(ext.length() &gt; 0)) &#123; out.println(\"**************myFileName的文件名是：\" + myFileName); &#125; int file_size = myFile.getSize();//取得文件的大小 String saveUrl = \"\";//文件保存路径 if (file_size &lt; file_size_max) &#123; //更改文件名，取得当前上传时间的毫秒数值 Calendar calendar = Calendar.getInstance(); String fileName = String.valueOf(calendar.getTimeInMillis());//设置新的文件名 saveUrl += fileName + \".\" + ext; myFile.saveAs(saveUrl, mySmartUpload.SAVE_PHYSICAL);//保存文件 //上传完成，开始生成缩略图 java.io.File file = new java.io.File(saveUrl);//读入刚才上传的文件 out.println(\"ext = \" + ext); String newUrl = url + fileName + \"_min.\" + ext;//新的缩略图保存地址 System.out.println(newUrl); BufferedImage image=ImageIO.read(file); int imageWidth=image.getWidth(); //取出图片额宽度 int imageHeight=image.getHeight();//取出图片的高度 int n_w=0; //缩略图的宽度 int n_h=0; //缩略图的高度 System.out.println(\"imageWidth=\"+imageWidth + \";\"+\"imageHeight=\"+imageHeight); float tempDouble; if(imageHeight &gt; imageWidth)&#123; tempDouble = imageHeight /200; &#125;else&#123; tempDouble = imageWidth /200; &#125; n_w = (int) (imageWidth/tempDouble); n_h = (int) (imageHeight/tempDouble); FileOutputStream fos=new FileOutputStream(newUrl); BufferedImage bi=new BufferedImage(n_w,n_h,BufferedImage.TYPE_INT_RGB); Graphics g=bi.getGraphics(); g.drawImage(image,0,0,n_w,n_h,Color.LIGHT_GRAY,null); g.dispose(); ImageIO.write(bi,\"jpg\",fos); &#125; else &#123; out.print(\"&lt;script type=\\\"text/javascript\\\"&gt;\"); out.print(\"window.alert(\\\"上传文件大小不能超过\\\"+(file_size_max/1000)+\\\"K\\\");\"); out.print(\"window.location=\\\"upload.html;\\\"\"); out.print(\"&lt;/script&gt;\"); &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;%&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;处理上传的图片&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 1.3 Cos上传组件 （Cloud Object Storage） Cos组件是O&#39;Reilly公司开发的一款免费组件。 Cos包下载地址：http://www.servlets.com/cos/2.3.1 在Cos组件中MultipartRequest类主要负责文件上传的处理 (1) MultipartRequest有8个构造函数，它们分别是： public MulipartRequest(HttpServletRequest request,String saveDirectory) throws IOException public MultipartRequest(HttpServletRequest request,String saveDirectory,int maxPostSize) throws IOException public MiltipartRequest(HttpServletRequest request,String saveDirectory,int maxPostSize,FileRenamePolicy policy) throws IOException public MultipartRequest(HttpServletRequest request,String saveDirectory,int maxPostSize,String encoding) throws IOException public MultipartRequest(HttpServletRequest request,String saveDirectory,int maxPostSize,String encoding,FileRenamePolicy policy) throws IOException public MultipartRequest(HttpServletRequest request,String saveDirectory,String encoding) throws IOException public MulipartRequest(HttpServletRequest request,String saveDirectory) throws IOException public MulipartRequest(HttpServletRequest request,String saveDirectory,int maxPostSize)throws IOException (2) MultipartRequest类工具有8中方法： public Enumeration getParameters(): 取得请求参数的名称 public String getParameter(String name): 此方法返回参数为name的值 public String[] getParameterValues(String name)：当指定参数具有多个值时，此方法会返回String数组 public Enumeration getFileName()：传回所有文件输入类型的名称 public String getFilesystemNames(String name)： 用此方法得到上传文件的真正的文件名称，这里的name指文件输入类型的名称 public String getContentType(String name)： 此方法得到上传文件的文件类型 public File getFile(String name)：此方法得到一个文件对象，代表存储在服务器上的name值 public String getOriginalFileName(String name)：返回文件在修改政策有效之前的文件名称。 注意：Cos组件在上传大容量文件时，效率比起前面介绍的自编写JavaBean组件和JspSmart上传组件高。 案例： 1234567891011121314151617181920&lt;!--upload.html--&gt;&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;style&gt; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!--enctype的值很重要，upload.jsp处理上传的JSP--&gt; &lt;form action=\"upload.jsp\" enctype=\"multipart/form-data\" name=\"form1\" method=\"post\"&gt; &lt;p&gt;&lt;input type=\"file\" name=\"file1\"&gt;&lt;/p&gt; &lt;p&gt;&lt;input type=\"file\" name=\"file2\"&gt;&lt;/p&gt; &lt;p&gt;&lt;input type=\"file\" name=\"file3\"&gt;&lt;/p&gt; &lt;p&gt;&lt;input type=\"submit\" name=\"Submit\" value=\"上传\"&gt;&lt;/p&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324252627282930313233&lt;%@ page import=\"java.io.File\" %&gt;&lt;%@ page import=\"com.oreilly.servlet.MultipartRequest\" %&gt;&lt;%@ page import=\"java.util.Enumeration\" %&gt;&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;% //文件上传后，保存在d:/JavaWebs String saveDirectory=\"d:\"+ File.separator+\"JavaWebs\"; //每个文化最大500M,最多三个文件，所以... int maxPostSize=3*500*1024*1024; //response的编码为gd2312，同时采用缺省的文件名冲突解决策略，实现上传 MultipartRequest multi=new MultipartRequest(request,saveDirectory,maxPostSize,\"UTF-8\"); //输出反馈信息 Enumeration files=multi.getFileNames(); while (files.hasMoreElements())&#123; System.err.println(\"ccc\"); String name= (String) files.nextElement(); File f=multi.getFile(name); if(f!=null)&#123; String fileName=multi.getFilesystemName(name); String lastFileName=saveDirectory+\"\\\\\"+fileName; out.println(\"上传的文件:\"+lastFileName); out.println(\"&lt;hr&gt;\"); &#125; &#125;%&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 以上内容大部分都是参考一本书叫做《软件开发 JSP》，感谢作者!!!!","categories":[{"name":"back-end","slug":"back-end","permalink":"https://CPWS.github.io/categories/back-end/"}],"tags":[{"name":"文件上传","slug":"文件上传","permalink":"https://CPWS.github.io/tags/文件上传/"}]},{"title":"解决中文乱码","slug":"解决中文乱码","date":"2019-06-28T01:47:18.000Z","updated":"2019-12-05T08:56:25.476Z","comments":true,"path":"2019/06/28/解决中文乱码/","link":"","permalink":"https://CPWS.github.io/2019/06/28/解决中文乱码/","excerpt":"","text":"1.1 熟悉Web应用程序中与编码相关的部分 JSP编译 指定文件的存储编码,很明显。该设置应该位于文件的开头：&lt;%@page pageEncoding=&quot;UTF-8&quot; %&gt; 另外对于一般的class文件，可以在编译的时候指定编码。 JSP输出 指定文件输出到Browser时的使用的编码，该设置也应该设置在文件的开头。&lt;%@page contentType=&quot;text/html;charset=UTF8&quot; %&gt; 该设置与response.setCharacterEncoding(&quot;GBK&quot;);等效 META设置 指定网页使用的编码，该设置对静态网页尤其有用，因为静态网页无法使用采用JSP的设置而且也无法执行response.setCharacterEncoding(&quot;UTF-8&quot;) ；例如：&lt;meta http-equiv=&quot;Content-Type&quot; contentType=&quot;text/html;charset=UTF-8&quot;/&gt; 注意：如果同时采用了JSP输出和meta设置两种编码指定方式，那么JSP指定的优先。因为JSP指定的直接体现在Response中。 Form设置 当浏览器提交表单时，可以指定相应的编码，例如:&lt;form accept-charset=&quot;UTF-8&quot;&gt;&lt;/form&gt;一般不需要设置，浏览器会直接使用网页的编码 1.2 熟悉Web应用程序产生中文乱码的原因 JSP页面被编译成class文件时,如果未指定字符集时,默认使用ISO-8859-1的编码格式，这样中文会出现乱码。 提交表单时如果设定提交方式为Post而没有设置提交的编码的格式，则会以ISO-8859-1方式提交，而接收的JSP却以UTF-8的方式接收，这样也会导致中文乱码。 提交表单时如果设定提交方式为Get而没有设置提交的编码的格式，Tomcat会以GET的默认编码格式ISO8859-1对汉字进行编码，编码后追加到URL，导致接收页面得到的参数为乱码。 1.3 解决中文乱码 设置文件本身的编码格式。这可以在Eclipse或MyEclipse中进行设置。 在JSP页面中指定字符集，通常页面字符集的设置如下： 1234567&lt;%@ page contentType=\"text/html;charset=UTF-8\" %&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=\"Content-Type\" contentType=\"text/html;charset=UTF8\"/&gt; &lt;title&gt;字符集设置联系&lt;/title&gt; &lt;/head&gt;&lt;/html&gt; 数据库连接时指定的字符集。 1String url=\"jdbc:msqyl://localhost:3306/test?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=UTF-8\" 在程序中获取页面数据时使用如下代码 12response.setContentType(\"text/html;charset=UTF-8\");request.setCharacterEncoding(\"UTF-8\"); 注意： 如果需要将中文作为参数传递，需要在传递和接受时进行相应的处理、具体方法如下所示： 在传递参数时对参数编码 : &quot;...RearshRes.jsp?keywords=&quot;+java.net.URLEncoder.encode(keywords) 然后在接收参数页面中使用如下语句接收 keywords=new String(request.getParameter(&quot;keywords&quot;).getBytes(&quot;ISO-8859-1&quot;))","categories":[{"name":"back-end","slug":"back-end","permalink":"https://CPWS.github.io/categories/back-end/"}],"tags":[{"name":"解决中文乱码","slug":"解决中文乱码","permalink":"https://CPWS.github.io/tags/解决中文乱码/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-06-27T05:37:31.802Z","updated":"2019-06-27T05:45:09.482Z","comments":true,"path":"2019/06/27/hello-world/","link":"","permalink":"https://CPWS.github.io/2019/06/27/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Hello HexoCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}
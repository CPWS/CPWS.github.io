{"meta":{"title":"Prossible's Blog","subtitle":null,"description":null,"author":"zhuli","url":"https://CPWS.github.io","root":"/CPWS.github.io/"},"pages":[],"posts":[{"title":"Mybatis3","slug":"Mybatis3","date":"2019-10-08T11:25:53.000Z","updated":"2019-10-14T12:57:23.729Z","comments":true,"path":"2019/10/08/Mybatis3/","link":"","permalink":"https://CPWS.github.io/2019/10/08/Mybatis3/","excerpt":"","text":"数据库命令 创建数据库并制定编码 1Create database 数据库名 default character set utf8 创建表 123Create table 表名( 列明 类型 约束 auto_increment comment '备注') 命名规范 项目名：没有要求，不起中文 包：公司域名倒写 持久层：dao,persist,mapper 实体层：entity，model，bean，javabean，pojo 业务逻辑：service，biz 控制器层：controll,action,servlet,web 过滤器：filter 异常：exception 监听器：listener 注释 类：大驼峰 属性和方法：小驼峰 MVC开发模式 M:Model 模型，实体类、业务和dao V:View 视图，JSP C:Controller 控制器，servlet MVC应用场景：适合大型项目开发 jsp+Servlet完成查询和新增框架是什么？ 框架：软件的半成品。为解决问题制定的一套约束，在提供功能的基础上进行扩充。 框架中一些不能被封装的代码（变量），需要使用框架这新建一个xml文件，在文件中添加变量的内容。 需要建立特定位置和特定名称的配置文件. 需要使用xml解析技术和反射技术。 常用概念： 类库:提供的类没有封装一定逻辑。 举例：类库就是名言警句，写作文时引入名言警句。 框架：区别于类库，里面有一定的约束。 框架是填空题。 Mybatis简介 Mybatis是一个开源免费框架。原名叫iBatis，2010在google code，2013年迁移到github 作用：数据访问层框架。 底层是对JDBC的封装 mybatis优点之一 使用Mybatis不需要编写实现类,只需要编写需要执行的sql命令。 Mybatis 环境搭建 导入jar包 asm.jar：Cglib依赖的包 cglib.jar：动态代理的包 commons-logging.jar、log4j.jar、slf4j.*.jar：日志包 javaassist.jar：字节码解析包 mybatis.jar：mybatis的核心包 在src下编写全局配置文件（JDBC四个变量）（mybatis.xml） 没有名称配置和地址要求。 在全局配置文件中引入dtd或schema 12345678910111213141516171819202122232425&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;!-- default引用 environment的id，当前使用的环境--&gt; &lt;environments default=\"default\"&gt; &lt;!-- 声明可能使用的环境 --&gt; &lt;environment id=\"default\"&gt; &lt;!-- 使用原生JDBC事务 --&gt; &lt;transactionManager type=\"JDBC\"&gt;&lt;/transactionManager&gt; &lt;!-- 数据库连接池 --&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"com.mysql.cj.jdbc.Driver\"/&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/ssm?serverTimezone=UTC&amp;amp;characterEncoding=utf8\"/&gt; &lt;property name=\"username\" value=\"root\"/&gt; &lt;property name=\"password\" value=\"123456\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource=\"com/zhuchuli/mapper/FlowerMapper.xml\"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 新建以mapper结尾的包，在包下新建：实体类名+Mapper.xml（FlowerMapper.xml） 文件作用：编写需要执行的sql语句。 把xml文件理解成实现类。 xml文件内容 1234567891011121314&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;!-- namespace：理解成实现类的完全限定名（报名+类名） --&gt;&lt;mapper namespace=\"a.b\"&gt; &lt;!-- id:方法名 --&gt; &lt;!-- parameterType:定义参数类型 --&gt; &lt;!-- resultType:定义结果返回值类型 --&gt; &lt;!-- 如果方法返回是list，在resultType中写List的泛型，因为Mybatis对jdbc封装，一行一行读取数据 --&gt; &lt;select id=\"selAll\" resultType=\"com.zhuchuli.pojo.Flower\"&gt; select * from flower &lt;/select&gt;&lt;/mapper&gt; 测试结果（只有单独使用Mybatis时使用，最后SSM整合时下面代码不需要编写） 12345678910111213141516171819public static void main(String[] args) &#123; InputStream is=null; try &#123; is = Resources.getResourceAsStream(\"mybatis.xml\"); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; //使用工厂设计模式 SqlSessionFactory factory=new SqlSessionFactoryBuilder().build(is); //生产SqlSession SqlSession session=factory.openSession(); List&lt;Flower&gt; list=session.selectList(\"a.b.selAll\"); for (Flower flower : list) &#123; System.out.println(flower.toString()); &#125; //释放资源 session.close(); &#125; 注意：当表列名与Java的属性名称不一致时，在进行数据库查询时可以指定通过起别名来实现。 环境搭建讲解 全局配置文件讲解 &lt;transactionManager&gt;： type属性可取值 JDBC：事务管理使用JDBC原生事务管理方式。 MANAGED：把事务管理转交给其他容器。原生JDBC事务setAutoMapping(false) &lt;dataSource&gt; : type属性可取值 UNPOOLED：不使用数据库连接池，和直接使用JDBC一样。 POOLED：使用数据库连接池 JNDI（Java语言调用其他语言）：Java命令目录接口技术。 数据库连接池 在内存中开辟一块空间，存放多个数据库连接对象 JDBC Tomcat Pool:直接由tomcat产生数据库连接池 图示: 使用数据库连接池的目的： 在高频率访问数据库时，使用数据库连接池可以降低服务器系统压力，提升程序运行效率。 小项目不适用数据库连接池 实现JDBC Tomcat Pool的步骤： 在META-INF包下添加Context.xml文件 1234567891011121314&lt;Context&gt; &lt;Resource driverClassName=\"com.mysql.cj.jdbc.Driver\" url=\"jdbc:mysql://localhost:3306/ssm\" username=\"root\" password=\"123456\" maxActive=\"50\" maxIdle=\"20\" name=\"test\" auth=\"Container\" maxWait=\"10000\" type=\"javax.sql.DataSource\" /&gt;&lt;/Context&gt; 把项目发布到tomcat中，数据库连接池就产生了. 可以使用Java的JNDI获取数据库连接池对象: Context：上下文接口，Context.xml文件对象类型 123Context ctx=new InitialContext();DataSource ds=ctx.lookup(\"java:comp/env/test\");Connection conn=ds.getConnection(); 当关闭数据库连接池对象时，把连接对象归还给数据库连接池，把状态改为idle状态。 三种查询方式 selectList()：返回值List&lt;resultType属性控制&gt; ,适合于查询结果都需要遍历的需求。 1234List&lt;Flower&gt; list=session.selectList(\"a.b.selAll\");for (Flower flower : list) &#123; System.out.println(flower.toString());&#125; selectOne()：返回Object，适用于返回结果只是变量或一行数据时 12int count=session.selectOne(\"a.b.selById\");System.out.println(count); selectMap()返回值Map，适用于需求需要在查询结果中通过某列的值取到这行数据的值的需求。 Map&lt;Object,Object&gt;：第一个Object的数据类型受到selectMap()第二参数影响，第二个Object的数据类型受到&lt;restultType属性值&gt;的控制。 12Map&lt;Object,Object&gt; map=session.selectMap(\"a.b.c\", \"name\");System.out.println(map); Log4j复习 由apache提出的开源免费日志处理的类库。 为什么需要日志： 在项目中编写 system.out.println();输出到控制台，当项目发布到tomcat后，没有控制台（在命令行能看见），不容易观察一些输出结果。 log4j的作用：不仅能把内容输出到控制台，还能把内容输出到文件中。便于观察结果。 使用步骤： 导入jar包 在src下新建log4j.properties(路径和名称都不允许改变) ConversionPattern：写表达式 log4j.appender.LOGFILE.File：写文件输出路径以及名称（日志文件的扩展名为.log） Log4j输出级别： Fatal(指明错误) &gt; error(错误) &gt; warm(警告) &gt; info(普通信息) &gt; debug(调试信息) 在log4j.properties第一行控制输出级别。 log4j.rootCategory=INFO Log4j输出目的地 log4j.rootCategory=CONSOLE,LOGFILE pattern常用表达式 %C 输出类名 %d 输出时间 %L 输出行号 %m 输出日志信息 %n 换行 &lt;settings&gt;标签 在mybatis全局配置文件中&lt;settings&gt;标签控制mybatis全局开关。 在mybatis.xml中开启log4j 必须保证有jar包 在src目录下要有log4j.properties文件 在mybatis.xml配置文件中添加如下代码 1234&lt;settings&gt; &lt;!-- Mybatis开启日志功能 --&gt; &lt;setting name=\"logImpl\" value=\"LOG4J\"/&gt;&lt;/settings&gt; log4j中可以指定内容的日志（控制某个局部内容的日志级别） 命名级别（包级别）：namespace属性中除了最后一个类名 先在总体级别调成error不输出无用信息。 在该配置文件中为特定包名设置输出级别为debug。 例如： namespace=&quot;com.zhuchuli.mapper.PeopleMapper&quot;其中包级别为com.zhuchuli.mapper，需要在log4j.properties配置文件中配置如下代码：log4j.rootCategory=ERROR, CONSOLE , LOGFILE;log4j.logger.com.zhuchuli.mapper=DEBUG 目的：输出主要的日志信息。 类级别：与上面包级别差不多，此处不再赘述。 方法级别：与上面包级别差不多，此处不再赘述。 parameterType 属性 在XxxMapper.xml中等标签的parameterType可以控制参数类型。 SqlSession的selectList()和selectOne()的第二个参数和selectMap()的第三个参数都表示方法的参数 12People people=session.selectOne(\"a.b.selById\",2);System.out.println(people); 在mapper.xml文件中通过#{}获取参数 123&lt;select id=\"selById\" resultType=\"com.zhuchuli.pojo.People\" parameterType=\"int\"&gt; select * from people where id=#&#123;0&#125;&lt;/select&gt; parameterType指定参数类型 #{}获取参数值，使用索引，从0开始，#{0}表示第一个参数。 如果只有一个参数(基本数据类型或String)，mybatis对#{}里面的内容没有要求，只要写内容即可。 如果参数是对象 #{属性名} 如果参数时msap #{key} 如果想要传递多个参数，可以使用map结构或对象 #{}与${}的区别： #{}获取参数的内容支持 索引获取，param1获取指定位置参数，并且SQL使用?占位符。 ${}字符串拼接不使用?，默认找${内容}的get/set方法，如果写数字，就是一个数字。 如果在xml文件中出现”&lt;”,”&gt;”，双引号等特殊字符时，可以使用xml文件转义标签（XML自身）：&lt;![CDATA[内容]]&gt; mybatis 实现mysql分页查询 ？不允许在关键字前后进行数学运算，需要在代码中计算完成后传递到mapper.xml中 在java代码中运算 12345678910int pageSize=2;int pageNumber=3;//如果希望传递多个参数，可以使用map或者对象Map&lt;String,Object&gt; map=new HashMap&lt;String, Object&gt;();map.put(\"pageSize\",pageSize);map.put(\"pageNumber\",(pageSize-1)*pageNumber);List&lt;People&gt; people=session.selectList(\"a.b.page\",map);System.out.println(people);session.close(); 在mapper.xml文件中代码 1234&lt;!-- 分页查询 --&gt;&lt;select id=\"page\" resultType=\"com.zhuchuli.pojo.People\" parameterType=\"map\"&gt; select * from people limit #&#123;pageSize&#125;,#&#123;pageNumber&#125;&lt;/select&gt; 别名 系统内置别名：把类型全小写 给某个类起别名： alias=”自定义” mybatis.xml配置文件 123&lt;typeAliases&gt; &lt;tyeAliases type=\"com.zhuchuli.pojo.People\" alias=\"peo\"/&gt;&lt;/typeAliases&gt; mapper.xml 123&lt;select id=\"page\" resultType=\"peo\" parameterType=\"map\"&gt; select * from people limit #&#123;pageStart&#125;,#&#123;pageSize&#125;&lt;select&gt; 直接给某个包下所有类起别名， 别名为类名，区分大小写。 mybatis.xml配置 123&lt;typeAliases&gt; &lt;package name=\"com.zhuchu.pojo\"/&gt;&lt;/typeAliases&gt; mapper.xml通过类名引用。 123&lt;select id=\"page\" resultType=\"People\" parameterType=\"map\"&gt; select * from people limit #&#123;pageStart&#125;,#&#123;pageSize&#125;&lt;select&gt; MyBatis实现新增 概念复习 功能：从应用程序角度出发，软件具有哪些功能。 事务: 从数据库角度出发，完成业务时需要执行的SQL集合，统称一个事务。 业务: 完成功能时的逻辑。对应Service中一个方法 事务回滚：如果在一个事务中某个sql执行事务，希望回归到事务的原点，保证数据库数据的完整性。 在Mybatis中默认关闭了JDBC自动提交的功能。 每一个SqlSession默认都是不自动提交事务。 session.commit()提交事务。 openSession(true)：自动提交，setAutoCommit(true); mybatis底层是JDBC的封装 JDBC中executeUpdate()执行新增，删除，修改的SQL，返回值int，表示受影响的行数 mybatis中的标签没有resultType属性，认为返回值int 在openSession()时Mybatis会创建SqlSession时同时创建一个Transaction(事务对象)，同时autoCommit为false 如果出现异常，应该session.roolback()进行事务回滚。 使用进行数据库操作时，要添加事务提交处理.Mybatis接口绑定方案及多参数传递 作用：实现创建一个接口后把mapper.xml由mybatis生成接口的实现类，通常调用接口对象就可以获取mapper.xml中编写的sql。 后面mybatis和spring整合时使用的是这个方案。 实现步骤： 创建一个接口 接口包名和接口名与mapper.xml中的namespace相同。 接口中的方法名和mapper的id属性值相同。 在mybatis.xml中使用标签来进行扫描接口和mapper.xml 代码实现步骤 在mybatis.xml的中使用 123&lt;mappers&gt; &lt;package name=\"com.zhuchuli.mapper\"/&gt;&lt;/mappers&gt; 在com.zhuchuli.mapper新建一个接口 123456789101112public interface LogMapper &#123; List&lt;Log&gt; selAll(); /*** * mybatis把参数转换为map,@Param(\"\")当成key,后面的参数值当成value * @param accin * @param account * @return */ //List&lt;Log&gt; setByAccInAccount(@Param(\"accin\") String accin,@Param(\"account\") String account); List&lt;Log&gt; setByAccInAccount(String accin,String account);&#125; 在com.zhuchuli.mapper新建一个LogMapper.xml文件 12345678910&lt;mapper namespace=\"com.zhuchuli.mapper.LogMapper\"&gt; &lt;select id=\"selAll\" resultType=\"log\"&gt; select * from log &lt;/select&gt; &lt;!-- 当多参数时，不需要写parameter --&gt; &lt;select id=\"setByAccInAccount\" resultType=\"log\"&gt; select * from log where accin=#&#123;arg0&#125; and accout=#&#123;arg1&#125; &lt;!-- select * from log where accin=#&#123;param1&#125; and accout=#&#123;param2&#125; --&gt; &lt;/select&gt;&lt;/mapper&gt; 测试 12345LogMapper logMapper = session.getMapper(LogMapper.class);List&lt;Log&gt; list=logMapper.selAll();for (Log log : list) &#123; System.out.println(log);&#125; 注意：namespace必须和接口的完全限定路径一致，id值必须与接口中的方法名一致。 如果接口中的方法为多个参数，可以省略parameter 多参数实现方法 在接口中声明方法 1List&lt;Log&gt; setByAccInAccount(String accin,String account); 在mapper.xml文件中添加，#{}可以使用[param0,param1,arg0,arg1] 1234&lt;select id=\"setByAccInAccount\" resultType=\"log\"&gt; select * from log where accin=#&#123;arg0&#125; and accout=#&#123;arg1&#125; &lt;!-- select * from log where accin=#&#123;param1&#125; and accout=#&#123;param2&#125; --&gt;&lt;/select&gt; 可以使用注解 在接口中声明方法 1234567/*** * mybatis把参数转换为map,@Param(\"\")当成key,后面的参数值当成value * @param accin * @param account * @return */List&lt;Log&gt; setByAccInAccount(@Param(\"accin\") String accin,@Param(\"account\") String account); 在mapper.xml文件中添加。#{}里面的内容为@param(“内容”)参数中的内容 1select * from log where accin=#&#123;accin&#125; and accout=#&#123;accout&#125; 动态SQL 根据不同的条件需要执行不同的SQl命令，成为动态sql Nybatis中动态sql在mapper.xml添加逻辑判断等 1234567891011&lt;!-- 当多参数时，不需要写parameter --&gt;&lt;select id=\"setByAccInAccount\" resultType=\"log\"&gt; select * from log where 1=1 &lt;!-- OGNL表达式，直接写key或对象的属，不需要添加任何特殊字符 --&gt; &lt;if test=\"accin!=null and accin!='' \"&gt; and accin=#&#123;param1&#125; &lt;/if&gt; &lt;if test=\"accout!=null and accout!=''\"&gt; and accout=#&#123;param2&#125; &lt;/if&gt;&lt;/select&gt; >* 当编写where标签时，如果内容中第一个是and，去掉第一个and。 >* 如果where中有内容会生成where，如果没有内容不会生成where关键字。 >* 比使用if标签少写了1=1 123456789101112&lt;select id=\"setByAccInAccount\" resultType=\"log\"&gt; select * from log &lt;!-- OGNL表达式，直接写key或对象的属，不需要添加任何特殊字符 --&gt; &lt;where&gt; &lt;if test=\"accin!=null and accin!='' \"&gt; and accin=#&#123;param1&#125; &lt;/if&gt; &lt;if test=\"accout!=null and accout!=''\"&gt; and accout=#&#123;param2&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; 只要有一个成立，其他的都不会执行。 代码示例:如果accin和accout都不是Null或不是””，生成的sql中只有where accin=? 1234567891011121314&lt;select id=\"setByAccInAccount\" resultType=\"log\"&gt; select * from log &lt;!-- OGNL表达式，直接写key或对象的属，不需要添加任何特殊字符 --&gt; &lt;where&gt; &lt;choose&gt; &lt;when test=\"accin!=null and accin!=''\"&gt; and accin=#&#123;param1&#125; &lt;/when&gt; &lt;when test=\"accout!=null and accout!=''\"&gt; and accout=#&#123;param2&#125; &lt;/when&gt; &lt;/choose&gt; &lt;/where&gt;&lt;/select&gt; 标签：用在修改SQL中set从句 作用：去掉最后一个逗号 如果里面有内容生成set关键字，没有则不生成 代码示例 : id=#{id} 防止中没有内容。 12345678910111213&lt;update id=\"upd\" parameterType=\"log\"&gt; update log &lt;set&gt; id=#&#123;id&#125;, &lt;if test=\"accIn!=null and accIn!=''\"&gt; accin=#&#123;accIn&#125;, &lt;/if&gt; &lt;if test=\"accOut!=null and accOut!=''\"&gt; accout=#&#123;occOut&#125; &lt;/if&gt; &lt;/set&gt; where id=#&#123;id&#125;&lt;/update&gt; >* prefix 在前面添加内容 >* prefixOverrides：去掉前面内容 >* suffix：在后面添加内容 >* suffixOverrides 去掉后面内容 >* 执行顺序：先去掉内容再添加内容 实现模糊查询 作用：给参数重新赋值 场景：模糊查询，在原内容前后添加内容 标签 循环参数内容，还具备在内容前后添加内容，还具备加分隔符功能 使用场景：in查询中，批量新增中(mybatis中foreach效率较低) 示例 collection=””要遍历的集合 item:迭代变量，#{迭代变量名获取内容} open 循环后左侧要添加的内容 close 循环后右侧要添加的内容 separator 每次循环时，元素之间的分隔符 123456&lt;select id=\"selIn\" parameterType=\"list\"&gt; select * from log where id in &lt;foreach collection=\"list\" item=\"abc\" close=\"\" open=\"\" &gt; #&#123;abc&#125; &lt;/foreach&gt;&lt;/select&gt; 如果希望批量新增，sql命令 1insert into log values(default,1,2),(default,2,3) openSession()必须指定 ExecutorType.BATCH 1SqlSession session=factory.openSession(ExecutorType.BATCH); 某些sql片段，如果希望复用，可以使用定义这个片段 123&lt;sql id=\"mysql\"&gt; id,accin,accout,money&lt;/sql&gt; 在&lt;select&gt;、&lt;delete&gt;、&lt;update&gt;、&lt;insert&gt;中使用标签引用 1select &lt;include refid=\"mysql\"&gt; from log ThreadLocal+OpenSessionInView 线程容器，给线程绑定一个Object内容，后只要线程不变，可以随时取出。 改变内容，无法取出内容123456789101112131415package com.zhuchuli.test;public class Test &#123; public static void main(String[] args) &#123; ThreadLocal&lt;Integer&gt; threadLocal=new ThreadLocal&lt;Integer&gt;(); threadLocal.set(13); new Thread(()-&gt; &#123; threadLocal.set(23); System.out.println(Thread.currentThread().getName()+\"---&gt;\"+threadLocal.get()); &#125;).start(); System.out.println(Thread.currentThread().getName()+\"---&gt;\"+threadLocal.get()); &#125;&#125; 缓存 应用程序和数据库交互的过程是一个相对耗时的过程。 缓存存在的意义：让应用程序减少对数据库的访问，提升程序运行效率。 Mybatis中默认SqlSession缓存开启 同一个SqlSession对象调用同一个&lt;select&gt;时，只有第一次访问数据库，第一次之后把查询结果缓存到SqlSession缓存区(内存)中。 缓存的对象是statement对象。（简单记忆：必须是用一个&lt;select&gt;） 在mybatis时一个&lt;select&gt;对应一个Statement对象. 有效范围必须是同一个SqlSession对象 缓存流程 先去缓存区中找是否存在statement。 返回结果。 如果没有缓存statement对象，去数据库获取数据。 数据库返回查询结果. 把查询结果放到对应的缓存区中。 SqlSessionFactory缓存 二级缓存 有效范围：同一个factory内哪个SqlSession都可以获取。 什么时候使用二级缓存： 当数据频繁被使用，很少被修改 使用二级缓存的步骤，在mapper.xml文件中添加 &lt;cache readOnly=&quot;true&quot;&gt;&lt;/cache&gt; 如果不写 readOnly=&quot;true&quot;,需要把实体类实例化 当SqlSession对象close()时或commit()时会把SqlSession缓存的数据刷到SqlSessionFactory缓存区中。多表查询分类 Mybatis实现多表查询方式： 业务装备：对两个表编写单表查询语句，在业务(Service)把查询的两个结果进行关联. 使用auto mapping特性，在实现两个表联合查询时通过别名完成映射 使用Mybatis的&lt;resultMap&gt;标签进行实现。 多表查询时，类中包含另一类的对象的分类 单个对象 多个对象 &lt;resultMap&gt;标签 该标签写在mapper.xml中，由程序员控制sql查询结果与实体类的映射关系。 默认Mybatis使用auto mapping特性. 使用&lt;resultMap&gt;标签时，&lt;select&gt;标签不写resultType属性，而是使用resultMap属性引用&lt;resultMap&gt;标签 使用resultMap实现单表映射关系 实体类 1234567891011121314151617181920212223package com.zhuchuli.pojo;public class Teacher &#123; private int id1; private String name1; public int getId1() &#123; return id1; &#125; public void setId1(int id1) &#123; this.id1 = id1; &#125; public String getName1() &#123; return name1; &#125; public void setName1(String name1) &#123; this.name1 = name1; &#125; @Override public String toString() &#123; return \"Teacher [id1=\" + id1 + \", name1=\" + name1 + \"]\"; &#125; &#125; TeacherMap.xml 1234567891011&lt;mapper namespace=\"com.zhuchuli.mapper.TeacherMapper\"&gt; &lt;resultMap type=\"teacher\" id=\"mymap\"&gt; &lt;!-- 主键使用id标签配置映射关系--&gt; &lt;id column=\"id\" property=\"id1\"/&gt; &lt;!-- 其它使用result标签配置映射关系 --&gt; &lt;result column=\"name\" property=\"name1\"/&gt; &lt;/resultMap&gt; &lt;select id=\"selAll\" resultMap=\"mymap\"&gt; select * from teacher &lt;/select&gt; &lt;/mapper&gt; 数据库设计 使用resultMap实现关联单个对象(N+1方式) N+1查询方式：先查询出某个表的全部信息，根据这个表的信息查询另一个表的信息。 与业务转配的区别： 在service里面写代码，由mybatis完成转配 实现步骤 在Student实现类中包含一个Teacher对象 1234567public class Student &#123; private int id; private String name; private int age; private int tid; private Teacher teacher;&#125; 在TeacherMapper中提供一个查询： 123&lt;select id=\"selById\" resultType=\"teacher\" parameterType=\"int\"&gt; select * from teacher where id = #&#123;0&#125;&lt;/select&gt; 在StudentMapper中使用： &lt;association&gt;装配一个对象时使用。 property：对象在类中的属性名。 select：通过哪个查询查询这个对象的信息。 column：把当前表的哪个列值最为参数传递给另一个查询。 大前提是使用N+1方式时，如果列名和属性名相同可以不配置，使用Auto mapping特性，但是Mybatis默认只给列装配一次。 12345678910111213&lt;mapper namespace=\"com.zhuchuli.mapper.StudentMapper\"&gt; &lt;resultMap type=\"student\" id=\"stuMap\"&gt; &lt;id property=\"id\" column=\"id\"/&gt; &lt;result property=\"name\" column=\"name\"/&gt; &lt;result property=\"age\" column=\"age\"/&gt; &lt;result property=\"tid\" column=\"tid\"/&gt; &lt;!-- 如果关联一个对象 --&gt; &lt;association property=\"teacher\" select=\"com.zhuchuli.mapper.TeacherMapper.selById\" column=\"tid\"&gt;&lt;/association&gt; &lt;/resultMap&gt; &lt;select id=\"selAll\" resultMap=\"stuMap\"&gt; select * from student &lt;/select&gt;&lt;/mapper&gt; 可以将上面简化为： 123456789101112&lt;mapper namespace=\"com.zhuchuli.mapper.StudentMapper\"&gt; &lt;resultMap type=\"student\" id=\"stuMap\"&gt; &lt;result property=\"tid\" column=\"tid\"/&gt; &lt;!-- 如果关联一个对象 --&gt; &lt;association property=\"teacher\" select=\"com.zhuchuli.mapper.TeacherMapper.selById\" column=\"tid\"&gt;&lt;/association&gt; &lt;/resultMap&gt; &lt;select id=\"selAll\" resultMap=\"stuMap\"&gt; select * from student &lt;/select&gt;&lt;/mapper&gt; 使用&lt;resultMap&gt;查询关联集合对象（N+1） 在Teacher中添加List&lt;Student&gt; 12345public class Teacher &#123; private int id; private String name; private List&lt;Student&gt; list;&#125; 在StudentMapper.xml中添加通过tid查询 123&lt;select id=\"selByTid\" resultType=\"student\" parameterType=\"int\"&gt; select * from student where tid = #&#123;0&#125;&lt;/select&gt; 在TeacherMapper.xml中添加查询全部 &lt;collection&gt;当属性是集合类型时使用的标签 1234567891011121314&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.zhuchuli.mapper.TeacherMapper\"&gt; &lt;resultMap type=\"teacher\" id=\"mymap\"&gt; &lt;id column=\"id\" property=\"id\"/&gt; &lt;result column=\"name\" property=\"name\"/&gt; &lt;collection property=\"list\" ofType=\"student\" select=\"com.zhuchuli.mapper.StudentMapper.selByTid\" column=\"id\"&gt;&lt;/collection&gt; &lt;/resultMap&gt; &lt;select id=\"selAll\" resultMap=\"mymap\"&gt; select * from teacher &lt;/select&gt;&lt;/mapper&gt; 使用&lt;resultMap&gt;实现加载集合数据（联合查询方式） 在TeacherMapper.xml添加 mybatis可以通过主键判断对象是否被加载过 不需要担心重复创建Teacher 12345678910111213&lt;resultMap type=\"teacher\" id=\"mymap1\"&gt; &lt;id column=\"tid\" property=\"id\"/&gt; &lt;result column=\"tname\" property=\"name\"/&gt; &lt;collection property=\"list\" ofType=\"student\"&gt; &lt;id column=\"sid\" property=\"id\"/&gt; &lt;result column=\"sname\" property=\"name\"/&gt; &lt;result column=\"age\" property=\"age\"/&gt; &lt;result column=\"tid\" property=\"tid\"/&gt; &lt;/collection&gt;&lt;/resultMap&gt;&lt;select id=\"selAll1\" resultMap=\"mymap1\"&gt; select t.id tid,t.name tname,s.id sid,s.name sname,age,tid from teacher t left join student s on t.id = s.tid&lt;/select&gt; AutoMapping 结合别名实现多表查询 只能使用多表联合查询 查询出的列名与属性名必须相同 实现方式： .在sql是关键字，两侧添加反单引号 这个方法只适合对象的查询，不适合list集合的查询 123456789&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.zhuchuli.mapper.StudentMapper\"&gt; &lt;select id=\"selAll\" resultType=\"student\"&gt; select t.id `teacher.id`,t.name `teacher.name`,s.id id,s.name name,age,tid from student s left join teacher t on t.id = s.tid &lt;/select&gt;&lt;/mapper&gt; Mybatis 注解 注解：就是为了简化配置文件 Mybatis的注解简化Mapper.xml文件 如果涉及动态SQL依然使用mapper.xml mapper.xml和注解可以共存。 使用注解时mybatis.xml中&lt;mapper&gt;的使用: &lt;package/&gt; &lt;mapper class=&quot;&quot;&gt; 实现查询、修改、新增、删除等功能 12345678910111213141516171819@Select(\"select * from teacher\") List&lt;Teacher&gt; selAll(); @Insert(\"insert into teacher(id,name) values(default,#&#123;name&#125;)\") int insTeacher(Teacher teacher); @Update(\"update teacher set name=#&#123;name&#125; where id=#&#123;id&#125;\") int updTeacher(Teacher teacher); @Delete(\"delete from teacher where id=#&#123;0&#125;\") int delTeacher(int id); @Results(value =&#123; @Result(id=true,property=\"id\",column=\"id\"), @Result(property=\"name\",column=\"name\"), @Result(property=\"list\",column=\"id\",many=@Many(select=\"com.zhuchuli.mapper.StudentMapper.selById\")) &#125;) @Select(\"select * from teacher\") List&lt;Teacher&gt; selTeacher(); @Results()：相当于&lt;resultMap&gt; @result()：相当于&lt;id/&gt;或&lt;result/&gt; @Result(id=true)：相当于&lt;id/&gt; @Many：相当于&lt;collection/&gt; @One：相当于&lt;association/&gt; Mybatis运行原理 运行过程中可能遇到的类： Resources：Mybatis中IO流的工具类。 作用：负责加载配置文件 SqlSessionFactoryBuilder()：构造器 作用：创建SqlSessionFactory接口的实现类 XMLConfigBuilder：Mybatis全局配置文件内容构造器类 负责读取流内容并转换为Java代码 Configuration 封装了全局配置文件所有配置信息。 全局配置文件内容都存在该对象中。 DefaultSqlSessionFactory是SqlSessionFactory接口的实现类。 Transaction 事务类 每一个SqlSession都会带一个Transaction对象 TransactionFactory 事务工厂 负责创建Transaction对象 Executor Mybatis执行器 作用：负责执行SQL语句 相当于JDBC中的statement对象（或PreperedStatement或CallableStatement） 默认的执行器SimpleExecutor 批量操作：BatchExecutor 通过openSession(参数控制) DefaultSqlSession是SqlSession接口的实现类 ExceptionFactory：Mybatis中错误异常工厂 Spring全家桶 SpringData SpringCloud SpringBoot SpringSession","categories":[],"tags":[]},{"title":"Hibernate4","slug":"Hibernate4","date":"2019-10-07T02:16:21.000Z","updated":"2019-10-11T14:26:11.463Z","comments":true,"path":"2019/10/07/Hibernate4/","link":"","permalink":"https://CPWS.github.io/2019/10/07/Hibernate4/","excerpt":"","text":"第一讲 Hibernate简介 Hibernate是一个轻量级、ORM的框架。完成数据的持久化。是对jdbc的封装，简化jdbc操作。使用Hibernate后，不需要编写Sql语句，是一个全自动的持久化框架。使用Hibernate后，可以跨数据库平台。提高开发效率。 持久化：就是数据从瞬时状态变为持久状态的过程。 ORM：Object Relational Mapping，对象关系映射.使得操作关系可以像操作对象一样方便。 结构体系 第二讲 helloworld 使用hibernate进行helloworld程序开发，步骤： 新建Java项目 导入hibernate jar包 新建数据库表 新建pojo对象 编写User.hbm.xml 12345678910111213141516&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC \"-//Hibernate/Hibernate Mapping DTD 3.0//EN\" \"http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd\"&gt;&lt;hibernate-mapping&gt; &lt;class name=\"com.zhuchuli.vo.User\" table=\"t_user\"&gt; &lt;!-- 主键映射 --&gt; &lt;id name=\"id\" column=\"id\" type=\"int\"&gt; &lt;!-- 主键生成策略 --&gt; &lt;generator class=\"native\"/&gt; &lt;/id&gt; &lt;property name=\"name\" column=\"name\" type=\"java.lang.String\"&gt;&lt;/property&gt; &lt;property name=\"age\" column=\"age\" type=\"int\"&gt;&lt;/property&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 在src包下新建hibernate.cfg.xml 123456789101112131415&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE hibernate-configuration PUBLIC \"-//Hibernate/Hibernate Configuration DTD 3.0//EN\" \"http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd\"&gt;&lt;hibernate-configuration&gt; &lt;session-factory&gt; &lt;property name=\"connection.driver_class\"&gt;com.mysql.cj.jdbc.Driver&lt;/property&gt; &lt;property name=\"connection.url\"&gt;jdbc:mysql://localhost:3306/hibernate4?serverTimezone=UTC&lt;/property&gt; &lt;property name=\"connection.username\"&gt;root&lt;/property&gt; &lt;property name=\"connection.password\"&gt;123456&lt;/property&gt; &lt;!-- 指定数据库的方言 --&gt; &lt;property name=\"dialect\"&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt; &lt;mapping resource=\"com/zhuchuli/vo/User.hbm.xml\"/&gt; &lt;/session-factory&gt;&lt;/hibernate-configuration&gt; 测试 12345678910111213141516171819202122232425262728293031package com.zhuchuli.test;import org.hibernate.Session;import org.hibernate.SessionFactory;import org.hibernate.boot.registry.StandardServiceRegistryBuilder;import org.hibernate.cfg.Configuration;import org.hibernate.service.ServiceRegistry;import com.zhuchuli.vo.User;public class HiberatorTest &#123; public static void main(String[] args) &#123; //1.读取hibrator.cfg.xml配置文件 Configuration cfg=new Configuration().configure(); //2.创建服务注册 ServiceRegistry registery=new StandardServiceRegistryBuilder() .applySettings(cfg.getProperties()) .build(); //3.新建sessionFactory对象 SessionFactory factory=cfg.buildSessionFactory(registery); //4.创建session对象 Session session=factory.openSession(); //5.获取数据 User user=(User) session.get(User.class,1); System.out.println(user); //6.释放资源 session.close(); factory.close(); &#125;&#125; 第三讲 配置文件讲解 hibernate.cfg.xml是hibernate的主配置文件,Configuration读取的也是该对象。 1234567891011121314151617181920212223242526&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE hibernate-configuration PUBLIC \"-//Hibernate/Hibernate Configuration DTD 3.0//EN\" \"http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd\"&gt;&lt;hibernate-configuration&gt; &lt;session-factory&gt; &lt;!-- 数据库连接信息 根据不同的数据库，要配置不同参数信息。 --&gt; &lt;property name=\"connection.driver_class\"&gt;com.mysql.cj.jdbc.Driver&lt;/property&gt; &lt;property name=\"connection.url\"&gt;jdbc:mysql://localhost:3306/hibernate4?serverTimezone=UTC&lt;/property&gt; &lt;property name=\"connection.username\"&gt;root&lt;/property&gt; &lt;property name=\"connection.password\"&gt;123456&lt;/property&gt; &lt;!-- 通用配置 --&gt; &lt;!-- 指定数据库的方言 --&gt; &lt;property name=\"dialect\"&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt; &lt;!-- 打印sql语句 --&gt; &lt;property name=\"show_sql\"&gt;true&lt;/property&gt; &lt;!-- 格式化sql语句 --&gt; &lt;property name=\"format_sql\"&gt;true&lt;/property&gt; &lt;!-- 映射文件信息 --&gt; &lt;mapping resource=\"com/zhuchuli/vo/User.hbm.xml\"/&gt; &lt;/session-factory&gt;&lt;/hibernate-configuration&gt; 映射文件：Xxx-hbm.xml 非关系型数据库：MongoDB、HBase、redis 《组成原理》《编译原理》 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC \"-//Hibernate/Hibernate Mapping DTD 3.0//EN\" \"http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd\"&gt;&lt;!-- package用于指定类所在的包，如果不指定，那么在指定class的name时，需要指定完全限定名 --&gt;&lt;hibernate-mapping package=\"com.zhuchuli.vo\"&gt; &lt;!-- class指定类的映射信息 name指定类，如果没有指定package时需要使用完全限定名 table指定类对应的数据库的数据表名，如果不指定，默认和类型相同。 schema:指定模式 --&gt; &lt;class name=\"User\" table=\"t_user\" schema=\"\"&gt; &lt;!-- 主键映射 在hibernate中，类所对应的表必须要有主键 name:为类所的属性名 column:是属性名所对应的表的字段名称，类型是属性的类型 column默认很属性名一致，类型默认和属性的类型一致。 length 指定长度 --&gt; &lt;id name=\"id\" column=\"id\" type=\"int\"&gt; &lt;!-- 主键生成策略 Oracle数据库 自增生成策略 &lt;generator class=\"sequence\"&gt; &lt;param name=\"sequence\"&gt;user_seq&lt;/param&gt; &lt;/generator&gt; UUID：生成的字符串唯一 hilo：使用一个高/低位算法高效生成long，short或int类型的标识符 assign:自己输入主键 forign： --&gt; &lt;generator class=\"native\"/&gt; &lt;/id&gt; &lt;!-- property 指定属性的映射 --&gt; &lt;property name=\"name\" column=\"name\" type=\"java.lang.String\"&gt;&lt;/property&gt; &lt;property name=\"age\" column=\"age\" type=\"int\"&gt;&lt;/property&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 第四讲 工具类及hibernate crud操作 工具类Util 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.zhuchuli.util;import org.hibernate.Session;import org.hibernate.SessionFactory;import org.hibernate.boot.registry.StandardServiceRegistryBuilder;import org.hibernate.cfg.Configuration;import org.hibernate.service.ServiceRegistry;public class HibernateUtil &#123; private static Configuration cfg=null; private static ServiceRegistry registery=null; private static SessionFactory factory=null; private static ThreadLocal&lt;Session&gt; sessionLocal=null; static &#123; cfg=new Configuration().configure(); registery=new StandardServiceRegistryBuilder() .applySettings(cfg.getProperties()) .build(); /*** * sessionFactory是一个重量级对象，在一个应用中只需一个即可。是一个 * 进程级别对象，可以在集群中使用。 * 操作完后一般不会释放资源。 */ factory=cfg.buildSessionFactory(registery); sessionLocal=new ThreadLocal&lt;Session&gt;(); &#125; public static Session getSession() &#123; if( sessionLocal.get()!=null &amp;&amp; !sessionLocal.get().isOpen()) &#123; sessionLocal.set(null); &#125; if(sessionLocal.get() == null) &#123; sessionLocal.set(factory.openSession()); &#125; return sessionLocal.get(); &#125; //释放资源 public static void close() &#123; if(sessionLocal.get()!=null) &#123; sessionLocal.get().close(); sessionLocal.set(null); &#125; &#125;&#125; crud操作 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091package com.zhuchuli.hibernate.test;import org.hibernate.Session;import org.hibernate.Transaction;import com.zhuchuli.util.HibernateUtil;import com.zhuchuli.vo.User;public class HibernateTest &#123; public static void main(String[] args) &#123; &#125; //删除 先查后删除。 private static void delete() &#123; Session session=null; Transaction tx=null; try &#123; //获取Session对象 session= HibernateUtil.getSession(); //获取事务并且开启事务 tx= session.beginTransaction(); User user=(User) session.get(User.class, 4); //删除 session.delete(user); //提交事务 tx.commit(); &#125; catch (Exception e) &#123; e.printStackTrace(); if(tx!=null) &#123; tx.rollback(); &#125; &#125;finally &#123; HibernateUtil.close(); &#125; &#125; //修改数据 先查在修改最后再删除 private static void update() &#123; Session session=null; Transaction tx=null; try &#123; //获取Session对象 session= HibernateUtil.getSession(); //获取事务并且开启事务 tx= session.beginTransaction(); User user=(User) session.get(User.class, 4); System.out.println(user); user.setName(\"小六六\"); //修改 session.save(user); //提交事务 tx.commit(); &#125; catch (Exception e) &#123; e.printStackTrace(); if(tx!=null) &#123; tx.rollback(); &#125; &#125;finally &#123; HibernateUtil.close(); &#125; &#125; // //增加数据 private static void save() &#123; Session session=null; Transaction tx=null; try &#123; //获取Session对象 session= HibernateUtil.getSession(); //获取事务并且开启事务 tx= session.beginTransaction(); /* 下面两句话等同上面一句话 Transaction tx=session.getTransaction(); tx.begin(); */ User user = new User(); user.setName(\"刘德华\"); user.setAge(53); //保存数据 session.save(user); //提交事务 tx.commit(); &#125; catch (Exception e) &#123; e.printStackTrace(); if(tx!=null) &#123; tx.rollback(); &#125; &#125;finally &#123; HibernateUtil.close(); &#125; &#125;&#125; 第五讲 软件工程步骤： 需要分析、概要分析、详细分析、编程、测试、发布 测试: 黑盒测试：工人测试。 白盒测试：Junit，需要编码实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.zhuchuli.test;import org.hibernate.Session;import org.hibernate.Transaction;import org.junit.After;import org.junit.Before;import org.junit.Test;import com.zhuchuli.util.HibernateUtil;import com.zhuchuli.vo.User;public class HibernateTest &#123; private Session session=null; private Transaction tx=null; @Before public void setUp() &#123; try &#123; //获取Session对象 session = HibernateUtil.getSession(); //获取事务并且开启事务 tx = session.beginTransaction(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; @After public void tear() &#123; HibernateUtil.close(); &#125; @Test public void testSave() &#123; try &#123; User user = new User(); user.setName(\"张学友\"); user.setAge(53); //保存数据 session.save(user); //提交事务 tx.commit(); &#125; catch (Exception e) &#123; e.printStackTrace(); if(tx!=null) &#123; tx.rollback(); &#125; &#125; &#125;&#125; 第六讲 对象生命周期 对象生命周期图 两种路线 new —&gt; 瞬时状态 —&gt; save() —&gt; 持久状态 —&gt; close() —&gt; 游离状态。 1234567891011121314151617181920212223242526272829//测试对象生命周期：第一条线路@Testpublic void testSession1() &#123; User user=null; try &#123; //user处于瞬时状态 user = new User(); user.setName(\"kkk\"); user.setAge(40); //user处于持久状态 //对象处于持久状态时被session管理 session.save(user); //对象处于持久状态时，提交事务前会将session中对象与数据库中的记录进行脏数据检查，如果不一致则进行数据同步。 //user.setAge(23);//此时会自动调用update() //提交事务 tx.commit(); &#125; catch (Exception e) &#123; e.printStackTrace(); if(tx!=null) &#123; tx.rollback(); &#125; &#125; //请除指定对象 ----&gt; session不再管理user //user此时处于游离状态，可能会把垃圾回收站回收。 session.evict(user); //close关闭session session.close(); //clear清楚session所有对象&#125; Get —&gt; 持久状态 —&gt; clear —&gt; 游离状态 —&gt; update() —&gt; 持久状态 –&gt; delete() —&gt; 瞬时状态 12345678910111213141516171819//测试对象生命周期：第二条线路@Testpublic void testSession2() &#123; User user=null; try &#123; //user对象被session管理，处于持久状态 user=(User) session.get(User.class, 1); //调用clear后，session不在管理user，user处理游离状态 session.clear(); user.setName(\"ddd\");//此时处于游离状态，所有数据库的数据不会发生改变 session.update(user);//重回持久状态,user对象被session管理. session.delete(user);//删除后user对象处于瞬时状态。 tx.commit(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; 总结 瞬时状态 session没有，数据库没有 持久状态 session有，数据库有,在该状态下会进行脏数据的读取 游离状态 session没有，数据库有 第七讲 hibernate与struts2框架的整合第八讲 关联映射之单向多对一 SchemaExport工具类 123456789101112/**** 将对象信息 转换为 关系信息*/@Testpublic void testCreateDB() &#123; Configuration cfg=new Configuration().configure(); //使得hibernate映射信息转化为ddl(数据库定义语言) SchemaExport se = new SchemaExport(cfg); //第一参数：是否打印ddl语句 //第二个参数：是否将ddl到数据库执行 se.create(true, true);&#125; 通用配置实现hbm to ddl 1234567&lt;!-- hbm2ddl.auto：该属性用于配置 是否将映射信息转换为关系信息 create：每次执行都会删除表再创建表 update：先检查数据库中表是否存在，如果不存在则先创建表，通常使用update create-drop：--&gt;&lt;property name=\"hbm2ddl.auto\"&gt;create&lt;/property&gt; 类与类之间的关系 依赖 –&gt; 关联 –&gt; 组合 –&gt; 聚合 学生和班级的信息是一个多对一的关系 表结构 类结构： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.zhuchuli.vo;import java.io.Serializable;/*** * 学生类 * @author 朱楚利 * */public class Student implements Serializable&#123; private int id; private String name; private int age; private String sex; //学生所对应的班级 private Cluss cluss; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125; public Cluss getCluss() &#123; return cluss; &#125; public void setCluss(Cluss cluss) &#123; this.cluss = cluss; &#125; &#125; 123456789101112131415161718192021222324252627282930313233package com.zhuchuli.vo;import java.io.Serializable;/*** * 班级类 * @author 朱楚利 * */public class Cluss implements Serializable&#123; private int id; private String name; private String address; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125; &#125; 映射文件 班级映射文件:Cluss_hbm.xml 123456789&lt;hibernate-mapping package=\"com.zhuchuli.vo\"&gt; &lt;class name=\"Cluss\" table=\"t_class\"&gt; &lt;id name=\"id\"&gt; &lt;generator class=\"native\"&gt;&lt;/generator&gt; &lt;/id&gt; &lt;property name=\"name\"&gt;&lt;/property&gt; &lt;property name=\"address\"&gt;&lt;/property&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 关联映射之基于外键单向一对一 身份证和人是一对一关系的","categories":[],"tags":[]},{"title":"深入使用struts2","slug":"深入使用struts2","date":"2019-09-29T11:17:18.000Z","updated":"2019-10-07T02:15:36.510Z","comments":true,"path":"2019/09/29/深入使用struts2/","link":"","permalink":"https://CPWS.github.io/2019/09/29/深入使用struts2/","excerpt":"","text":"详解Struts2的类型转换Strut2内建的类型转换器 对于大部分常用类型，开发者无须理会类型转换，Struts2可以完成大多数常用的类型转换。这是常用的类型转换是通过Struts2内建的类型转化器完成的，Struts2已经内建了字符串类型与如下类型之间相互转换的转换器。 boolean和Boolean：完成字符串和布尔值之间的转换。 char和Character：完成字符串和字符之间的转换。 int和Integer：完成字符串和整型值之间的转换。 long和Long：完成字符串和长整型值之间的转换。 float和Float：完成字符串和单精度浮点之间的转换。 double和Double：完成字符串和双精度浮点之间的转换。 Date：完成字符串和日期类型之间的转换，日期格式使用用户请求所在Locale的SHORT格式。 数据：在默认情况下，数组元素是字符串，如果用户提供了自定义的类型转换器，也可以是其他复合类型的转换器。 集合：在默认情况下，假定集合元素类型为String，并创建一个新的ArrayList封装所有的字符串。基于OGNL的类型转换 借助于内置的类型转换器，Struts2可以完成字符串和基本类型之间的转换。除此之外，借助于OGNL表达式，Struts2允许以另一种简单的方法将请求参数转换成复合类型。 不仅如此，还可以直接将请求参数转换成Collection集合。 指定集合元素的类型 使用集合时都使用了泛型，这种泛型可以让Struts2了解集合元素的类型，Struts2就可以通过反射来创建对应类的对象，并将这些对象加入到List中。 如果不使用泛型的话，这时得通过局部类型转换文件来指定集合元素的类型。 局部类型转换文件文件名应该为：actionName-convention.properties 类型转换文件应该与Action存放在相同的位置。 为了指定List集合里元素的类型，需要指定两个部分 List集合属性名称 List集合里元素的类型 提示：为了让Struts2了解集合中元素的类型，可以使用如下两种方式： 通过为集合指定泛型。 通过在Action的局部类型转换文件中指定集合元素的类型。 自定义类型转换器 大部分时候，使用Struts2提供的类型转换器，以及基于OGNL的类型转换机制,就能满足大部分类型转换的需求。但在某些特殊的情况下，例如需要把一个字符串转换成一个复合对象，这时候就需要使用到类型转换器。 Struts2的类型转换器实际上依然是基于OGNL框架的，在OGNL项目中有一个TypeConverter接口，这个接口就是自定义类型转换器要实现的接口。该接口的定义如下： 1234//OGNL提供的类型转换器接口public interface TypeConverter&#123; public Object converterValue(Map context,Object target,Member member,String propertyName,Object value,Class toType); &#125; 实现类型转换器必须实现上面的TypeConverter接口，不过上面接口里面的方法太过复杂，所有OGNL项目还为该接口提供了一个实现类：DefultTypeConverter，通常采用扩展该方法来实现自定义类型转换器。实现类型转换器需要重写DefaultTypeConverter类的converterValue方法。 converterValue方法：为了实现该方法的双向转换，程序需要通过判断toType的类型即可判断转换的方向。 注册类型转换器 自定义类型转换器完成之后，必须在web应用中注册该类型转换器，Struts2才可以正常使用该类型转换器。 Struts2支持如下三种类型转换器 注册局部类型转换器：ActionName-conversion.properties 注册全局类型转换器：xwork-conversion.properties 使用JDK1.5的注解来注册类型转换器：通过注解方法来注册类型转换器。 局部转换器只对指定的Action的执行属性有效，全局转换器指对指定类型的全部属性有效。 基于Struts2的类型转换器 Struts2提供了StrutsTypeConverter抽象类，实际上它是DefaultTypeConverter的子类，实现该抽象类，需要实现两个方法convertFromString()和convertToString()。第一个方法是将字符串类型转换成复合类型时调用，第二方法是将复合类型转换为字符串类型的调用。 注册该方法的方式与上面三种方法一样。 处理set集合 由于set集合元素是无序状态，所以Struts2无法准确将字符串转换为set集合，也无法准确读取set集合元素。 如果想要实现处理set集合，就需要为集合里每个元素添加一个标识属性。 Struts2允许使用局部类型转换文件来指定Set集合元素的标识属性，在局部类型转换文件中增加如下一行代码即可指定Set集合标识属性。 1KeyProperty_&lt;SetPropName&gt; = &lt;KeyPropName&gt; 在jsp页面中访问set元素的方式：&lt;SetPropName&gt;(&#39;&lt;indexPropValue&gt;&#39;) 类型转换中的错误处理 实际上，表现层数据设计两个处理：类型转换和数据校验。 可以进行有效的类型转换是基础，只有当数据完成有效数据转换后，下一步才去进行数据校验。 Struts2中类型转换的错误处理流程 当conversionError拦截器对异常进行处理后，系统会跳到名为input的逻辑视图名。 处理类型转换错误 为了让struts2的类型转换机制生效，必须让Action实现ActionSupport基类，因为ActionSupport基类负责收集异常信息，并将他们封装到FieldError对象，添加到ActionContext中。 在jsp页面中使用&lt;s:fielderror&gt;输出异常信息。 使用Struts2的输入校验 输入校验分为客户端校验和服务器端校验，客户端校验主要是过滤正常用户的误操作，主要由JavaScript代码完成；服务器端校验是整个应用阻止非法数据的最后防线，主要通过在应用编程中实现。 Struts2的输入校验即包括服务器端的校验，也包括客户端的校验。编写校验规则文件 Struts2提供了基于框架的输入校验，在这种输入校验下，所有的输入校验只需要编写简单的配置文件，Struts2的验证框架将会负责服务器端校验和客户端校验. 输入校验的配置文件的文件名：ActionName-validation.xml。 该文件的配置： &lt;validtors../&gt;:该配置文件的根元素。 &lt;field-validator../&gt;：字段校验配置风格。 &lt;validator ../&gt;：非字段校验配置风格。 当输入校验失败后，Struts2会自动返回名为input的逻辑视图名。 案例实现：12345678910111213 &lt;!--registerForm.jsp--&gt;&lt;h2&gt;请输入您的注册信息&lt;/h2&gt;&lt;s:fielderror/&gt;&lt;s:form action=\"register\"&gt; &lt;s:textarea name=\"name\" label=\"用户名\"&gt;&lt;/s:textarea&gt; &lt;s:textarea name=\"pass\" label=\"密码\"&gt;&lt;/s:textarea&gt; &lt;s:textarea name=\"age\" label=\"年龄\"&gt;&lt;/s:textarea&gt; &lt;s:textarea name=\"birth\" label=\"生日\"&gt;&lt;/s:textarea&gt; &lt;s:submit value=\"注册\"&gt;&lt;/s:submit&gt;&lt;/s:form&gt; 12345678910//Register Actionpublic class RegisterAction extends ActionSupport&#123; //定义四个成员变量封装请求参数 private String name; private String pass; private int age; private Date birth; //此处省略了getter和setter方法 //处理方采用ActionSupport中的方法&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;!--校验配置文件 RegisetAction-validation.xml--&gt;&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!-- 指定校验配置文件的dtd信息 --&gt; &lt;!DOCTYPE validators PUBLIC \"-//Apache Struts//XWork Validator 1.0.3//EN\" \"http://struts.apache.org/dtds/xwork-validator-1.0.3.dtd\"&gt;&lt;!-- 校验文件根元素 --&gt;&lt;validators&gt; &lt;!-- 校验Action的name属性 --&gt; &lt;field name=\"name\"&gt; &lt;!-- 指定name属性必须满足必填规则 --&gt; &lt;field-validator type=\"requiredstring\"&gt; &lt;param name=\"trim\"&gt;true&lt;/param&gt; &lt;message&gt;必须输入用户名&lt;/message&gt; &lt;/field-validator&gt; &lt;!-- 指定name属性必须匹配正则表达式 --&gt; &lt;field-validator type=\"regex\"&gt; &lt;param name=\"regex\"&gt;&lt;![CDATA[(\\w&#123;4,25&#125;)]]&gt;&lt;/param&gt; &lt;message&gt;您输入的用户只能是字母或数字，且长度必须在4-25位之间&lt;/message&gt; &lt;/field-validator&gt; &lt;/field&gt; &lt;!-- 校验Action的pass属性 --&gt; &lt;field name=\"pass\"&gt; &lt;!-- 指定pass属性必须满足必填规则 --&gt; &lt;field-validator type=\"requiredstring\"&gt; &lt;param name=\"trim\"&gt;true&lt;/param&gt; &lt;message&gt;必须输入密码&lt;/message&gt; &lt;/field-validator&gt; &lt;!-- 指定pass属性必须匹配正则表达式 --&gt; &lt;field-validator type=\"regex\"&gt; &lt;param name=\"regex\"&gt;&lt;![CDATA[(\\w&#123;4,25&#125;)]]&gt;&lt;/param&gt; &lt;message&gt;您输入的密码只能是字母或数字，且长度必须在4-25位之间&lt;/message&gt; &lt;/field-validator&gt; &lt;/field&gt; &lt;!-- 指定age必须在指定范围内 --&gt; &lt;field name=\"age\"&gt; &lt;field-validator type=\"int\"&gt; &lt;param name=\"min\"&gt;1&lt;/param&gt; &lt;param name=\"max\"&gt;150&lt;/param&gt; &lt;message&gt;年纪必须在1到150之间的整数&lt;/message&gt; &lt;/field-validator&gt; &lt;/field&gt; &lt;!-- 指定birth必须在指定范围内 --&gt; &lt;field name=\"birth\"&gt; &lt;field-validator type=\"date\"&gt; &lt;!-- 下面指定日期字符串时，必须使用Locale的日期格式 --&gt; &lt;param name=\"min\"&gt;1900-01-01&lt;/param&gt; &lt;param name=\"max\"&gt;2050-20-21&lt;/param&gt; &lt;message&gt;生日必须在$&#123;min&#125;到s&#123;max&#125;之间&lt;/message&gt; &lt;/field-validator&gt; &lt;/field&gt;&lt;/validators&gt; 12345&lt;!--struts.xml--&gt;&lt;action name=\"register\" class=\"org.crazyit.app.action.RegisterAction\"&gt; &lt;result&gt;/WEB-INF/content/show.jsp&lt;/result&gt; &lt;result name=\"input\"&gt;/WEB-INF/content/registerForm.jsp&lt;/result&gt;&lt;/action&gt; 12345&lt;!--show.jsp--&gt;用户名：&lt;s:property value=\"name\"/&gt;&lt;br/&gt;密 码：&lt;s:property value=\"pass\"/&gt;&lt;br/&gt;年 龄：&lt;s:property value=\"age\"/&gt;&lt;br/&gt;生 日：&lt;s:property value=\"birth\"/&gt;&lt;br/&gt; 注意：上面案例的校验配置文件与Action类放在同一个包下面。 从上面可以看出，这种校验方式的可用性很高，只要在配置文件中配置校验规则，即可完成数据校验，无须用户书写任何的数据校验代码。国家化提示信息 在上面的数据校验中，所有的提示信息都是通过硬编码的方式写在配置文件中，这种方式显然不利于程序国际化。 使用国际化资源文件案例： 数据校验配置文件： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;!--输入校验配置文件--&gt;&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!-- 指定校验配置文件的dtd信息 --&gt; &lt;!DOCTYPE validators PUBLIC \"-//Apache Struts//XWork Validator 1.0.3//EN\" \"http://struts.apache.org/dtds/xwork-validator-1.0.3.dtd\"&gt;&lt;!-- 校验文件根元素 --&gt;&lt;validators&gt; &lt;!-- 校验Action的name属性 --&gt; &lt;field name=\"name\"&gt; &lt;!-- 指定name属性必须满足必填规则 --&gt; &lt;field-validator type=\"requiredstring\"&gt; &lt;param name=\"trim\"&gt;true&lt;/param&gt; &lt;!-- &lt;message&gt;必须输入用户名&lt;/message&gt;--&gt; &lt;message key=\"name.required\"/&gt; &lt;/field-validator&gt; &lt;!-- 指定name属性必须匹配正则表达式 --&gt; &lt;field-validator type=\"regex\"&gt; &lt;param name=\"regex\"&gt;&lt;![CDATA[(\\w&#123;4,25&#125;)]]&gt;&lt;/param&gt; &lt;!-- 采用国际化资源文件配置提示信息 --&gt; &lt;message key=\"name.regex\"/&gt; &lt;/field-validator&gt; &lt;/field&gt; &lt;!-- 校验Action的pass属性 --&gt; &lt;field name=\"pass\"&gt; &lt;!-- 指定pass属性必须满足必填规则 --&gt; &lt;field-validator type=\"requiredstring\"&gt; &lt;param name=\"trim\"&gt;true&lt;/param&gt; &lt;!-- &lt;message&gt;必须输入密码&lt;/message&gt; --&gt; &lt;message key=\"pass.required\"/&gt; &lt;/field-validator&gt; &lt;!-- 指定pass属性必须匹配正则表达式 --&gt; &lt;field-validator type=\"regex\"&gt; &lt;param name=\"regex\"&gt;&lt;![CDATA[(\\w&#123;4,25&#125;)]]&gt;&lt;/param&gt; &lt;message key=\"pass.regex\"/&gt; &lt;/field-validator&gt; &lt;/field&gt; &lt;!-- 指定age必须在指定范围内 --&gt; &lt;field name=\"age\"&gt; &lt;field-validator type=\"int\"&gt; &lt;param name=\"min\"&gt;1&lt;/param&gt; &lt;param name=\"max\"&gt;150&lt;/param&gt; &lt;message key=\"age.range\"/&gt; &lt;/field-validator&gt; &lt;/field&gt; &lt;!-- 指定birth必须在指定范围内 --&gt; &lt;field name=\"birth\"&gt; &lt;field-validator type=\"date\"&gt; &lt;!-- 下面指定日期字符串时，必须使用Locale的日期格式 --&gt; &lt;param name=\"min\"&gt;1900-01-01&lt;/param&gt; &lt;param name=\"max\"&gt;2050-20-21&lt;/param&gt; &lt;message key=\"birth.range\"/&gt; &lt;/field-validator&gt; &lt;/field&gt;&lt;/validators&gt; 国际资源文件：RegisterAction_zh_CN.properties 123456name.required=您必须输入用户名！name.regex=您输入的用户只能是字母或数字，且长度必须在4-25位之间pass.required=必须输入密码pass.regex=您输入的密码只能是字母或数字，且长度必须在4-25位之间age.range=年纪必须在$&#123;min&#125;和$&#123;max&#125;之间的整数birth.range=生日必须在$&#123;min&#125;和$&#123;max&#125;之间 其它代码与上面一样。 从上面可以看出：&lt;message../&gt;没有直接给出提示信息，而是添加一个key属性，用它来指定国际资源文件。 使用客户端校验 在Struts2应用中使用客户端校验非常简单，只需要改变人如下两个地方即可。 将输入页面的表单标签改为使用Struts2标签来生成表单。 为该&lt;s:form&gt;元素增加validate=&quot;true&quot; 123456789101112&lt;h2&gt;请输入您的注册信息&lt;/h2&gt; &lt;s:fielderror/&gt; &lt;s:form action=\"register\" validate=\"true\"&gt; &lt;s:textarea name=\"name\" label=\"用户名\"&gt;&lt;/s:textarea&gt; &lt;s:textarea name=\"pass\" label=\"密码\"&gt;&lt;/s:textarea&gt; &lt;s:textarea name=\"age\" label=\"年龄\"&gt;&lt;/s:textarea&gt; &lt;s:textarea name=\"birth\" label=\"生日\"&gt;&lt;/s:textarea&gt; &lt;s:submit value=\"注册\"&gt;&lt;/s:submit&gt; &lt;/s:form&gt; 字段校验器配置风格 Struts2提供了两种方式来配置校验规则，字段校验风格和非字段校验风格。 字段校验风格是以字段为优先的配置方式 非字段校验风格是以校验器为优先的配置方式 字段校验器风格配置文件 &lt;field ../&gt;：校验规则文件的基本组成单位。 &lt;field-validator ../&gt;：指定一个校验规则。 ：用于指定该校验器的参数。 &lt;message ../&gt;：确定失败后的提示信息。 非字段校验配置风格 对于非字段校验配置风格，这是一种以校验器为优先的配置方式 文件格式如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!-- 指定校验配置文件的dtd信息 --&gt; &lt;!DOCTYPE validators PUBLIC \"-//Apache Struts//XWork Validator 1.0.3//EN\" \"http://struts.apache.org/dtds/xwork-validator-1.0.3.dtd\"&gt;&lt;!-- 校验文件根元素 --&gt;&lt;validators&gt; &lt;!-- 非字段校验配置风格 --&gt; &lt;!-- 配置指定必填字符串的校验器 --&gt; &lt;validator type=\"requiredstring\"&gt; &lt;!-- 使用该校验器name属性 --&gt; &lt;param name=\"fieldName\"&gt;name&lt;/param&gt; &lt;param name=\"trim\"&gt;true&lt;/param&gt; &lt;!-- 指定校验失败后 输出name.required的国际化提示信息 --&gt; &lt;message key=\"name.required\"/&gt; &lt;/validator&gt; &lt;validator type=\"regex\"&gt; &lt;!--使用该校验器校验name属性 --&gt; &lt;param name=\"fieldName\"&gt;name&lt;/param&gt; &lt;param name=\"trim\"&gt;true&lt;/param&gt; &lt;param name=\"regex\"&gt;&lt;![CDATA[(\\w&#123;4,25&#125;)]]&gt;&lt;/param&gt; &lt;!-- 指定校验失败后 输出name.regex的国际化提示信息 --&gt; &lt;message key=\"name.regex\"/&gt; &lt;/validator&gt; &lt;!-- 配置指定必填字符串的校验器 --&gt; &lt;validator type=\"requiredstring\"&gt; &lt;!-- 使用该校验器pass属性 --&gt; &lt;param name=\"fieldName\"&gt;pass&lt;/param&gt; &lt;param name=\"trim\"&gt;true&lt;/param&gt; &lt;!-- 指定校验失败后 输出pass.required的国际化提示信息 --&gt; &lt;message key=\"pass.required\"/&gt; &lt;/validator&gt; &lt;validator type=\"regex\"&gt; &lt;!--使用该校验器校验name属性 --&gt; &lt;param name=\"fieldName\"&gt;pass&lt;/param&gt; &lt;param name=\"trim\"&gt;true&lt;/param&gt; &lt;param name=\"regex\"&gt;&lt;![CDATA[(\\w&#123;4,25&#125;)]]&gt;&lt;/param&gt; &lt;!-- 指定校验失败后 输出pass.regex的国际化提示信息 --&gt; &lt;message key=\"pass.regex\"/&gt; &lt;/validator&gt; &lt;!-- 配置指定整数的校验器 --&gt; &lt;validator type=\"int\"&gt; &lt;!-- 使用该校验器name属性 --&gt; &lt;param name=\"fieldName\"&gt;age&lt;/param&gt; &lt;!-- 配置指定整数的范围 --&gt; &lt;param name=\"min\"&gt;1&lt;/param&gt; &lt;param name=\"max\"&gt;150&lt;/param&gt; &lt;!-- 年纪必须在1到150之间的整数--&gt; &lt;message key=\"age.range\"/&gt; &lt;/validator&gt; &lt;!-- 配置指定整数的校验器 --&gt; &lt;validator type=\"date\"&gt; &lt;!-- 使用该校验器name属性 --&gt; &lt;param name=\"fieldName\"&gt;birth&lt;/param&gt; &lt;!-- 下面指定日期字符串时，必须使用Locale的日期格式 --&gt; &lt;param name=\"min\"&gt;1900-01-01&lt;/param&gt; &lt;param name=\"max\"&gt;2050-20-21&lt;/param&gt; &lt;!-- 生日必须在$&#123;min&#125;到$&#123;max&#125;之间 --&gt; &lt;message key=\"birth.range\"/&gt; &lt;/validator&gt;&lt;/validators&gt; 非字段校验器配置风格的配置文件 &lt;validator ../&gt;:定义一个校验规则 &lt;validator type=”” ../&gt;：用于指定校验器名称。 功能与字段校验规则一样。 ：功能与字段校验规则一样。 ：用于指定需要被校验的`Action`的属性。 短路校验器 short-circuit：在&lt;field-validator ../&gt;元素上添加该属性实现短路验证器。 校验文件的搜索规则 如果一个Action中可能包含多个处理逻辑，Struts2中允许为不同的处理逻辑提供不同的校验规则。 校验规则名字：&lt;Action Name&gt; - &lt;ActionAliasName&gt; - validation.xml；ActionAliasName为struts.xml配置文件Action的`name``值。 如果一个处理逻辑，例如登录请求处理逻辑，既有LoginAction-volidator.xml校验规则，又有LoginAction-loginPro-volidator.xml的校验规则，则该处理逻辑的校验规则为这两个校验规则的总和。 此处之外，还有另外一种情形：如果系统包含两个Action处理类：BaseAction和RegisterAction，RegisterAction继承了BaseAction,则registerAction的校验规则是RegisterAction-validation.xml和BaseAction-validation.xml这两个规则文件的总和。 假设系统中有两个Action：BaseAction和RegisterAction，则系统搜索规则文件的顺序如下： BaseAction-validation.xml BaseAction-别名-validation.xml RegisterAction-validation.xml RegisterAction-别名-validation.xml 如果上面的RegisterAction继承了BaseAction，那么RegisterAction的校验规则是上面四个校验规则文件的总和。 注意：Struts2校验规则文件是从上到下搜索的，实际用的校验规则是所有校验规则的总和。如果校验规则有冲突时，则后面文件中的校验规则取胜。 校验顺序和短路 校验器的执行顺序有如下原则： 所有非字段风格的校验器优先于字段风格的校验器。 所有的非字段风格的校验器，排在前面的会先执行。 所有的字段风格的校验器，排在前面的会先执行。 校验器短路的原则如下： 所有非字段校验器是最优先执行，如果某个非字段校验器校验失败了，则该字段上所有的校验器都不会获得校验的机会。 非字段校验器的校验失败，不会阻止其他非字段校验器的执行。 如果一个字段校验器校验失败后，则该字段下且排在该校验失败的校验器之后的其他校验器不会获得校验的机会。 如果应用中所需要的校验规则非常复杂，用户可以两个选择，开发自己的校验器，或者重写Action中的validate方法。 内建校验器 注册一个校验器，通过一个&lt;validator../&gt;元素即可注册一个校验器，name属性指定校验器名称，class指定校验器的实现类。 如果开发者开发了一个自己的校验器，则可以通过添加一个validators.xml文件来注册校验器。 注意：如果Struts2系统在src路径下找到一个validators.xml文件，则不会加载系统默认的default.xml文件。如果开发者开发自己的校验器时，要把default.xml文件里的内容全部复制到validators.xml文件中。 必填校验器(name=required):要求指定的字段必须有值（非空）。 必填校验器可以接受如下参数： fieldName:该参数用于指定校验的Action属性名，如果采用字段校验器风格，则无需指定该参数 采用非字段校验器配置风格，该校验器的配置示例如下： 123456789&lt;validators&gt; &lt;!--使用非字段校验配置风格--&gt; &lt;validator type=\"required\"&gt; &lt;!--指定需要校验的字段名--&gt; &lt;param name=\"fieldName\"&gt;username&lt;/param&gt; &lt;!--指定校验失败的提示信息--&gt; &lt;message&gt;username must not be null&lt;/message&gt; &lt;/validator&gt;&lt;/validators&gt; 采用字段校验器配置风格，该校验器的配置示例如下： 12345678910&lt;validators&gt; &lt;!--使用字段校验配置风格--&gt; &lt;field name=\"username\"&gt; &lt;field-validator type=\"required\"&gt; &lt;!--指定校验失败的提示信息--&gt; &lt;message&gt;username must not be null&lt;/message&gt; &lt;/field-validator&gt; &lt;/field&gt;&lt;/validators&gt; 必填字符串校验器（requiredstring）:该校验器要求字段值必须非空且长度大于0，即该字符串不能是””. 必填字符串校验器可以接受如下参数： fieldName:该属性指定校验的Action属性名，如果采用字段校验器配置风格，则无须指定该属性 trim:是否在校验前截断被校验属性值前后的空白，该属性是可选的，默认为true 采用非字段校验器配置风格，该校验器的配置示例如下： 12345678910&lt;validators&gt; &lt;!--使用非字段校验配置风格来配置必填字符串校验器--&gt; &lt;validator type=\"requiredstring\"&gt; &lt;!--指定需要校验的字段名--&gt; &lt;param name=\"fieldName\"&gt;username&lt;/param&gt; &lt;param name=\"trim\"&gt;true&lt;/param&gt; &lt;!--指定校验失败的提示信息--&gt; &lt;message&gt;username must not be null&lt;/message&gt; &lt;/validator&gt;&lt;/validators&gt; 采用字段校验器配置风格，该校验器的配置示例如下： 12345678910&lt;validators&gt; &lt;!--使用字段校验配置风格来配置必填字符串校验器--&gt; &lt;field name=\"username\"&gt; &lt;field-validator type=\"requiredstring\"&gt; &lt;param name=\"trim\"&gt;true&lt;/param&gt; &lt;!--指定校验失败的提示信息--&gt; &lt;message&gt;username must not be null&lt;/message&gt; &lt;/field-validator&gt; &lt;/field&gt;&lt;/validators&gt; 整数校验器（int）:整数校验器包括int、short、long，该校验器要求字段的整数值必须在指定的范围内. 该校验器可以接受如下参数: fieldName:该属性指定校验的Action属性名，如果采用字段校验器配置风格，则无须指定该属性 min：指定该属性的最小值，该参数可选，如果没有指定，则不检查最小值。 max：指定该属性的最大值，该参数可选，如果没有指定，则不检查最大值。 采用非字段校验器配置风格，该校验器的配置示例如下： 12345678910111213&lt;validators&gt; &lt;!--使用非字段校验配置风格来配置整数校验器--&gt; &lt;validator type=\"int\"&gt; &lt;!--指定需要校验的字段名--&gt; &lt;param name=\"fieldName\"&gt;age&lt;/param&gt; &lt;!--指定最小值--&gt; &lt;param name=\"min\"&gt;1&lt;/param&gt; &lt;!--指定最大值--&gt; &lt;param name=\"max\"&gt;150&lt;/param&gt; &lt;!--指定校验失败的提示信息--&gt; &lt;message&gt;username must not be null&lt;/message&gt; &lt;/validator&gt;&lt;/validators&gt; 采用字段校验器配置风格，该校验器的配置示例如下： 12345678910111213&lt;validators&gt; &lt;!--使用字段校验配置风格来配置整数校验器--&gt; &lt;field name=\"age\"&gt; &lt;field-validator type=\"int\"&gt; &lt;!--指定最小值--&gt; &lt;param name=\"min\"&gt;1&lt;/param&gt; &lt;!--指定最大值--&gt; &lt;param name=\"max\"&gt;150&lt;/param&gt; &lt;!--指定校验失败的提示信息--&gt; &lt;message&gt;username must not be null&lt;/message&gt; &lt;/field-validator&gt; &lt;/field&gt;&lt;/validators&gt; 日期校验器（date）:，该校验器要求字段的日期值必须在指定的范围内. 该校验器可以接受如下参数: fieldName:该属性指定校验的Action属性名，如果采用字段校验器配置风格，则无须指定该属性 min：指定该属性的最小值，该参数可选，如果没有指定，则不检查最小值。 max：指定该属性的最大值，该参数可选，如果没有指定，则不检查最大值。 采用非字段校验器配置风格，该校验器的配置示例如下： 12345678910111213&lt;validators&gt; &lt;!--使用非字段校验配置风格来配置日期校验器--&gt; &lt;validator type=\"int\"&gt; &lt;!--指定需要校验的字段名--&gt; &lt;param name=\"fieldName\"&gt;birth&lt;/param&gt; &lt;!--指定最小值--&gt; &lt;param name=\"min\"&gt;1900-01-01&lt;/param&gt; &lt;!--指定最大值--&gt; &lt;param name=\"max\"&gt;2020-02-21&lt;/param&gt; &lt;!--指定校验失败的提示信息--&gt; &lt;message&gt;username must not be null&lt;/message&gt; &lt;/validator&gt;&lt;/validators&gt; 采用字段校验器配置风格，该校验器的配置示例如下： 12345678910111213&lt;validators&gt; &lt;!--使用字段校验配置风格来配置日期校验器--&gt; &lt;field name=\"age\"&gt; &lt;field-validator type=\"birth\"&gt; &lt;!--指定最小值--&gt; &lt;param name=\"min\"&gt;1900-01-01&lt;/param&gt; &lt;!--指定最大值--&gt; &lt;param name=\"max\"&gt;2020-02-21&lt;/param&gt; &lt;!--指定校验失败的提示信息--&gt; &lt;message&gt;username must not be null&lt;/message&gt; &lt;/field-validator&gt; &lt;/field&gt;&lt;/validators&gt; 表达式校验器（expression）：它是一个非字段校验器，不可在字段校验配置风格中使用。 字段表达式验证器（fieldexpression）：它要求指定字段满足一个逻辑表达式。 邮箱地址校验器（email）：它要求检查的字段如果不为空，则必须满足的邮箱地址。 网址校验器（url）：它要求被检查的字符如果非空，则必须满足合法的url地址。 Visitor校验器：主要用于检测Action里的复合属性。 转换器校验（conversion）：主要用于被检验字段在类型转换过程中是否出现错误。 字符串长度校验器（stringlength）：它要求被校验字段的长度必须在指定范围内，否则校验失败。 正则表达式校验器（regex）：它用于检查被校验字符是否匹配一个正则表达式。基于注册的输入校验 案例实现：12345678910111213141516171819202122232425262728293031323334353637383940414243public class RegisterAction02 extends ActionSupport&#123; private static final long serialVersionUID = 1L; //定义User类型的成员变量用于封装请求参数 private String name; private String pass; private int age; private Date birth; public String getName() &#123; return name; &#125; //使用注解指定必填，正则表达式两个校验器 @RequiredStringValidator(key=\"name.required\",message=\"\") @RegexFieldValidator(regex=\"\\\\w&#123;4,25&#125;\",key=\"name.regex\",message=\"\") public void setName(String name) &#123; this.name = name; &#125; public String getPass() &#123; return pass; &#125; //使用注解指定必填，正则表达式两个校验器 @RequiredStringValidator(key=\"pass.required\",message=\"\") @RegexFieldValidator(regex=\"\\\\w&#123;4,25&#125;\",key=\"pass.regex\",message=\"\") public void setPass(String pass) &#123; this.pass = pass; &#125; public int getAge() &#123; return age; &#125; @IntRangeFieldValidator(message=\"\",key=\"age.range\",min=\"1\",max=\"150\") public void setAge(int age) &#123; this.age = age; &#125; public Date getBirth() &#123; return birth; &#125; @DateRangeFieldValidator(message=\"\",key=\"birth.range\",min=\"1900/01/01\",max=\"2050/02/21\") public void setBirth(Date birth) &#123; this.birth = birth; &#125; &#125; 手动完成输入校验 重写validate()方法 重写validateXxx()方法 使用Struts2控制文件上传Struts2的文件上传 实现步骤: 实现文件上传的Action 12345&lt;s:form action=\"upload\" method=\"POST\" enctype=\"multipart/form-data\"&gt; &lt;s:textfield name=\"title\" label=\"文件标题\"&gt;&lt;/s:textfield&gt; &lt;s:file name=\"upload\" label=\"选择文件\"&gt;&lt;/s:file&gt; &lt;s:submit value=\"上传\"&gt;&lt;/s:submit&gt; &lt;/s:form&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package org.crazyit.app.action;import java.io.File;import java.io.FileInputStream;import java.io.FileOutputStream;import org.apache.struts2.ServletActionContext;import com.opensymphony.xwork2.ActionSupport;@SuppressWarnings(\"all\")public class UploadAction extends ActionSupport&#123; //封装文件标题请求参数的成员变量 private String title; //封装上传文件域的成员变量 private File upload; //封装上传文件类型的成员变量 private String uploadContentType; //封装上传文件名的属性 private String uploadFileName; //直接在`struts.xml`文件中配置的成员变量 private String savePath; //接收`struts.xml`文件配置值的方法 public void setSavePath(String value) &#123; this.savePath=value; &#125; //获取上传文件的保存位置 public String getSavePath() throws Exception&#123; return ServletActionContext.getServletContext().getRealPath(savePath); &#125; public String getTitle() &#123; return title; &#125; public void setTitle(String title) &#123; this.title = title; &#125; public File getUpload() &#123; return upload; &#125; public void setUpload(File upload) &#123; this.upload = upload; &#125; public String getUploadContentType() &#123; return uploadContentType; &#125; public void setUploadContentType(String uploadContentType) &#123; this.uploadContentType = uploadContentType; &#125; public String getUploadFileName() &#123; return uploadFileName; &#125; public void setUploadFileName(String uploadFileName) &#123; this.uploadFileName = uploadFileName; &#125; @Override public String execute() throws Exception &#123; //以服务器的文件保存地址和原文件建立上传文件输出流 FileOutputStream fos=new FileOutputStream(getSavePath()+\"\\\\\"+getUploadFileName()); FileInputStream fis=new FileInputStream(getUpload()); byte[] buffer=new byte[1024]; int len=0; while((len=fis.read(buffer))!=-1) &#123; fos.write(buffer,0,len); &#125; fos.flush(); return SUCCESS; &#125;&#125; 配置文件上传的Action 123456789101112&lt;constant name=\"struts.i18n.encoding\" value=\"GBK\"&gt;&lt;/constant&gt;&lt;package name=\"default\" namespace=\"/\" extends=\"struts-default\" &gt; &lt;!-- 配置處理文件上傳的Action --&gt; &lt;action name=\"upload\" class=\"org.crazyit.app.action.UploadAction\"&gt; &lt;!-- 動態設置Action的属性值--&gt; &lt;param name=\"savePath\"&gt;/uploadFiles&lt;/param&gt; &lt;result&gt;/WEB-INF/content/succ.jsp&lt;/result&gt; &lt;/action&gt; &lt;action name=\"*\"&gt; &lt;result&gt;/WEB-INF/content/&#123;1&#125;.jsp&lt;/result&gt; &lt;/action&gt;&lt;/package&gt; 手动实现文件过滤 如果需要手动实现文件过滤，可按如下步骤进行： 在Action中定义一个专门用于过滤文件的方法，该方法的方法名是任意的，该方法的逻辑就是判断上传文件的类型是否为允许类型。例如增加filterTypes()方法,方法代码如下： 1234567891011public String filterTypes(String[] types) &#123; System.out.println(types); //获取允许上传的所有文件类型 String fileType=getUploadContentType(); for(String type:types) &#123; if(type.equals(fileType)) &#123; return null; &#125; &#125; return ERROR;&#125; 上面的方法判断了上传文件的文件类型是否在允许上传的文件类型列表中。为了让程序可以动态设置允许上传的文件类型，为该action增加一个allowTypes属性，该属性的值列出了所有允许上传的文件类型。为了可以在struts.xml文件中配置allowTypes属性的值，必须在Action类中提供如下代码: 123456789//定义该action允许上传的文件类型private String allowTypes;public String getAllowTypes() &#123; return allowTypes;&#125;public void setAllowTypes(String allowTypes) &#123; this.allowTypes = allowTypes;&#125; 利用Struts2的数据校验来判断用户输入的文件是否符合要求。如果不符合要求，接下来将错误提示信息添加到FieldError中。该Action中添加的validate()代码如下： 1234567891011//执行输入校验@Overridepublic void validate() &#123; //将允许上传的文件类型的字符串以英文逗号(,) //分解成字符串数字从而判断当前文件类型是否允许上传 String filterResult=filterTypes(getAllowTypes().split(\",\")); if(filterResult!=null) &#123; addFieldError(\"upload\", \"您要上传的文件类型不符合！\"); &#125;&#125; 在Struts.xml配置文件的配置如下： 12345678&lt;action name=\"upload\" class=\"org.crazyit.app.action.UploadAction\"&gt; &lt;!-- 動態設置Action的属性值--&gt; &lt;param name=\"savePath\"&gt;/uploadFiles&lt;/param&gt; &lt;!-- 设置允许上传的文件类型 --&gt; &lt;param name=\"allowTypes\"&gt;image/png,image/gif&lt;/param&gt; &lt;result name=\"input\"&gt;/WEB-INF/content/uploadForm.jsp&lt;/result&gt; &lt;result&gt;/WEB-INF/content/succ.jsp&lt;/result&gt;&lt;/action&gt; 为了在页面显示错误提示信息，可以在该页面添加如下代码： 1&lt;s:fielderror/&gt; 拦截器实现文件过滤 配置文件如下：1234567891011121314151617&lt;action name=\"upload\" class=\"org.crazyit.app.action.UploadAction\"&gt; &lt;!-- 配置fileUpload拦截器 --&gt; &lt;interceptor-ref name=\"fileUpload\"&gt; &lt;!-- 配置允许上传的文件类型 --&gt; &lt;param name=\"allowTypes\"&gt;image/png,image/gif&lt;/param&gt; &lt;!-- 配置允许上传的文件的大小 --&gt; &lt;param name=\"maximumSize\"&gt;2000&lt;/param&gt; &lt;/interceptor-ref&gt; &lt;!-- 配置系统默认的拦截器 --&gt; &lt;interceptor-ref name=\"defaultStack\"&gt;&lt;/interceptor-ref&gt; &lt;!-- 動態設置Action的属性值--&gt; &lt;param name=\"savePath\"&gt;/uploadFiles&lt;/param&gt; &lt;!-- 设置允许上传的文件类型 --&gt; &lt;result name=\"input\"&gt;/WEB-INF/content/uploadForm.jsp&lt;/result&gt; &lt;result&gt;/WEB-INF/content/succ.jsp&lt;/result&gt;&lt;/action&gt; 输出错误提示信息 …文件上传的常量配置 … 使用Struts2控制文件下载实现文件下载的Action 实现文件下载的Action与普通的Action没有太大的区别，，仅仅需要提供一个返回InputStream流的方法，该输入流代表了被下载文件的入口。该Action类的代码如下： 12345678910111213141516171819public class FileDownloadAction extends ActionSupport&#123; //该成员变量可以在配置文件中动态指定该值 private String inputPath; //inputName的setter方法 public void setInputPath(String value) &#123; this.inputPath = value; &#125; /* 定义一个返回InputStream的方法， 该方法将作为被下载文件的入口， 且需要配置stream类型结果时指定inputName参数， inputName参数的值就是方法去掉get前缀、首字母小写的字符串 */ public InputStream getTargetFile() throws Exception&#123; // ServletContext提供getResourceAsStream()方法 // 返回指定文件对应的输入流 return ServletActionContext.getServletContext().getResourceAsStream(inputPath); &#125;&#125; 一旦定义了该Action就可以实现文件下载。 配置Action 配置文件下载的Action与配置普通的Action并没有太大的不同，关键是要配置一个类型为stream的结果，该Stream的结果将使用文件下载作为响应。 Stream结果类型的逻辑视图是返回客户端一个输入流，因此无需指定location属性。 1234567891011121314&lt;action name=\"down\" class=\"org.crazyit.app.action.FileDownloadAction\"&gt; &lt;!-- 指定被下载资源的位置 --&gt; &lt;param name=\"inputPath\"&gt;/WEB-INF/img/56efbc0d6b66e.jpg&lt;/param&gt; &lt;result type=\"stream\"&gt; &lt;!-- 指定下载文件的文件类型 --&gt; &lt;param name=\"contentType\"&gt;image/jpg&lt;/param&gt; &lt;!-- 指定由getTargetFile()方法返回被下载文件的InputStream --&gt; &lt;param name=\"inputName\"&gt;targetFile&lt;/param&gt; &lt;!-- 指定下载的文件名 --&gt; &lt;param name=\"contentDisposition\"&gt;filename=\"demo.jpg\"&lt;/param&gt; &lt;!-- 指定下载文件的缓冲大小 --&gt; &lt;param name=\"bufferSize\"&gt;4096&lt;/param&gt; &lt;/result&gt;&lt;/action&gt; 下载前的权限控制 案例 1234567891011121314151617181920212223public class AuthorityDownAction implements Action&#123; private String inputPath; public void setInputPath(String value) &#123; this.inputPath=value; &#125; public InputStream getTargetFile() throws Exception&#123; return ServletActionContext.getServletContext().getResourceAsStream(inputPath); &#125; @Override public String execute() throws Exception &#123; //取得ActionContext实例 ActionContext ctx=ActionContext.getContext(); //通过ActionContext访问用户的HttpSession Map session=ctx.getSession(); String user=(String) session.get(\"user\"); //判断Session里的user是否通过检查 if(user!=null&amp;&amp;user.equals(\"crazyit.org\")) &#123; return SUCCESS; &#125; ctx.put(\"tip\", \"您还没有登录\"); return LOGIN; &#125;&#125; 123456789101112131415161718&lt;action name=\"download2\" class=\"org.crazyit.app.action.AuthorityDownAction\"&gt; &lt;!-- 定义被下载文件的物理资源 --&gt; &lt;param name=\"inputPath\"&gt;/WEB-INF/images/wjc_logo.zip&lt;/param&gt; &lt;result type=\"stream\"&gt; &lt;!-- 指定下载文件的文件类型 --&gt; &lt;param name=\"contentType\"&gt;application/zip&lt;/param&gt; &lt;!-- 指定由getTargetFile()方法返回被下载文件的InputStream --&gt; &lt;param name=\"inputName\"&gt;targetFile&lt;/param&gt; &lt;param name=\"contentDisposition\"&gt;filename=\"wjc_logo.zip\"&lt;/param&gt; &lt;!-- 指定下载文件的缓冲大小 --&gt; &lt;param name=\"bufferSize\"&gt;4096&lt;/param&gt; &lt;/result&gt; &lt;!-- 定义一个名为login的结果 --&gt; &lt;result name=\"login\"&gt;/WEB-INF/content/loginForm.jsp&lt;/result&gt;&lt;/action&gt;&lt;action name=\"login\" class=\"org.crazyit.app.action.LoginAction\"&gt; &lt;result&gt;/WEB-INF/content/struts2Down.jsp&lt;/result&gt;&lt;/action&gt; 详解Struts2的拦截器机制配置拦截器 定义拦截器使用&lt;interceptor../&gt;元素来定义，定义拦截器的简答的格式如下： 12&lt;!--通过指定拦截器名和拦截器实现类来定义拦截器--&gt;&lt;interceptor name=\"拦截器名\" class=\"拦截器实现类\" /&gt; 如果还需要在配置拦截器是传入拦截器参数，需要在&lt;interceptor../&gt;元素中使用&lt;param ../&gt;子元素即可。下面是它配置的简单格式： 123456&lt;!--通过指定拦截器名和拦截器实现类来定义拦截器--&gt;&lt;interceptor name=\"拦截器名\" class=\"拦截器实现类\"&gt; &lt;!--下面的元素可以出现0次，或者是无限次--&gt; &lt;!--name属性指定参数名，中间值指定的该参数名对象的参数值--&gt; &lt;param name=\"参数名\"&gt;参数值&lt;/param&gt;&lt;/interceptor&gt; 还可以把多个拦截器连在一起组成拦截器栈，定于拦截器栈可以使用&lt;interceptor-stack ../&gt;元素，拦截器栈是由多个拦截器组成的，因此需要在该元素中使用&lt;interceptor-ref ../&gt;元素来定义多个拦截器引用，即该拦截器栈由多个&lt;inteceptor-ref../&gt;元素指定的拦截器组成。配置拦截器栈的语法格式如下： 12345&lt;interceptor-stack name=\"拦截器栈名\"&gt; &lt;interceptor-ref name=\"拦截器1\"/&gt; &lt;interceptor-ref name=\"拦截器2\"/&gt; ...&lt;/inteceptor-stack&gt; 因为拦截器栈与拦截器在功能上完全统一，因此可能出现，拦截器里也可能包含其他拦截器栈。因此，可能出现如下配置片段： 12345678910&lt;interceptor-stack name=\"拦截器栈1\"&gt; &lt;interceptor-ref name=\"拦截器1\"/&gt; &lt;interceptor-ref name=\"拦截器2\"/&gt; ...&lt;/inteceptor-stack&gt;&lt;interceptor-stack name=\"拦截器栈2\"&gt; &lt;interceptor-ref name=\"拦截器3\"/&gt; &lt;interceptor-ref name=\"拦截器栈1\"/&gt; ...&lt;/inteceptor-stack&gt; 系统为拦截器指定参数有两种时机。 定义拦截器时指定参数值：这种参数值将作为拦截器参数的默认参数值。 使用拦截器时指定参数值：在配置Action时为拦截器参数指定值。 通过为&lt;interceptor-ref&gt;元素增加&lt;param../&gt;子元素，就可以在拦截器使用时为参数指定值。因此可能出现以下片段 1234567891011121314&lt;interceptor-stack name=\"拦截器栈1\"&gt; &lt;interceptor-ref name=\"拦截器1\"&gt; &lt;param name=\"参数名\"&gt;参数值&lt;/param&gt; &lt;param name=\"参数名\"&gt;参数值&lt;/param&gt; ... &lt;/interceptor-ref&gt; &lt;interceptor-ref name=\"拦截器2\"/&gt; ...&lt;/inteceptor-stack&gt;&lt;interceptor-stack name=\"拦截器栈2\"&gt; &lt;interceptor-ref name=\"拦截器3\"/&gt; &lt;interceptor-ref name=\"拦截器栈1\"/&gt; ...&lt;/inteceptor-stack&gt; 使用拦截器的配置语法 下面是在Action中定义拦截器的配置实例：123456789101112131415161718192021&lt;!--定义全部拦截器--&gt;&lt;interceptors&gt; &lt;!--定义第一个拦截器--&gt; &lt;interceptor name=\"mySimple\" class=\"lee.SimpleInterceptor\"/&gt; &lt;!--定义第二个拦截器--&gt; &lt;interceptor name=\"later\" class=\"lee.LaterInterceptor\"&gt; &lt;param name=\"参数名\"&gt;参数值&lt;/param&gt; &lt;/interceptor&gt;&lt;/interceptors&gt;...&lt;action name=\"login\" class=\"org.crazyit.app.action.LoginAction\"&gt; &lt;!--使用系统默认的拦截器--&gt; &lt;interceptor-ref name=\"defaultStack\"/&gt; &lt;!--使用第一个拦截器--&gt; &lt;interceptor-ref name=\"mySimple\"/&gt; &lt;!--使用第二个拦截器--&gt; &lt;interceptor-ref name=\"later\"&gt; &lt;!--为该Action指定拦截器参数，该参数会覆盖默认值--&gt; &lt;param name=\"name\"&gt;动态参数&lt;/param&gt; &lt;/interceptor-ref&gt;&lt;/action&gt; 配置默认拦截器 配置默认拦截器使用&lt;default-interceptor-ref&gt;元素，该元素作为package的子元素,为该包下的所有Action配置默认拦截器。 下面配置默认拦截器的配置示例：1234567891011&lt;package name=\"\" namespace=\"\" extends=\"struts-default\"&gt; &lt;interceptors&gt; &lt;!--定义拦截器--&gt; &lt;interceptor .../&gt; &lt;!--定义拦截器栈--&gt; &lt;interceptor-stack .../&gt; &lt;/interceptor&gt; &lt;!--配置该包下的默认拦截器--&gt; &lt;default-interceptor-ref name=\"拦截器名或拦截器栈名\"&gt; &lt;action ../&gt;&lt;/package&gt; 使用拦截器类 如果用户想要开发自己的拦截器，需要实现com.opensymphony.xwork2.interceptor.Interceptor接口. 该接口的类定义如下： 12345678public interface Interceptor&#123; //销毁该拦截器之前的回调方法 void destory(); //初始化该拦截器的回调方法 void init(); //拦截器实现拦截的逻辑方法 String interceptor(ActionInvocation innovation) throws Exception;&#125; 下面实现一个简单的拦截器示例： 12345678910111213141516171819202122232425262728293031323334353637public class SimpleInterceptor extends AbstractInterceptor&#123; //简单拦截器的名字 private String name; public void setName(String name) &#123; this.name = name; &#125; @Override public void init() &#123; // TODO Auto-generated method stub super.init(); &#125; @Override public void destroy() &#123; // TODO Auto-generated method stub super.destroy(); &#125; @Override public String intercept(ActionInvocation invocation) throws Exception &#123; //取得被拦截的Action实例 LoginAction action=(LoginAction) invocation.getAction(); //打印开始执行时间 System.out.println(name+\"拦截器的动作----------\"+\"开始执行登录Action的时间：\"+new Date()); //取得开始执行Action的事件 long start =System.currentTimeMillis(); //执行该烂机器的最后一个拦截器 String result=invocation.invoke(); //打印结束执行时间 System.out.println(name+\"拦截器的动作----------\"+\"介绍登录Action的时间：\"+new Date()); long end=System.currentTimeMillis(); System.out.println(\"执行时间\"+(end-start)+\"ms\"); return result; &#125; &#125; 使用拦截器 使用拦截器需要两个步骤： 通过&lt;interceptor&gt;元素来定义拦截器 通过&lt;interceptor-ref&gt;元素来使用拦截器 12345678910111213141516&lt;!-- 应用所需的拦截器需要在该元素下配置 --&gt;&lt;interceptors&gt; &lt;interceptor name=\"mySimple\" class=\"org.crazyit.app.interceptor.SimpleInterceptor\"&gt; &lt;!-- 为拦截器指定参数值 --&gt; &lt;param name=\"name\"&gt;简单拦截器&lt;/param&gt; &lt;/interceptor&gt;&lt;/interceptors&gt;&lt;action name=\"login\" class=\"org.crazyit.app.action.LoginAction\"&gt; &lt;result name=\"error\"&gt;/WEB-INF/content/eeor.jsp&lt;/result&gt; &lt;result name=\"success\"&gt;/WEB-INF/content/welcome.jsp&lt;/result&gt; &lt;!-- 配置系统的默认拦截器 --&gt; &lt;interceptor-ref name=\"defaultStack\"&gt;&lt;/interceptor-ref&gt; &lt;interceptor-ref name=\"mySimple\"&gt; &lt;param name=\"name\"&gt;改名后的拦截器&lt;/param&gt; &lt;/interceptor-ref&gt;&lt;/action&gt; 拦截方法的拦截器 方法过滤的拦截器方法的示例：123456789101112131415161718192021222324252627282930313233343536/*** * 拦截器方法的拦截器，应该继承MethodFilterInterceptor * @author 1huangzewei * */public class MyFilterInterceptor extends MethodFilterInterceptor&#123; /** * */ private static final long serialVersionUID = 1L; //简单拦截器的名字 private String name; public void setName(String name) &#123; this.name = name; &#125; @Override protected String doIntercept(ActionInvocation invocation) throws Exception &#123; //取得被拦截的Action实例 LoginAction action=(LoginAction) invocation.getAction(); //打印开始执行时间 System.out.println(name+\"拦截器的动作----------\"+\"开始执行登录Action的时间：\"+new Date()); //取得开始执行Action的事件 long start =System.currentTimeMillis(); //执行该烂机器的最后一个拦截器 String result=invocation.invoke(); //打印结束执行时间 System.out.println(name+\"拦截器的动作----------\"+\"介绍登录Action的时间：\"+new Date()); long end=System.currentTimeMillis(); System.out.println(\"执行时间\"+(end-start)+\"ms\"); return result; &#125; &#125; 123456789101112131415161718&lt;!-- 应用所需的拦截器需要在该元素下配置 --&gt;&lt;interceptors&gt; &lt;interceptor name=\"mySimple\" class=\"org.crazyit.app.interceptor.MyFilterInterceptor\"&gt; &lt;!-- 为拦截器指定参数值 --&gt; &lt;param name=\"name\"&gt;拦截器方法拦截器&lt;/param&gt; &lt;/interceptor&gt;&lt;/interceptors&gt;&lt;action name=\"login\" class=\"org.crazyit.app.action.LoginAction\"&gt; &lt;result name=\"error\"&gt;/WEB-INF/content/eeor.jsp&lt;/result&gt; &lt;result name=\"success\"&gt;/WEB-INF/content/welcome.jsp&lt;/result&gt; &lt;!-- 配置系统的默认拦截器 --&gt; &lt;interceptor-ref name=\"defaultStack\"&gt;&lt;/interceptor-ref&gt; &lt;interceptor-ref name=\"mySimple\"&gt; &lt;param name=\"name\"&gt;改名后的拦截器&lt;/param&gt; &lt;!-- 指定execute方法不需要被拦截 --&gt; &lt;param name=\"excludeMethods\"&gt;execute&lt;/param&gt; &lt;/interceptor-ref&gt;&lt;/action&gt; Struts2中提供了方法过滤的拦截器有如下几个 TokenInterceptor、TokenSessionStoreInterceptor、DefaultWorkflowInterceptor、ValidationInterceptor 拦截器的执行顺序 在Action的控制方法执行之前，位于拦截器链前面的拦截器将先发生作用，在Action控制方法执行之后，为于拦截器链前面的拦截器将后发生作用。 拦截结果的监听器 拦截结果的监听器代码： 1234567891011public class MyPreResultListener implements PreResultListener&#123; //定义在处理result之前的行为。 @Override public void beforeResult(ActionInvocation invocation, String resultCode) &#123; //打印出执行结果 System.out.println(\"返回的逻辑视图名：\"+resultCode); &#125;&#125; 在拦截器中手动注册拦截结果监听器 12345678910111213public class BeforeResultInterceptor extends AbstractInterceptor&#123; @Override public String intercept(ActionInvocation invocation) throws Exception &#123; //将一个拦截结果的监听器注册给该监听器 invocation.addPreResultListener(new MyPreResultListener()); System.out.println(\"execute方法执行之前的拦截...\"); String result=invocation.invoke(); System.out.println(\"execute方法执行之后拦截...\"); return result; &#125;&#125; 值得注意的是，虽然beforeResule()方法中也可获得ActionInvocation实例，但千万不可通过该实例再次调用invoke()方法，如果再次调用invoke()方法，将会再次执行Action处理，Action处理后紧跟beforeResule()方法……这样会陷入死循环。 覆盖拦截器栈里特定拦截器的参数 如果需要覆盖拦截器栈里特定拦截器的参数，则在定义&lt;param&gt;元素的name属性时使用：&lt;拦截器名&gt;.&lt;参数名&gt; 代码示例 123456789101112131415161718192021222324252627&lt;interceptors&gt; &lt;interceptor name=\"mySimple\" class=\"org.crazyit.app.interceptor.BeforeResultInterceptor\"&gt; &lt;!-- 为拦截器指定参数值 --&gt; &lt;param name=\"name\"&gt;简单拦截器&lt;/param&gt; &lt;/interceptor&gt; &lt;interceptor name=\"second\" class=\"org.crazyit.app.interceptor.SecondInterceptor\"/&gt; &lt;interceptor-stack name=\"myStack\"&gt; &lt;interceptor-ref name=\"mySimple\"&gt; &lt;!-- 为拦截器指定参数值 --&gt; &lt;param name=\"name\"&gt;第一个&lt;/param&gt; &lt;/interceptor-ref&gt; &lt;interceptor-ref name=\"second\"&gt; &lt;!-- 为拦截器指定参数值 --&gt; &lt;param name=\"name\"&gt;第二个&lt;/param&gt; &lt;/interceptor-ref&gt; &lt;/interceptor-stack&gt;&lt;/interceptors&gt;&lt;action name=\"login\" class=\"org.crazyit.app.action.LoginAction\"&gt; &lt;result name=\"error\"&gt;/WEB-INF/content/eeor.jsp&lt;/result&gt; &lt;result name=\"success\"&gt;/WEB-INF/content/welcome.jsp&lt;/result&gt; &lt;!-- 配置系统的默认拦截器 --&gt; &lt;interceptor-ref name=\"defaultStack\"&gt;&lt;/interceptor-ref&gt; &lt;interceptor-ref name=\"myStack\"&gt; &lt;!-- 覆盖指定拦截器的指定参数值 --&gt; &lt;param name=\"second.name\"&gt;改名后的拦截结果监听器&lt;/param&gt; &lt;/interceptor-ref&gt;&lt;/action&gt; 使用拦截器完成权限控制 登录权限案例实现: 拦截代码的实现 1234567891011121314151617181920//权限检查拦截器继承 AbstractInterceptorpublic class AuthorityInterceptor extends AbstractInterceptor&#123; //拦截Action处理的拦截方法 @Override public String intercept(ActionInvocation invocation) throws Exception &#123; //取得请求相关的ActionContext实例 ActionContext ctx=invocation.getInvocationContext(); Map session=ctx.getSession(); //取出session里的user属性 String user=(String) session.get(\"user\"); //如果没有登录，或者登录的用户名不是crazyit.org，都返回登录 if(user!=null &amp;&amp; user.equals(\"crazyit.org\")) &#123; invocation.invoke(); &#125; ctx.put(\"tip\",\"您还没有登录\"); return Action.LOGIN; &#125; &#125; 配置文件中进行配置 1234567891011121314151617181920212223242526272829&lt;!-- 用户拦截器定义在该元素下 --&gt;&lt;interceptors&gt; &lt;!-- 定义了一个名为authority的拦截器 --&gt; &lt;interceptor name=\"authority\" class=\"org.crazyit.app.interceptor.AuthorityInterceptor\"/&gt;&lt;/interceptors&gt;&lt;!-- 定义全局Result --&gt;&lt;global-results&gt; &lt;!-- 当返回login视图名时，转入loginForm.jsp页面 --&gt; &lt;result name=\"login\"&gt;/WEB-INF/content/loginForm.jsp&lt;/result&gt;&lt;/global-results&gt;&lt;action name=\"login\" class=\"org.crazyit.app.action.LoginAction\"&gt; &lt;result name=\"error\"&gt;/WEB-INF/content//error.jsp&lt;/result&gt; &lt;result&gt;/WEB-INF/content/welcome.jsp&lt;/result&gt;&lt;/action&gt;&lt;!-- 定义一个名为viewBook的Action，其实现类为ActionSupport --&gt;&lt;action name=\"viewBook\"&gt; &lt;!-- 返回success视图名时，转入viewBook.jsp页面 --&gt; &lt;result&gt;/WEB-INF/content/viewBook.jsp&lt;/result&gt; &lt;interceptor-ref name=\"defaultStack\"/&gt; &lt;!-- 应用自定义拦截器 --&gt; &lt;interceptor-ref name=\"authority\"/&gt;&lt;/action&gt;&lt;action name=\"*\"&gt; &lt;result&gt;/WEB-INF/content/&#123;1&#125;.jsp&lt;/result&gt;&lt;/action&gt; 使用Struts2的ajax支持使用Stream类型的Result实现Ajax 案例实现1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib prefix=\"s\" uri=\"/struts-tags\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;使用JSON插件&lt;/title&gt;&lt;script type=\"text/javascript\" src=\"$&#123;pageContext.request.contextPath&#125;/jquery-3.2.1.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;s:form id=\"loginForm\"&gt; &lt;s:textfield name=\"user\" label=\"用户名\"&gt;&lt;/s:textfield&gt; &lt;s:textfield name=\"pass\" label=\"密码\"&gt;&lt;/s:textfield&gt; &lt;tr&gt; &lt;td colspan=\"2\"&gt; &lt;input id=\"loginBn\" type=\"button\" value=\"提交\"/&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/s:form&gt; &lt;div id=\"show\" style=\"display:none\"&gt;&lt;/div&gt; &lt;script type=\"text/javascript\"&gt; $(\"#loginBn\").click(function()&#123; $.get(\"login\",$(\"#loginForm\").serializeArray(), function(data,statusText)&#123; $(\"#show\").height(80) .width(230) .css(\"border\",\"1px solid black\") .css(\"border-radius\",\"15px\") .css(\"background-color\",\"#efef99\") .css(\"color\",\"#ff0000\") .css(\"padding\",\"20px\") .empty(); $(\"#show\").append(\"登录结果：\"+data+\"&lt;br/&gt;\"); $(\"#show\").show(600); &#125;,\"html\" ) &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920212223242526package org.crazyit.app.action;import java.io.ByteArrayInputStream;import java.io.InputStream;import com.opensymphony.xwork2.Action;public class LoginAction implements Action&#123; //封装请求参数的两个成员变量 private String user; private String pass; //封装输出结果二进制流 private InputStream inputStream; public InputStream getResult() &#123; return this.inputStream; &#125; //此处省略了setter和getter @Override public String execute() throws Exception &#123; //判断用户名和密码，生成响应 inputStream=(getUser().equals(\"crazyit.org\") &amp;&amp; getPass().equals(\"leegang\"))? new ByteArrayInputStream(\"恭喜你！登录成功\".getBytes(\"UTF-8\")):new ByteArrayInputStream(\"对不起，用户名，密码不匹配。\".getBytes(\"UTF-8\")); return SUCCESS; &#125; &#125; 12345678&lt;action name=\"login\" class=\"org.crazyit.app.action.LoginAction\"&gt; &lt;result type=\"stream\"&gt; &lt;!-- 指定stream生成的响应数据的类型 --&gt; &lt;param name=\"contentType\"&gt;text/html&lt;/param&gt; &lt;!-- 指定由getResult()返回输出结果的InputStream --&gt; &lt;param name=\"inputName\"&gt;result&lt;/param&gt; &lt;/result&gt;&lt;/action&gt; 除此之外，Strust2还提供了一个JSON插件，通过该插件可以更简单的完成Ajax。 JSON的基本知识 JSON主要有如下两种格式： key-value 有序集合 在Javascript中主要有两种JSON语法，一种用于创建对象，另一种用于创建数组。 使用JSON语法创建对象 语法格式如下： 123456789101112131415161718192021222324252627var object=&#123; propertyName1:propertyValue1, propertyName2:propertyValue2&#125;function Person(name,sex)&#123; this.name=name; this.sex=sex;&#125;var p=new Person(\"kk\",\"man\");alert(p.name)var p2=&#123;\"name\":\"yeeku\",\"age\":12&#125;console.log(p2.age)var p3=&#123; name:\"yeeku\", sex:\"man\", son:&#123; name:'nono', grade:1 &#125;, info:function()&#123; console.log(\"姓名：\"+this.son.name+\" 年龄：\"+this.son.grade) &#125;&#125;p3.info(); 使用JSON语法创建数组 使用教程如下 1234567891011//创建数组 方式1var a=new Array();a[0]='yeeku';a[1]='man';alert(a[0])//创建数组 方式2var b=new Array(\"yeeku\",\"man\");alert(b[1]);//创建数组 方式3var c=['yeeu','name'];alert(c[0]) 使用JSON创建数组的语法格式:arr=[value1,value2] 实现Action逻辑1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package org.crazyit.app.action;import java.util.HashMap;import java.util.Map;import org.apache.struts2.json.annotations.JSON;import com.opensymphony.xwork2.Action;public class JSONExample &#123; //模拟处理结果的成员变量 private int[] ints= &#123;10,20&#125;; private Map&lt;String,String&gt; map=new HashMap&lt;String, String&gt;(); private String customName=\"顾客\"; //封装请求参数的三个成员变量 private String field1; //`transient`修饰的成员变量不会被序列化 private transient String field2; //没有getter和setter方法的成员变量不会被序列化 private String field3; public String execute()&#123; map.put(\"name\", \"疯狂Java讲义\"); return Action.SUCCESS; &#125; //使用注解来改变该成员变量序列化后的名字 @JSON(name=\"newName\") public Map getMap() &#123; return this.map; &#125; // customName的setter和getter方法 public void setCustomName(String customName) &#123; this.customName = customName; &#125; public String getCustomName() &#123; return this.customName; &#125; // field1的setter和getter方法 public void setField1(String field1) &#123; this.field1 = field1; &#125; public String getField1() &#123; return this.field1; &#125; // field2的setter和getter方法 public void setField2(String field2) &#123; this.field2 = field2; &#125; public String getField2() &#123; return this.field2; &#125; // field3的setter和getter方法 public void setField3(String field3) &#123; this.field3 = field3; &#125; public String getField3() &#123; return this.field3; &#125; &#125; JSON插件与json类型的Result12345678910&lt;action name=\"JSONExample\" class=\"org.crazyit.app.action.JSONExample\"&gt; &lt;result type=\"json\"&gt; &lt;!-- 配置类型的json的Result --&gt; &lt;!-- 为该Result指定参数 --&gt; &lt;param name=\"noCache\"&gt;true&lt;/param&gt; &lt;param name=\"contentType\"&gt;text/html&lt;/param&gt; &lt;!-- 设置只序列Action的map属性 --&gt; &lt;!-- param name=\"root\"&gt;map&lt;/param --&gt; &lt;/result&gt;&lt;/action&gt; 实现JSP页面12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib prefix=\"s\" uri=\"/struts-tags\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;使用JSON插件&lt;/title&gt;&lt;script type=\"text/javascript\" src=\"$&#123;pageContext.request.contextPath&#125;/jquery-3.2.1.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;s:form id=\"form1\"&gt; &lt;s:textfield name=\"field1\" label=\"Field 1\"/&gt; &lt;s:textfield name=\"field2\" label=\"Field 2\"/&gt; &lt;s:textfield name=\"field3\" label=\"Field 3\"/&gt; &lt;tr&gt;&lt;td colspan=\"2\"&gt; &lt;input type=\"button\" value=\"提交\" onclick=\"gotClick();\"/&gt; &lt;/td&gt;&lt;/tr&gt; &lt;/s:form&gt; &lt;div id=\"show\"&gt;&lt;/div&gt; &lt;script type=\"text/javascript\"&gt; function gotClick()&#123; console.log(1) $(\"#show\").hide(); // 指定向JSONExample发送请求，将id为form1的表单所包含的表单控件转换为请求参数 $.post(\"JSONExample\" , $(\"#form1\").serializeArray() , // 指定回调函数 function(data , statusText) &#123; console.log(data) console.log(statusText) $(\"#show\").height(120) .width(340) .css(\"border\" , \"1px solid black\") .css(\"border-radius\" , \"15px\") .css(\"background-color\" , \"#efef99\") .css(\"color\" , \"#ff0000\") .css(\"padding\" , \"20px\") .empty(); // 遍历JavaScript对象的各属性 for(var propName in data) &#123; $(\"#show\").append(propName + \"--&gt;\" + data[propName] + \"&lt;br /&gt;\"); &#125; $(\"#show\").show(600); &#125;, // 指定服务器响应为JSON数据 \"json\"); &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;","categories":[],"tags":[]},{"title":"Java邮箱接口","slug":"Java邮箱接口","date":"2019-09-25T07:52:14.000Z","updated":"2019-09-25T08:12:16.918Z","comments":true,"path":"2019/09/25/Java邮箱接口/","link":"","permalink":"https://CPWS.github.io/2019/09/25/Java邮箱接口/","excerpt":"","text":"邮箱的相关标准 常见的邮件协议 SMTP（Simple Mail Transfer Protocol）：即简单邮箱传输协议，它是一组用于源地址到目的地址传送邮件的规则，由它来控制信息的中转方式。 POP3（Post Office Protocol - Version 3）: 即邮局协议版本 3，用于接收电子邮件的标准协议。","categories":[],"tags":[]},{"title":"Struts2.5","slug":"Struts2-5","date":"2019-09-17T08:17:50.000Z","updated":"2019-09-29T11:18:30.866Z","comments":true,"path":"2019/09/17/Struts2-5/","link":"","permalink":"https://CPWS.github.io/2019/09/17/Struts2-5/","excerpt":"","text":"Struts2的下载和安装 为Web应用增加的Struts支持 下载和安装Struts2的步骤如下: 登录https://struts.apache.org/download.cgi#struts2520站点，下载Struts2的最新包2.5.20。 进入Struts2的解压目录的lib目录下，将一些相关的jar包导入到Web用于的/web-inf/lib路径下。 编写Web应用的web.xml配置文件，配置Struts2的核心Filter。 12345678910111213141516171819202122&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://java.sun.com/xml/ns/javaee\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd\" version=\"3.0\"&gt; &lt;display-name&gt;Struts_studyByBook01&lt;/display-name&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;welcome-file&gt;default.html&lt;/welcome-file&gt; &lt;welcome-file&gt;default.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;default.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;!-- 定义Struts2的核心Filter --&gt; &lt;filter&gt; &lt;filter-name&gt;Struts2&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.struts2.dispatcher.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;!-- 让Strut2 的核心标签库Filter拦截所有的请求 --&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;Struts2&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt; 将Struts2解压目录下的apps目录下的struts2-rest-showcase.war压缩包的struts.xml配置文件复制到web应用的src目录下。并将该配置文件修改为如下格式： 1234567891011&lt;struts&gt; &lt;!-- Overwrite Convention --&gt; &lt;constant name=\"struts.enable.DynamicMethodInvocation\" value=\"false\"/&gt; &lt;constant name=\"struts.devMode\" value=\"true\"/&gt; &lt;!-- Uncomment the lines below to use Jackson XML bindings instead of the XStream library to handle XML serialisations --&gt; &lt;package name=\"crazyit\" namespace=\"/\" extends=\"struts-default\"&gt; &lt;action name=\"*\"&gt; &lt;result&gt;/WEB-INF/content/&#123;1&#125;.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; 在Eclipse使用Struts2 首先创建一个Dynamic Web Project,也就是创建一个动态web项目。 在项目的/webcontent/WEB-INF/lib导入一些响相应的jar包。类型参考上面第2点。 打开/webcontent/WEB-INF/web.xml，编译该文件，并在其中定义Struts2核心的Filter。 在项目的src目录下定义一个struts.xml配置文件，其内容参考上面第四点。 至此，该Web应用完全具备了Struts2框架的支持。 增加登录处理 创建一个Strut2Demo的动态web项目，并且按上面的步骤依次导入相关的jar包、配置web.xml、配置struts.xml。 在/webcontent/WEB-INF/content/下添加一个名为loginForm的JSP页面,该页面的代码如下： 1234567891011121314151617&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@taglib prefix=\"s\" uri=\"/struts-tags\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;&lt;s:text name=\"loginPage\"&gt;&lt;/s:text&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;s:form action=\"login\"&gt; &lt;s:textfield name=\"username\" key=\"user\"&gt;&lt;/s:textfield&gt; &lt;s:textfield name=\"password\" key=\"pass\"&gt;&lt;/s:textfield&gt; &lt;s:submit key=\"login\"&gt;&lt;/s:submit&gt; &lt;/s:form&gt;&lt;/body&gt;&lt;/html&gt; 除此之外，还要添加一个welcome.jsp和error.jsp作为登录成功，登录失败的提示页面，它们的代码如下： 12345678910111213141516&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@taglib prefix=\"s\" uri=\"/struts-tags\"%&gt;&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt; &lt;title&gt;&lt;s:text name=\"succPage\"/&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!--成功界面--&gt; &lt;s:text name=\"succTip\"&gt; &lt;s:param&gt;$&#123;sessionScope.user&#125;&lt;/s:param&gt; &lt;/s:text&gt;&lt;br/&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314&lt;%@page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@taglib prefix=\"s\" uri=\"/struts-tags\"%&gt;&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt; &lt;title&gt;&lt;s:text name=\"errorPage\"/&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!--失败界面--&gt; &lt;s:text name=\"failTip\"/&gt;&lt;/body&gt;&lt;/html&gt; 配置Struts.xml文件 1234567891011121314&lt;struts&gt; &lt;!-- Overwrite Convention --&gt; &lt;!-- 指定全局国际化资源文件 --&gt; &lt;constant name=\"struts.enable.DynamicMethodInvocation\" value=\"false\"/&gt; &lt;constant name=\"struts.custom.i18n.resources\" value=\"mess\"/&gt; &lt;constant name=\"struts.devMode\" value=\"true\"&gt;&lt;/constant&gt; &lt;!-- Uncomment the lines below to use Jackson XML bindings instead of the XStream library to handle XML serialisations --&gt; &lt;!-- 所有的Action定义都应方法package包下 --&gt; &lt;package name=\"loginForm\" namespace=\"/\" extends=\"struts-default\"&gt; &lt;action name=\"*\"&gt; &lt;result&gt;/WEB-INF/content/&#123;1&#125;.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; 由于上面已经指定了国际化资源，所以在src目录还应该提供一个名为mess_zh_CN.properties的文件，其内容为： loginPage=登录页面 errorPage=错误页面 succPage=成功页面 failTip=对不起，您不能登录！ succTip=欢迎，{0}，您已经登录！ user=用户名 pass=密码 login=登录 把项目部署到Tomcat服务器，并在浏览器的地址栏上输入 http://localhost:8080/Strust2Demo/LoginForm，将会看到登录界面。 在Eclipse工具创建一个Java类，该Java类的类名为LoginAction，代码如下 123456789101112131415161718192021222324252627282930313233343536package org.crazyit.app.action;import com.opensymphony.xwork2.ActionContext;import com.opensymphony.xwork2.ActionSupport;public class LoginAction extends ActionSupport &#123; private static final long serialVersionUID = 1L; //定义封装请求参数的username和password成员变量 private String username; private String password; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; //定义处理用户请求的execute方法 public String execute() &#123; System.out.println(getUsername() + \"--&gt;\" + getPassword()); //当username为crazyit.org,password为leegang时即登录成功 if(getUsername().equals(\"crazyit.org\") &amp;&amp; getPassword().equals(\"leegang\")) &#123; //采用解耦的方法获取session对象 ActionContext.getContext().getSession().put(\"user\",getUsername()); return SUCCESS; &#125; return ERROR; &#125; &#125; 在struts.xml中添加一个name=&quot;login&quot;&lt;action.../&gt;代码如下： 12345&lt;action name=\"login\" class=\"org.crazyit.app.action.LoginAction\"&gt; &lt;!-- 定义三个逻辑视图和物理资源之间进行映射 --&gt; &lt;result name=\"success\"&gt;/WEB-INF/content/welcome.jsp&lt;/result&gt; &lt;result name=\"error\"&gt;/WEB-INF/content/error.jsp&lt;/result&gt;&lt;/action&gt; 至此，整个Struts2的应用已经创建完成，再次重启服务器，然后先访问loginForm，并在该页面输入用户名和密码进行登录，如果为crazyit.org、leegang，则跳转到welcome.jsp页面，否则则跳转到error.jsp。 Struts2的流程 Struts2应用的开发步骤 在web.xml文件中定义核心的Filter来拦截用户请求。 如果需要以POST的方式提交请求，则定义包含表单数据的JSP页面。如果仅仅是以GET方法发送请求，则无需通过这一步。 定义处理用户请求的Action类。 配置Action 配置处理结果和物理视图资源之间的对应关系。 编写视图资源。如果Action需要将一些数据传给视图资源，则可以借助于OGNL表达式。 经过上面6个步骤，基本完成一个Struts2的处理流程的开发，也就是可以执行一次完整的请求--&gt;响应过程。 Struts2的运行流程 Struts2的常规配置 虽然Struts2提供了Convention插件来管理Action，结果映射，但对于大部分实际开发来说还会考虑使用XML配置文件来管理Struts2的配置信息。 Struts2的默认配置文件名为struts.xml，该文件放在web应用的类加载器路径下，通常就是方法WEB-INF/classes路径下。 struts.xml配置文件的最大作用就是配置Action与请求之间的对应关系，并配置逻辑视图名与物理视图资源的对应关系，除此之外，struts.xml文件还有一些额外的配置，例如Bean配置，配置常量以及导入其他配置文件等。 常量配置 Strut2还提供了struts.properties文件来管理常量 struts.properties是一个标准的properties文件，该文件包含了系列key-value，每个key对应一个Struts2常量，该key对应的value值就是一个Struts2常量值。 Struts2配置常量总共有三种方式： 通过struts.properties文件 通过struts.xml文件 通过web.xml文件 如下struts.xml配置片段在struts.xml文件中配置一个常量，该常量即可代替struts.properties文件中struts2配置属性。 1234567891011121314151617181920212223&lt;!DOCTYPE struts PUBLIC \"-//Apache Software Foundation//DTD Struts Configuration 2.5//EN\" \"http://struts.apache.org/dtds/struts-2.5.dtd\"&gt;&lt;struts&gt; &lt;!-- Overwrite Convention --&gt; &lt;!-- 指定全局国际化资源文件 --&gt; &lt;constant name=\"struts.enable.DynamicMethodInvocation\" value=\"false\"/&gt; &lt;constant name=\"struts.custom.i18n.resources\" value=\"mess\"/&gt; &lt;constant name=\"struts.devMode\" value=\"true\"&gt;&lt;/constant&gt; &lt;!-- Uncomment the lines below to use Jackson XML bindings instead of the XStream library to handle XML serialisations --&gt; &lt;!-- 所有的Action定义都应方法package包下 --&gt; &lt;package name=\"loginForm\" namespace=\"/\" extends=\"struts-default\"&gt; &lt;action name=\"*\"&gt; &lt;result&gt;/WEB-INF/content/&#123;1&#125;.jsp&lt;/result&gt; &lt;/action&gt; &lt;action name=\"login\" class=\"org.crazyit.app.action.LoginAction\"&gt; &lt;!-- 定义三个逻辑视图和物理资源之间进行映射 --&gt; &lt;result name=\"success\"&gt;/WEB-INF/content/welcome.jsp&lt;/result&gt; &lt;result name=\"error\"&gt;/WEB-INF/content/error.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; 在web.xml配置文件中配置常量 12345678910111213&lt;filter&gt; &lt;filter-name&gt;Struts2&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.struts2.dispatcher.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;struts.custom.i18n.resources&lt;/param-name&gt; &lt;param-value&gt;mess&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;!-- 让Strut2 的核心标签库Filter拦截所有的请求 --&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;Struts2&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 包含其他配置文件 下面的struts.xml文件就通过&lt;include ../&gt;手动导入一个配置文件。 1&lt;include file=\"struts-part1.xml\"&gt;&lt;/include&gt; 被包含的配置文件应该也包含dtd信息和struts根元素等信息，且该配置文件也应该放在WEB-INF/classes/路径下。 实现Action Action类默认处理用户请求的方法：execute方法。 Action接口和ActionSupport基类 下面是一个标准的Action接口代码 1234567891011package com.opensymphony.xwork2;public interface Action &#123; public static final String SUCCESS = \"success\"; public static final String NONE = \"none\"; public static final String ERROR = \"error\"; public static final String INPUT = \"input\"; public static final String LOGIN = \"login\"; public String execute() throws Exception;&#125; 下面是ActionSupport实现类的片段代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327/* * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */package com.opensymphony.xwork2;import com.opensymphony.xwork2.inject.Container;import com.opensymphony.xwork2.inject.Inject;import com.opensymphony.xwork2.interceptor.ValidationAware;import com.opensymphony.xwork2.util.ValueStack;import org.apache.logging.log4j.LogManager;import org.apache.logging.log4j.Logger;import org.apache.struts2.StrutsConstants;import java.io.Serializable;import java.util.*;/** * Provides a default implementation for the most common actions. * See the documentation for all the interfaces this class implements for more detailed information. */public class ActionSupport implements Action, Validateable, ValidationAware, TextProvider, LocaleProvider, Serializable &#123; private static final Logger LOG = LogManager.getLogger(ActionSupport.class); private final ValidationAwareSupport validationAware = new ValidationAwareSupport(); private transient TextProvider textProvider; private transient LocaleProvider localeProvider; protected Container container; public void setActionErrors(Collection&lt;String&gt; errorMessages) &#123; validationAware.setActionErrors(errorMessages); &#125; public Collection&lt;String&gt; getActionErrors() &#123; return validationAware.getActionErrors(); &#125; public void setActionMessages(Collection&lt;String&gt; messages) &#123; validationAware.setActionMessages(messages); &#125; public Collection&lt;String&gt; getActionMessages() &#123; return validationAware.getActionMessages(); &#125; public void setFieldErrors(Map&lt;String, List&lt;String&gt;&gt; errorMap) &#123; validationAware.setFieldErrors(errorMap); &#125; public Map&lt;String, List&lt;String&gt;&gt; getFieldErrors() &#123; return validationAware.getFieldErrors(); &#125; @Override public Locale getLocale() &#123; return getLocaleProvider().getLocale(); &#125; @Override public boolean isValidLocaleString(String localeStr) &#123; return getLocaleProvider().isValidLocaleString(localeStr); &#125; @Override public boolean isValidLocale(Locale locale) &#123; return getLocaleProvider().isValidLocale(locale); &#125; public boolean hasKey(String key) &#123; return getTextProvider().hasKey(key); &#125; public String getText(String aTextName) &#123; return getTextProvider().getText(aTextName); &#125; public String getText(String aTextName, String defaultValue) &#123; return getTextProvider().getText(aTextName, defaultValue); &#125; public String getText(String aTextName, String defaultValue, String obj) &#123; return getTextProvider().getText(aTextName, defaultValue, obj); &#125; public String getText(String aTextName, List&lt;?&gt; args) &#123; return getTextProvider().getText(aTextName, args); &#125; public String getText(String key, String[] args) &#123; return getTextProvider().getText(key, args); &#125; public String getText(String aTextName, String defaultValue, List&lt;?&gt; args) &#123; return getTextProvider().getText(aTextName, defaultValue, args); &#125; public String getText(String key, String defaultValue, String[] args) &#123; return getTextProvider().getText(key, defaultValue, args); &#125; public String getText(String key, String defaultValue, List&lt;?&gt; args, ValueStack stack) &#123; return getTextProvider().getText(key, defaultValue, args, stack); &#125; public String getText(String key, String defaultValue, String[] args, ValueStack stack) &#123; return getTextProvider().getText(key, defaultValue, args, stack); &#125; /** * Dedicated method to support I10N and conversion errors * * @param key message which contains formatting string * @param expr that should be formatted * @return formatted expr with format specified by key */ public String getFormatted(String key, String expr) &#123; Map&lt;String, Object&gt; conversionErrors = ActionContext.getContext().getConversionErrors(); if (conversionErrors.containsKey(expr)) &#123; String[] vals = (String[]) conversionErrors.get(expr); return vals[0]; &#125; else &#123; final ValueStack valueStack = ActionContext.getContext().getValueStack(); final Object val = valueStack.findValue(expr); return getText(key, Arrays.asList(val)); &#125; &#125; public ResourceBundle getTexts() &#123; return getTextProvider().getTexts(); &#125; public ResourceBundle getTexts(String aBundleName) &#123; return getTextProvider().getTexts(aBundleName); &#125; public void addActionError(String anErrorMessage) &#123; validationAware.addActionError(anErrorMessage); &#125; public void addActionMessage(String aMessage) &#123; validationAware.addActionMessage(aMessage); &#125; public void addFieldError(String fieldName, String errorMessage) &#123; validationAware.addFieldError(fieldName, errorMessage); &#125; public String input() throws Exception &#123; return INPUT; &#125; /** * A default implementation that does nothing an returns \"success\". * * &lt;p&gt; * Subclasses should override this method to provide their business logic. * &lt;/p&gt; * * &lt;p&gt; * See also &#123;@link com.opensymphony.xwork2.Action#execute()&#125;. * &lt;/p&gt; * * @return returns &#123;@link #SUCCESS&#125; * @throws Exception can be thrown by subclasses. */ public String execute() throws Exception &#123; return SUCCESS; &#125; public boolean hasActionErrors() &#123; return validationAware.hasActionErrors(); &#125; public boolean hasActionMessages() &#123; return validationAware.hasActionMessages(); &#125; public boolean hasErrors() &#123; return validationAware.hasErrors(); &#125; public boolean hasFieldErrors() &#123; return validationAware.hasFieldErrors(); &#125; /** * Clears field errors. Useful for Continuations and other situations * where you might want to clear parts of the state on the same action. */ public void clearFieldErrors() &#123; validationAware.clearFieldErrors(); &#125; /** * Clears action errors. Useful for Continuations and other situations * where you might want to clear parts of the state on the same action. */ public void clearActionErrors() &#123; validationAware.clearActionErrors(); &#125; /** * Clears messages. Useful for Continuations and other situations * where you might want to clear parts of the state on the same action. */ public void clearMessages() &#123; validationAware.clearMessages(); &#125; /** * Clears all errors. Useful for Continuations and other situations * where you might want to clear parts of the state on the same action. */ public void clearErrors() &#123; validationAware.clearErrors(); &#125; /** * Clears all errors and messages. Useful for Continuations and other situations * where you might want to clear parts of the state on the same action. */ public void clearErrorsAndMessages() &#123; validationAware.clearErrorsAndMessages(); &#125; /** * A default implementation that validates nothing. * Subclasses should override this method to provide validations. */ public void validate() &#123; &#125; @Override public Object clone() throws CloneNotSupportedException &#123; return super.clone(); &#125; /** * &lt;!-- START SNIPPET: pause-method --&gt; * Stops the action invocation immediately (by throwing a PauseException) and causes the action invocation to return * the specified result, such as &#123;@link #SUCCESS&#125;, &#123;@link #INPUT&#125;, etc. * * &lt;p&gt; * The next time this action is invoked (and using the same continuation ID), the method will resume immediately * after where this method was called, with the entire call stack in the execute method restored. * &lt;/p&gt; * * &lt;p&gt; * Note: this method can &lt;b&gt;only&lt;/b&gt; be called within the &#123;@link #execute()&#125; method. * &lt;/p&gt; * * &lt;!-- END SNIPPET: pause-method --&gt; * * @param result the result to return - the same type of return value in the &#123;@link #execute()&#125; method. */ public void pause(String result) &#123; &#125; /** * If called first time it will create &#123;@link com.opensymphony.xwork2.TextProviderFactory&#125;, * inject dependency (if &#123;@link com.opensymphony.xwork2.inject.Container&#125; is accesible) into in, * then will create new &#123;@link com.opensymphony.xwork2.TextProvider&#125; and store it in a field * for future references and at the returns reference to that field * * @return reference to field with TextProvider */ protected TextProvider getTextProvider() &#123; if (textProvider == null) &#123; Container container = getContainer(); TextProviderFactory tpf = container.getInstance(TextProviderFactory.class); textProvider = tpf.createInstance(getClass()); &#125; return textProvider; &#125; protected LocaleProvider getLocaleProvider() &#123; if (localeProvider == null) &#123; Container container = getContainer(); LocaleProviderFactory localeProviderFactory = container.getInstance(LocaleProviderFactory.class); localeProvider = localeProviderFactory.createLocaleProvider(); &#125; return localeProvider; &#125; /** * TODO: This a temporary solution, maybe we should consider stop injecting container into beans */ protected Container getContainer() &#123; if (container == null) &#123; container = ActionContext.getContext().getContainer(); if (container != null) &#123; boolean devMode = Boolean.parseBoolean(container.getInstance(String.class, StrutsConstants.STRUTS_DEVMODE)); if (devMode) &#123; LOG.warn(\"Container is null, action was created manually? Fallback to ActionContext\"); &#125; else &#123; LOG.debug(\"Container is null, action was created manually? Fallback to ActionContext\"); &#125; &#125; else &#123; LOG.warn(\"Container is null, action was created out of ActionContext scope?!?\"); &#125; &#125; return container; &#125; @Inject public void setContainer(Container container) &#123; this.container = container; &#125;&#125; Action访问ServletAPI Struts2还提供了一个ActionContext类，Struts2通过该类来访问ServletAPI。下面是ActionContext类中包含的几个常用方法： Object get(Object ley)：该方法类似于调用HtppServletRequest的getAttribute(String name) Map getApplication()：返回一个Map对象，该对象模拟了该应用的ServletContext实例. static ActionContext getContext()：静态方法，获取系统的ActionContext实例。 Map getParameters()：获取所有的请求参数。类似于调用HttpServletRequest对象的getParametermap（）方法。 Map getSession()：返回一个Map对象，该Map对象模拟了HttpSession的实例。 void setApplication(Map application)：直接传入一个Map实例，将该Map实例里的key-value转换成application的属性名和属性值。 void setSession(Map session)：直接传入一个Map实例，将该Map实例里的key-value转换成session的属性名和属性值。 通过案例示范在rquest、session、application范围设置属性值12345678910111213141516171819202122&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://java.sun.com/xml/ns/javaee\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd\" version=\"3.0\"&gt; &lt;display-name&gt;Struts_studyByBook01&lt;/display-name&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;welcome-file&gt;default.html&lt;/welcome-file&gt; &lt;welcome-file&gt;default.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;default.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;!-- 定义Struts2的核心Filter --&gt; &lt;filter&gt; &lt;filter-name&gt;Struts2&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.struts2.dispatcher.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;!-- 让Strut2 的核心标签库Filter拦截所有的请求 --&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;Struts2&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt; 1234567891011121314151617&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib prefix=\"s\" uri=\"/struts-tags\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;&lt;s:text name=\"loginPage\"&gt;&lt;/s:text&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;s:form action=\"login\"&gt; &lt;s:textfield name=\"username\" key=\"user\"&gt;&lt;/s:textfield&gt; &lt;s:textfield name=\"password\" key=\"pass\"&gt;&lt;/s:textfield&gt; &lt;s:submit key=\"login\"&gt;&lt;/s:submit&gt; &lt;/s:form&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@taglib prefix=\"s\" uri=\"/struts-tags\"%&gt;&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt; &lt;title&gt;&lt;s:text name=\"succPage\"/&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; 本站访问的次数：$&#123;applicationScope.counter&#125;&lt;br&gt; $&#123;sessionScope.user&#125;，您已登录成功！ $&#123;requestScope.tip&#125;&lt;/body&gt;&lt;/html&gt; 12345678910111213&lt;%@page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@taglib prefix=\"s\" uri=\"/struts-tags\"%&gt;&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt; &lt;title&gt;&lt;s:text name=\"errorPage\"/&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; $&#123;sessionScope.user&#125;,$&#123;requestScope.tip&#125;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package org.crazyit.app.action;import com.opensymphony.xwork2.Action;import com.opensymphony.xwork2.ActionContext;public class LoginAction implements Action&#123; private String username; private String password; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; @Override public String execute() throws Exception &#123; ActionContext ctx=ActionContext.getContext(); //通过ActionContext访问application范围内的属性 Integer counter=(Integer) ctx.getApplication().get(\"counter\"); if(counter == null) &#123; counter=1; &#125;else &#123; counter = counter+1; &#125; //通过ActionContext设置application范围的属性 ctx.getApplication().put(\"counter\",counter); //通过ActionContext设置Session范围内的属性 ctx.getSession().put(\"user\",getUsername()); if(getUsername().equals(\"crazyit\") &amp;&amp; getPassword().equals(\"leegang\")) &#123; //通过ActionContext设置request范围内的属性 ctx.put(\"tip\", \"服务器提示，你已经成功登录\"); return SUCCESS; &#125; //通过ActionContext设置request范围内的属性 ctx.put(\"tip\", \"服务器提示，登录失败\"); return ERROR; &#125; &#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!--/* * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */--&gt;&lt;!-- 下面指定struts2配置文件的dtd信息 --&gt;&lt;!DOCTYPE struts PUBLIC \"-//Apache Software Foundation//DTD Struts Configuration 2.5//EN\" \"http://struts.apache.org/dtds/struts-2.5.dtd\"&gt;&lt;struts&gt; &lt;!-- Overwrite Convention --&gt; &lt;!-- 指定全局国际化资源文件 --&gt; &lt;constant name=\"struts.enable.DynamicMethodInvocation\" value=\"false\"/&gt; &lt;constant name=\"struts.custom.i18n.resources\" value=\"mess\"/&gt; &lt;constant name=\"struts.devMode\" value=\"true\"&gt;&lt;/constant&gt; &lt;!-- Uncomment the lines below to use Jackson XML bindings instead of the XStream library to handle XML serialisations --&gt; &lt;!-- 所有的Action定义都应方法package包下 --&gt; &lt;!-- package元素是struts2配置文件的核心，该元素可以出现0次或者无限次 --&gt; &lt;package name=\"loginForm\" namespace=\"/\" extends=\"struts-default\" &gt; &lt;action name=\"*\"&gt; &lt;result&gt;/WEB-INF/content/&#123;1&#125;.jsp&lt;/result&gt; &lt;/action&gt; &lt;action name=\"login\" class=\"org.crazyit.app.action.LoginAction\"&gt; &lt;!-- 处理结果返回为error,则对应于 /WEB-INF/content/error.jsp视图资源 --&gt; &lt;result name=\"error\"&gt; /WEB-INF/content/error.jsp&lt;/result&gt; &lt;!-- 处理结果返回为success,则对应于 /WEB-INF/content/welcome.jsp视图资源 --&gt; &lt;result name=\"success\"&gt; /WEB-INF/content/welcome.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; mess_zh_CN.properties的文件，其内容为： loginPage=登录页面 errorPage=错误页面 succPage=成功页面 failTip=对不起，您不能登录！ succTip=欢迎，{0}，您已经登录！ user=用户名 pass=密码 login=登录 从以上案列可以看出，Struts2的Action设计非常优秀，它既可以与ServletAPI解耦，也可以脱离Web容器运行，也可以脱离Web容器测试，又可以用简单的方式来操作request、session、application范围内的属性。 Action直接访问ServletAPI 虽然struts2提供了ActionContext来访问ServletAPI，但是这种访问毕竟不是直接获得Servlet API实例。为了在Action中直接访问ServletAPI，Struts2还提供如下几个接口：ServletContextAware：实现该接口的Action可以直接访问Web应用的ServletContext实例。ServletRequestAware：实现该接口的Action可以直接访问Web应用的HttpServletRequest实例。ServletResponseAware：实现该接口的Action可以直接访问Web应用的HttpServletResponse实例。 案列：以ServletResponseAware为例,如何在Action中访问HttpServletResponse123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172package org.crazyit.app.action;import javax.servlet.http.Cookie;import javax.servlet.http.HttpServletResponse;import org.apache.struts2.ServletActionContext;import org.apache.struts2.interceptor.ServletResponseAware;import com.opensymphony.xwork2.Action;import com.opensymphony.xwork2.ActionContext;/*** * 解耦方式 * @author 1huangzewei * */public class LoginAction02 implements Action,ServletResponseAware&#123; private String username; private String password; private HttpServletResponse response; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; //重写ServletResponseAware接口必须实现的方法 @Override public void setServletResponse(HttpServletResponse response) &#123; // TODO Auto-generated method stub this.response=response; &#125; @Override public String execute() throws Exception &#123; System.out.println(\"---- LoginAction2---\"); // TODO Auto-generated method stub ActionContext ctx=ActionContext.getContext(); //通过ActionContext访问application范围内的属性 Integer counter=(Integer) ctx.getApplication().get(\"counter\"); if(counter == null) &#123; counter=1; &#125;else &#123; counter = counter+1; &#125; //通过ActionContext设置application范围的属性 ctx.getApplication().put(\"counter\", counter); // 通过ActionContext设置Session范围内的属性 ctx.getSession().put(\"user\", getUsername()); if (getUsername().equals(\"crazyit\") &amp;&amp; getPassword().equals(\"leegang\")) &#123; //通过Response添加cookie Cookie c=new Cookie(\"user\", getUsername()); c.setMaxAge(60*60); response.addCookie(c); //通过ActionContext设置request范围的属性 ctx.put(\"tip\", \"服务器提示，你已经成功登录\"); return SUCCESS; &#125; // 通过ActionContext设置request范围内的属性 ctx.put(\"tip\", \"服务器提示，登录失败\"); return ERROR; &#125; &#125; 123456789101112131415&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@taglib prefix=\"s\" uri=\"/struts-tags\"%&gt;&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt; &lt;title&gt;&lt;s:text name=\"succPage\"/&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; 本站访问的次数：$&#123;applicationScope.counter&#125;&lt;br&gt; &lt;!-- $&#123;sessionScope.user&#125; --&gt;$&#123;user&#125;，您已登录成功！ $&#123;requestScope.tip&#125;&lt;/body&gt;&lt;/html&gt; ServletActionContext访问ServletAPI 除此之外，为了能直接访问ServletAPI，Struts2还提供了一个ServletActionContext工具类。该类包含如下几个静态方法： static PageContext getPageContext()：取得web应用的pageContext对象。 static HttpServletRequest getRequest()：取得web应用的request对象。 static HttpServletResponse getResponse()：取得web应用的response对象。 static ServletContext getServletContext()：取得web应用的ServletContext对象。 案列，以static HttpServletResponse getResponse()为例，获取response实例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package org.crazyit.app.action;import javax.servlet.http.Cookie;import javax.servlet.http.HttpServletResponse;import org.apache.struts2.ServletActionContext;import org.apache.struts2.interceptor.ServletResponseAware;import com.opensymphony.xwork2.Action;import com.opensymphony.xwork2.ActionContext;/*** * 解耦方式 * @author 1huangzewei * */public class LoginAction03&#123; private String username; private String password; private HttpServletResponse response; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; @Override public String execute() throws Exception &#123; System.out.println(\"---- LoginAction2---\"); // TODO Auto-generated method stub ActionContext ctx=ActionContext.getContext(); //通过ActionContext访问application范围内的属性 Integer counter=(Integer) ctx.getApplication().get(\"counter\"); if(counter == null) &#123; counter=1; &#125;else &#123; counter = counter+1; &#125; //通过ActionContext设置application范围的属性 ctx.getApplication().put(\"counter\", counter); // 通过ActionContext设置Session范围内的属性 ctx.getSession().put(\"user\", getUsername()); if (getUsername().equals(\"crazyit\") &amp;&amp; getPassword().equals(\"leegang\")) &#123; //通过Response添加cookie Cookie c=new Cookie(\"user\", getUsername()); c.setMaxAge(60*60); ServletActionContext().getResponse().addCookie(c); //通过ActionContext设置request范围的属性 ctx.put(\"tip\", \"服务器提示，你已经成功登录\"); return SUCCESS; &#125; // 通过ActionContext设置request范围内的属性 ctx.put(\"tip\", \"服务器提示，登录失败\"); return ERROR; &#125; &#125; 配置Action 实现了Action处理类之后，就可以在struts.xml文件中配置该Action了。配置Action就是让Struts2知道哪个Action处理哪个请求，也就是完成用户请求和Action之间的对应关系。 包和命名空间 定义&lt;package ../&gt;元素时可以指定如下几个元素： name：必须元素，该属性指定该包的名字，该名字是该包被其他包引用的key； extends：可选属性，该属性指定该包继承其他包。继承其他包，可以继承其他包中的Action定义、拦截器定义等。 namespace：可选元素。该属性定义该包的命名空间。 abstract：可选元素。它指定该包是否为抽象包。抽象包不能包含Action定义。 Action的基本配置 定义&lt;action ../ &gt;元素时可以指定如下几个元素： name：必须元素，该属性定义该action的名字，也定义了处理该请求的url class：非必须元素。用于指定action的实现类，如果没有定义该属性，系统则默认使用ActionSupport作为处理类。 method：非必须元素。该属性用于指定处理类中的业务处理方法的方法名，如果没有定义该属性，系统则默认使用execute。 配置Action时应该配置逻辑视图名与物理视图名之间的对应关系，而配置他们之间的映射关系，是通过&lt;result ../&gt;元素来完成。 使用Action的动态方法调用 动态方法调用采用如下方式:ActionName!method.action，其中actionName指定的是要提交到哪个Action，method指定的是交给哪个方法调用。 案列实现： 登录注册界面 123456789101112131415161718192021222324&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib prefix=\"s\" uri=\"/struts-tags\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;&lt;s:text name=\"loginPage\"&gt;&lt;/s:text&gt;&lt;/title&gt;&lt;script&gt; function regist()&#123; //获得第1个表单页面 targetForm=document.forms[0]; targetForm.action=\"login02!regist\" &#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=\"login02\"&gt; 用户名：&lt;input name=\"username\"/&gt;&lt;br/&gt; 密 码：&lt;input name=\"password\"/&gt;&lt;br/&gt; &lt;input type=\"submit\" value=\"登录\"/&gt;&lt;input type=\"submit\" value=\"注册\" onclick=\"regist();\"/&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 业务处理类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package org.crazyit.app.action;import com.opensymphony.xwork2.Action;import com.opensymphony.xwork2.ActionContext;import com.opensymphony.xwork2.ActionSupport;public class LoginRegisterAction extends ActionSupport&#123; //封装用户请求参数的两个成员变量 private String username; private String password; //封装处理结果的tip成员变量 private String tip; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public String getTip() &#123; return tip; &#125; public void setTip(String tip) &#123; this.tip = tip; &#125; //Action包含的注册控制逻辑 public String regist() &#123; System.out.println(\"------regist------\"); ActionContext.getContext().getSession().put(\"user\", getUsername()); setTip(\"恭喜您,\"+getUsername()+\"，您已经注册成功\"); return Action.SUCCESS; &#125; //Action包含的登录业务逻辑 public String execute() &#123; System.out.println(\"------login------\"); if(getUsername().equals(\"crazyit.org\") &amp;&amp; getPassword().equals(\"leegang\")) &#123; ActionContext.getContext().getSession().put(\"user\", getUsername()); setTip(\"欢迎,\"+getUsername()+\"，您已经登录成功\"); return Action.SUCCESS; &#125; return Action.ERROR; &#125;&#125; 配置文件 1234567891011121314151617181920212223&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!-- 下面指定struts2配置文件的dtd信息 --&gt;&lt;!DOCTYPE struts PUBLIC \"-//Apache Software Foundation//DTD Struts Configuration 2.5//EN\" \"http://struts.apache.org/dtds/struts-2.5.dtd\"&gt;&lt;struts&gt; &lt;!-- 指定全局国际化资源文件 --&gt; &lt;constant name=\"struts.enable.DynamicMethodInvocation\" value=\"true\"/&gt; &lt;constant name=\"struts.custom.i18n.resources\" value=\"mess\"/&gt; &lt;constant name=\"struts.devMode\" value=\"true\"&gt;&lt;/constant&gt; &lt;package name=\"loginForm\" namespace=\"/\" extends=\"struts-default\" &gt; &lt;action name=\"*\"&gt; &lt;result&gt;/WEB-INF/content/&#123;1&#125;.jsp&lt;/result&gt; &lt;/action&gt; &lt;action name=\"login02\" class=\"org.crazyit.app.action.LoginRegisterAction\"&gt; &lt;!-- 处理结果返回为error,则对应于 /WEB-INF/content/error.jsp视图资源 --&gt; &lt;result name=\"error\"&gt; /WEB-INF/content/error.jsp&lt;/result&gt; &lt;!-- 处理结果返回为success,则对应于 /WEB-INF/content/welcome.jsp视图资源 --&gt; &lt;result name=\"success\"&gt; /WEB-INF/content/welcome.jsp&lt;/result&gt; &lt;allowed-methods&gt;regist&lt;/allowed-methods&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; 成功页面 12345678910111213141516&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@taglib prefix=\"s\" uri=\"/struts-tags\"%&gt;&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt; &lt;title&gt;&lt;s:text name=\"succPage\"/&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 本站访问的次数：$&#123;applicationScope.counter&#125;&lt;br&gt; --&gt; &lt;!-- $&#123;sessionScope.user&#125; --&gt;$&#123;user&#125;，您已登录成功！ $&#123;sessionScope.tip&#125;&lt;/body&gt;&lt;/html&gt; 结果 指定Method属性及其通配符 在配置&lt;action ../&gt;元素时，允许在指定name使用模式字符串，接下来在method，class，以及&lt;result../&gt;子元素中使用{N}的形式来表示前面第N个所匹配的字符串。 在Action的name属性中使用模式通配符后，可以用一个&lt;action../&gt;代替多个逻辑Action。 注意：因为除非请求的URL与action与name属性绝对相同，否则将按先后顺序来决定由哪个action来处理用户请求。因此应该讲name=&quot;*&quot;的Action配置放在最后，否则，Struts2将使用该Action来处理所有希望使用模式字符串匹配的请求。 配置默认的Action与配置默认的处理类 默认Action：&lt;default-action-ref name=&quot;ActionName&quot; /&gt; 默认处理类：&lt;default-class-ref name=&quot;className&quot; /&gt; 配置处理结果 理解处理结果 Action处理完用户的请求后，并未把请求直接转发给任何具体的视图资源，而是返回一个逻辑视图（逻辑视图就是一个简单的字符串），Struts2框架收到这个逻辑视图，，把请求转发到具体的物理视图资源，然后把处理结果展示给用户看。 配置结果 Struts2框架在struts.xml文件中使用&lt;result../&gt;元素来配置结果。 配置&lt;result ../&gt;元素时需要指定如下两个属性: name：该属性指定所配置的逻辑视图名。 type：该属性指定结果类型。 Struts2支持的结果类型 plainText结果类型：将实际的视图资源的源代码显示到客户端浏览器上。 案例: Action实现类 1234567891011121314151617package org.crazyit.app.action;import com.opensymphony.xwork2.ActionSupport;public class LoginAction extends ActionSupport&#123; private static final long serialVersionUID = 1L; //用于封装请求的username private String username; //username属性的getter和setter public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; &#125; struts.xml配置文件 123456789101112131415161718192021&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE struts PUBLIC \"-//Apache Software Foundation//DTD Struts Configuration 2.5//EN\" \"http://struts.apache.org/dtds/struts-2.5.dtd\"&gt;&lt;struts&gt; &lt;constant name=\"struts.devMode\" value=\"true\"&gt;&lt;/constant&gt; &lt;package name=\"loginForm\" namespace=\"/\" extends=\"struts-default\"&gt; &lt;action name=\"*\"&gt; &lt;result&gt;/WEB-INF/content/&#123;1&#125;.jsp&lt;/result&gt; &lt;/action&gt; &lt;action name=\"login\" class=\"org.crazyit.app.action.LoginAction\"&gt; &lt;!-- 指定Result的类型为PlainText --&gt; &lt;result type=\"plainText\"&gt; &lt;!-- 指定实际的视图资源 --&gt; &lt;param name=\"location\"&gt;/WEB-INF/content/welcome.jsp&lt;/param&gt; &lt;!-- 指定使用指定字符串来处理页面代码 --&gt; &lt;param name=\"charSet\"&gt;UTF-8&lt;/param&gt; &lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; 结果页面 12345678910111213&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib prefix=\"s\" uri=\"/struts-tags\" %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;欢迎页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;s:property value=\"username\"/&gt;&lt;/body&gt;&lt;/html&gt; 效果图： 使用plainText结果类型可以指定如下两个参数 location：指定实际的视图资源。 charSet：指定输出页面是所使用的的字符集。 redirect结果类型: 使用该属性之后，会丢失所有的请求参数，请求属性，当然也丢失了action的处理结果。 案例：将上面的配置文件修改一下 1234567891011121314&lt;struts&gt; &lt;constant name=\"struts.devMode\" value=\"true\"&gt;&lt;/constant&gt; &lt;package name=\"loginForm\" namespace=\"/\" extends=\"struts-default\"&gt; &lt;action name=\"*\"&gt; &lt;result&gt;/WEB-INF/content/&#123;1&#125;.jsp&lt;/result&gt; &lt;/action&gt; &lt;action name=\"login\" class=\"org.crazyit.app.action.LoginAction\"&gt; &lt;!-- 指定Result的类型为PlainText --&gt; &lt;result type=\"redirect\"&gt; /welcome.jsp &lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; 配置一个redirect结果类型时，可以为其指定如下两个参数 location：该Action指定Action处理完用户请求后跳转的地址。 parse：该参数指定是否允许location参数值中使用表达式,默认值为 true; redirectAction结果类型 redirectAction实现在一个Action处理结束时，直接将请求重定向到里一个Action。 配置redirectAction结果类型时，可以指定如下两个参数: actionName：该参数指定重定向的Action名。 namespache：该参数指定需要重定向的Action所在的命名空间。 redirect与redirectAction，这两种结果都会产生新的请求，区别在于前者重定向的是实际视频的资源，后者重向定的是另一个Action，两种结果类型都会丢失前一个Action的请求参数，请求属性以及处理的结果。 动态结果 动态结果的含义是指在指定实际视图资源使用了表达式语法。Action属性值决定物理视图资源 配置&lt;result ../&gt;元素时，不仅可以使用${N}表达式来指定实际视图资源，还可以使用${属性名}方法来指定物理视图资源。 案例 业务处理类：MyAction.java 1234567891011121314151617181920package org.crazyit.app.action;import com.opensymphony.xwork2.ActionSupport;public class MyAction extends ActionSupport&#123; private static final long serialVersionUID = 1L; private String target; public String getTarget() &#123; return target; &#125; public void setTarget(String target) &#123; this.target = target; &#125; public String execute() &#123; addActionMessage(\"恭喜您，您已经成功转向!\"); return SUCCESS; &#125;&#125; 配置文件 struts.xml 123456789101112131415161718&lt;struts&gt; &lt;constant name=\"struts.devMode\" value=\"true\"&gt;&lt;/constant&gt; &lt;constant name=\"struts.enable.DynamicMethodInvocation\" value=\"true\"/&gt; &lt;constant name=\"struts.custom.i18n.resources\" value=\"mess\"/&gt; &lt;package name=\"shop\" namespace=\"/\" extends=\"struts-default\" &gt; &lt;action name=\"*\"&gt; &lt;result&gt;/WEB-INF/content/&#123;1&#125;.jsp&lt;/result&gt; &lt;/action&gt; &lt;action name=\"myAction\" class=\"org.crazyit.app.action.MyAction\"&gt; &lt;!-- 配置结果集时，采用OGNL表达式来指定实际视图资源 --&gt; &lt;result&gt;/WEB-INF/content/$&#123;target&#125;.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; JSP页面 ok.jsp 12345678910111213141516&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt; &lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;转向页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=\"myAction\" method=\"post\"&gt; 转入的目标页面：&lt;input type=\"text\" name=\"target\"/&gt;&lt;br/&gt; &lt;input type=\"submit\" value=\"转入\"/&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 成功页面:welcome.jsp 12345678910111213&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib prefix=\"s\" uri=\"/struts-tags\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;成功页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;s:actionmessage/&gt;&lt;/body&gt;&lt;/html&gt; 全局结果 配置全局结果可以采用&lt;global-result ../&gt;标签完成。全局结果集多所有的Action有效。使用PreResultListener PreResultListener是一个监听器接口，它可以在Action完成处理控制后，系统转入实际的物理视图之间被回调。 添加PreResultListener监听器通过Invocation的addPreResultListener()方法完成。 案例，在之前的项目中添加如下代码即可：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package org.crazyit.app.action;import com.opensymphony.xwork2.Action;import com.opensymphony.xwork2.ActionContext;import com.opensymphony.xwork2.ActionInvocation;import com.opensymphony.xwork2.ActionSupport;import com.opensymphony.xwork2.interceptor.PreResultListener;public class LoginRegisterAction extends ActionSupport&#123; private static final long serialVersionUID = 1L; //封装用户请求参数的两个成员变量 private String username; private String password; //封装处理结果的tip成员变量 private String tip; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public String getTip() &#123; return tip; &#125; public void setTip(String tip) &#123; this.tip = tip; &#125; //Action包含的注册控制逻辑 public String regist() &#123; System.out.println(\"------regist------\"); ActionContext.getContext().getSession().put(\"user\", getUsername()); setTip(\"恭喜您,\"+getUsername()+\"，您已经注册成功\"); return Action.SUCCESS; &#125; //Action包含的登录业务逻辑 public String execute() &#123; System.out.println(\"------login------\"); //添加PreResultListener接口监听器 ActionInvocation invocation=ActionContext.getContext().getActionInvocation(); invocation.addPreResultListener(new PreResultListener() &#123; @Override public void beforeResult(ActionInvocation invocation, String resultCode) &#123; // TODO Auto-generated method stub System.out.println(\"返回的逻辑视图名字为：\"+resultCode); //在返回Result之前加入一个额外的数据 invocation.getInvocationContext().put(\"extra\", new java.util.Date()+\"由\"+resultCode+\"逻辑视图名转入\"); &#125; &#125;); if(getUsername().equals(\"crazyit.org\") &amp;&amp; getPassword().equals(\"leegang\")) &#123; ActionContext.getContext().getSession().put(\"user\", getUsername()); setTip(\"欢迎,\"+getUsername()+\"，您已经登录成功\"); return Action.SUCCESS; &#125; return Action.ERROR; &#125;&#125; 配置Struts2的异常处理Struts2的异常处理机制 为了使用Struts2的异常处理机制，必须打开Struts2的异常映射功能,开启异常映射功能需要一个拦截器。下面是struts-default.xml文件中开启异常映射功能的配置文件。12345678&lt;interceptors&gt; &lt;interceptor name=\"exception\" class=\"com.opensymphony.xwork2.interceptor.ExceptionMappingInterceptor\"&gt;&lt;/interceptor&gt; &lt;!--Struts2默认的拦截器栈--&gt; &lt;interceprot-stack name=\"defaultStack\"&gt; &lt;interceptor-ref name=\"exception\" /&gt; &lt;/interceptor-stack&gt;&lt;/interceptors&gt; 声明式异常捕获 Struts2的异常处理机制是通过在struts.xml文件中配置&lt;exception-mapping ../&gt;元素完成的。配置该文件时，需要指定如下两个属性： exception：此属性指定该异常映射所映射所设置的异常类型。 result：此属性指定Action出现异常时，系统返回result属性值对应的逻辑视图名。 根据&lt;exception-mapping&gt;出现位置的不同，异常映射又可以分为如下两种： 局部异常映射：将&lt;exception-mapping&gt;作为Action的子元素配置。 全局异常映射：将&lt;exception-mapping&gt;作为&lt;global-exception-mappings&gt;的子元素配置。 案例123456789101112131415package org.crazyit.app.exception;public class MyException extends Exception&#123; /** * */ private static final long serialVersionUID = 1L; public MyException() &#123; super(); &#125; public MyException(String msg) &#123; super(msg); &#125;&#125; 123456789101112131415161718192021222324252627package org.crazyit.app.exception;import com.opensymphony.xwork2.ActionSupport;public class LoginAction extends ActionSupport&#123; private static final long serialVersionUID = 1L; //封装请求参数的username和password private String username; private String password; private String tip; ... public String execute() throws Exception&#123; System.out.println(\"exception\"); if(getUsername().equalsIgnoreCase(\"user\")) &#123; throw new MyException(\"自定义异常\"); &#125; if(getUsername().equalsIgnoreCase(\"sql\")) &#123; throw new java.sql.SQLException(\"用户名不能为sql\"); &#125; if(getUsername().equals(\"crazyit.org\") &amp;&amp; getPassword().equals(\"leegang\")) &#123; return SUCCESS; &#125; return ERROR; &#125;&#125; 1234567891011121314151617181920212223242526272829 &lt;!-- 配置全局结果集 --&gt;&lt;global-results&gt; &lt;result name=\"sql\"&gt;/WEB-INF/content/exception.jsp&lt;/result&gt; &lt;result name=\"root\"&gt;/WEB-INF/content/exception.jsp&lt;/result&gt;&lt;/global-results&gt; &lt;!-- 配置全局异常映射 --&gt;&lt;global-exception-mappings&gt; &lt;exception-mapping result=\"sql\" exception=\"java.sql.SQLException\"&gt;&lt;/exception-mapping&gt; &lt;exception-mapping result=\"root\" exception=\"java.lang.Exception\"&gt;&lt;/exception-mapping&gt;&lt;/global-exception-mappings&gt;&lt;action name=\"*\"&gt; &lt;result&gt;/WEB-INF/content/&#123;1&#125;.jsp&lt;/result&gt;&lt;/action&gt;&lt;action name=\"login\" class=\"org.crazyit.app.action.LoginAction02\"&gt;&lt;!-- 处理结果返回为error,则对应于 /WEB-INF/content/error.jsp视图资源 --&gt; &lt;result name=\"error\"&gt; /WEB-INF/content/error.jsp&lt;/result&gt; &lt;!-- 处理结果返回为success,则对应于 /WEB-INF/content/welcome.jsp视图资源 --&gt; &lt;result name=\"success\"&gt; /WEB-INF/content/welcome.jsp&lt;/result&gt;&lt;/action&gt;&lt;action name=\"login02\" class=\"org.crazyit.app.exception.LoginAction\"&gt; &lt;!-- 定义局部异常映射 --&gt; &lt;exception-mapping result=\"my\" exception=\"org.crazyit.app.exception.MyException\"&gt;&lt;/exception-mapping&gt; &lt;result name=\"my\"&gt;/my.jsp&lt;/result&gt; &lt;!-- 处理结果返回为error,则对应于 /WEB-INF/content/error.jsp视图资源 --&gt; &lt;result name=\"error\"&gt; /WEB-INF/content/error.jsp&lt;/result&gt; &lt;!-- 处理结果返回为success,则对应于 /WEB-INF/content/welcome.jsp视图资源 --&gt; &lt;result name=\"success\"&gt; /WEB-INF/content/welcome.jsp&lt;/result&gt; &lt;allowed-methods&gt;regist&lt;/allowed-methods&gt; &lt;/action&gt; 输出异常信息 为了在异常页面中显示异常信息，可以使用Struts2的如下标签来输出异常信息 &lt;s:property value=&quot;exception&quot;/&gt;：输出异常对象本身。 &lt;s:property value=&quot;exceptionStack&quot;/&gt;：输出异常堆本身。 还可以使用&lt;s:property value=&quot;exception.message&quot;/&gt;来输出异常message信息。 Convention插件与约定支持Action的搜索和映射约定 convention会把如下两种Java类当成Action类。 所有实现了com.opensymphony.xwork2.Action的Java类 所有类名以Action结尾的Java类。 按约定映射ResultAction链的约定自动重加载映射 Convention完全支持自动重载映射，只要为Struts2配置如下两个常量即可 配置Struts2处于开发者模式：&lt;constant name=&quot;struts.devMode&quot; value=&quot;true&quot;&gt;&lt;/constant&gt; 配置Convention插件自动重加载映射：&lt;constant name=&quot;struts.convention.classes.reloaad&quot; value=&quot;true&quot;&gt;&lt;/constant&gt; Convention插件的相关常量Convention插件的相关注解 使用Struts2的国际化 Struts2的国际化可以按照如下步骤进行： 让系统加载国际化资源文件。加载国家化资源文件有两种方式: 自动加载：Action范围的国际化资源文件，包范围的国家化资源文件由系统自动加载。 手动加载：JSP范围的国际化资源文件、全局范围的国际化资源文件，分别使用标签、配置常量的方式来手动加载。 输出国际化。Struts2输出国家化的消息同样有两种方式： 在视图页面上输出国家化消息，需要使用Struts2的标签库。 在Action类中输出国际化消息，需要使用ActionSupport的getText()方法来完成。 视图页面的国际化 在Jsp页面中指定国际化资源需要借助Struts2的另外一个标签：&lt;s:i18n&gt; 案例实现: 定义两个国际化资源文件，其路径分别为：/JSPResources/src/viewResources/loginForm_en_US与/JSPResources/src/viewResources/loginForm_zh_CN.properties 两个包的内容分别为： 12345# loginForm_en_US.propertiesloginPage=JSP Message:Login Pageuser=JSP Message:User Namepass=JSP Message:User Passlogin=JSP Message:Login 12345# loginForm_zh_CN.propertiesloginPage=JSP Message:Login Pageuser=JSP Message:User Namepass=JSP Message:User Passlogin=JSP Message:Login 定义一个JSP页面，并在其中使用国际化资源文件，其路径为：/JSPResources/WebContent/WEB-INF/content/success.jsp 12345678910111213141516171819202122&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib prefix=\"s\" uri=\"/struts-tags\"%&gt;&lt;!DOCTYPE html&gt;&lt;!-- 加载baseName为viewResource包下的baseName为loginForm的国际化资源文件 --&gt;&lt;s:i18n name=\"viewResources.loginForm\"&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;!-- 使用text标签来输出国际化信息 --&gt; &lt;title&gt;&lt;s:text name=\"loginPage\"&gt;&lt;/s:text&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;s:form action=\"login\"&gt; &lt;!-- 在表单页面中，使用key属性来输出国际化信息 --&gt; &lt;s:textfield name=\"username\" key=\"user\" /&gt; &lt;s:textfield name=\"password\" key=\"pass\" /&gt; &lt;s:submit key=\"login\"/&gt; &lt;/s:form&gt; &lt;/body&gt;&lt;/html&gt;&lt;/s:i18n&gt; 定义配置文件struts.xml来访问页面 12345678910111213141516171819&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE struts PUBLIC \"-//Apache Software Foundation//DTD Struts Configuration 2.5//EN\" \"http://struts.apache.org/dtds/struts-2.5.dtd\"&gt;&lt;struts&gt; &lt;constant name=\"struts.devMode\" value=\"true\"&gt;&lt;/constant&gt; &lt;constant name=\"struts.enable.DynamicMethodInvocation\" value=\"true\"/&gt; &lt;package name=\"shop\" namespace=\"/\" extends=\"struts-default\" &gt; &lt;action name=\"*\"&gt; &lt;result&gt;/WEB-INF/content/&#123;1&#125;.jsp&lt;/result&gt; &lt;/action&gt; &lt;action name=\"login\"&gt; &lt;result&gt;/WEB-INF/content/success.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; 启动服务器，在页面查看效果. Action的国际化 为Action单独指定国际化资源文件的方法是：在Action类文件所在的路径下建立多个文件名为ActionName_language_country.properties. Struts2的国际资源文件是由系统自动加载。 使用包范围的国际化资源 包范围的国际化资源可以被该包下的所有Action使用。 包范围的国际化资源文件的文件名：package_&lt;language&gt;_&lt;country&gt;.properties使用全局国际化资源 不管是在struts.xml文件中配置常量，还是在struts.properties文件中配置常量，只需要配置struts.custom.i18n.resources常量即可加载全局国际化资源文件。输出带占位符的国际化消息 国际化消息可能包含占位符，这些占位符必须使用参数来填充。加载资源文件的顺序 使用Struts2的标签库Struts2标签库概述 Struts2的标签都定义在URI为/struts-tags的空间下。 从大范围上看，可以将Struts2标签分成如下两类： UI(User Interface，用户界面)标签：主要用于生成HTML元素的标签。 非UI标签：主要用于数据访问、逻辑控制等的标签。 对于UI标签，可以分为如下两类： 标签标签：主要用于生成HTML页面的form元素，以及普通表单元素的标签。 非表单标签：主要用于生成页面上的树、Tab页等标签。 对于非UI标签，也可以分为如下两类： 流程控制标签：主要包含用于生成分支、循环等流程控制的标签。 数据访问标签：主要包含用于输出ValueStack中的值，完成国际化等功能的标签。 使用Struts2标签 Struts2的标签库定义文件存放在struts2-core.2.5.20.jar包下的struts-tags.tld文件 在JSP页面中使用Struts2标签的步骤 在JSP页面中导入Struts2的标签库，例如：&lt;%@ taglib prefix=&quot;s&quot; uri=&quot;/struts-tags&quot; %&gt;；其中prefix指定标签的前缀，uri指定使用哪个核心标签库。 在JSP页面中使用相关标签：例如：&lt;s:text name=&quot;hello&quot;/&gt; 。 Struts2的OGNL表达式语言 OGNL(Object-Graph Navigation Language：图像导航语言) OGNL,如果需要访问的对象属于根对象，则可以直接访问该属性，如果不是则需要使用一个前缀# 开发中，可以在页面中添加&lt;s:debug/&gt;标签，来查看属性是为value stack还是stack contextOGNL中的集合操作 很多时候，可能需要一个集合对象（例如List对象，或者Map对象），使用OGNL表达式可以直接创建集合对象。 直接创建List集合的语法：{e1,e2,e3} 直接创建Map集合的语法：#{key1:value1,key2:value2} 对于集合，OGNL提供了两个运算符：in和not in 除此之外，OGNL还允许通过某个规则取得集合的子集。取得集合的子集时有如下三个操作： ?: 取出所有符合选择逻辑的元素。 ^: 取出符合选择逻辑的第一个元素。 $: 取出符合选择逻辑的最后一个元素。 访问静态成员1&lt;constant name=\"struts.ognl.allowStaticMethodAccess\" value=\"true\"&gt;&lt;/constant&gt; 1234访问静态方法：&lt;s:property value=\"@org.crazyit.struts2.action.DemoAction@s()\"/&gt;&lt;br&gt;访问静态属性：&lt;s:property value=\"@org.crazyit.struts2.action.DemoAction@str\"/&gt;&lt;br&gt;生成一个伪随机数:&lt;s:property value=\"@java.lang.Math@random()\"/&gt;&lt;br&gt;圆周率的值:&lt;s:property value=\"@java.lang.Math@PI\"/&gt; Lambda表达式 Lambda表达式支持:&lt;s:property value=&quot;#fib =: [#this == 0?0:#this==1?1:#fib(#this-2)+#fib(#this-1)],#fib(11)&quot;/&gt;控制标签 控制标签有9个 if：用于控制选择输出的标签。 elseIf/elseif：与if标签结合使用，用于控制选择输出的标签。 else：与if标签结合使用，用于控制选择输出的标签。 append：用于将多个集合拼接成一个新的集合。 generator：它是一个字符串解析器，用于讲一个字符串解析成一个集合。 iterator：这是一个迭代器，用于将集合迭代输出。 merge：用于将多个集合合拼成一个新的集合。但与append的拼接方法有所不同。 sort：这个标签用于对集合进行排序。 subset：这个标签用于截取集合的部分元素，形成新的子集合。 if/elseif/else标签 三个标签结合的语法格式如下： 12345678910&lt;s:if test=\"表达式\"&gt; 标签体&lt;/s:if&gt;&lt;s:elseif test=\"表达式\"&gt; 标签体&lt;/s:elseif&gt;...&lt;s:else&gt; 标签体&lt;/s:else&gt; 案列实现: 1234567891011121314151617181920212223242526272829&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib prefix=\"s\" uri=\"/struts-tags\" %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;分支控制&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 向Stack Context中定义一个属性age,并取值为 29 --&gt; &lt;s:set var=\"age\" value=\"29\"&gt;&lt;/s:set&gt; &lt;!-- 如果Stack Context中的age属性大于60 --&gt; &lt;s:if test=\"#age&gt;60\"&gt; 老年人 &lt;/s:if&gt; &lt;!-- 如果Stack Context中的age属性大于35 --&gt; &lt;s:elseif test=\"#age&gt;35\"&gt; 中年人 &lt;/s:elseif&gt; &lt;!-- 如果Stack Context中的age属性大于15 --&gt; &lt;s:elseif test=\"#age&gt;15\"&gt; 青年人 &lt;/s:elseif&gt; &lt;s:else&gt; 少年人 &lt;/s:else&gt;&lt;/body&gt;&lt;/html&gt; iterator标签 主要用于对集合进行迭代。 案例实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib prefix=\"s\" uri=\"/struts-tags\" %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;iterator标签&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;table border=\"1\" width=\"300\"&gt; &lt;s:iterator value=\"&#123;'疯狂java讲义','轻量级Java EE企业应用实战','疯狂IOS讲义'&#125;\" var=\"name\"&gt; &lt;tr&gt; &lt;th&gt;&lt;s:property value=\"#st.count\"/&gt;&lt;s:property value=\"name\"/&gt;&lt;/th&gt; &lt;/tr&gt; &lt;/s:iterator&gt; &lt;/table&gt; &lt;!-- 迭代输出list集合 --&gt; &lt;table border=\"1\" width=\"300\"&gt; &lt;s:iterator value=\"&#123;'疯狂java讲义','轻量级Java EE企业应用实战','疯狂IOS讲义'&#125;\" var=\"name\" status=\"st\"&gt; &lt;tr &lt;s:if test=\"#st.odd\"&gt;style=\"background-color:#bbbbbb\" &lt;/s:if&gt;&gt; &lt;td&gt; &lt;s:property value=\"name\"/&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/s:iterator&gt; &lt;/table&gt; &lt;!-- 对Map集合进行迭代 --&gt; &lt;table border=\"1\" width=\"300\"&gt; &lt;tr&gt; &lt;th&gt;书名&lt;/th&gt; &lt;th&gt;作者&lt;/th&gt; &lt;/tr&gt; &lt;s:iterator value=\"#&#123;'疯狂java讲义':'李刚','轻量级Java EE企业应用实战':'李刚','疯狂IOS讲义':'李刚'&#125;\" var=\"name\" status=\"st\"&gt; &lt;!--根据当前迭代的元素的索引是否为奇数来决定是否使用背景颜色 --&gt; &lt;tr &lt;s:if test=\"#st.odd\"&gt;style=\"background-color:#bbbbbb\" &lt;/s:if&gt;&gt; &lt;td&gt; &lt;!-- 数据Map对象里Entry的key --&gt; &lt;s:property value=\"key\"/&gt; &lt;/td&gt; &lt;td&gt; &lt;!-- 数据Map对象里Entry的value --&gt; &lt;s:property value=\"value\"/&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/s:iterator&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt; append标签 append：用于将多个集合拼接成一个新的集合。 案例实现 1234567891011121314151617181920212223242526272829303132333435363738&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib prefix=\"s\" uri=\"/struts-tags\" %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;append标签&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 使用append标签将两个集合拼接成新的集合，新集合的名字是newList，新集合放入到Stack Context --&gt; &lt;s:append var=\"newList\"&gt; &lt;s:param value=\"&#123;'疯狂java讲义','轻量级Java EE企业应用实战','疯狂IOS讲义'&#125;\"&gt;&lt;/s:param&gt; &lt;s:param value=\"&#123;'http://www.baidu.com','cpws.github.io','qqqqyy.github.io'&#125;\"&gt;&lt;/s:param&gt; &lt;/s:append&gt; &lt;table border=\"1\" width=\"400\"&gt; &lt;s:iterator value=\"#newList\" var=\"name\" status=\"index\"&gt; &lt;tr &lt;s:if test=\"#index.even\"&gt;style=\"background-color:#4dffff\"&lt;/s:if&gt;&gt; &lt;td&gt;&lt;s:property value=\"name\"/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/s:iterator&gt; &lt;/table&gt; &lt;!-- 使用append标签将List集合和Map结合拼接成新的集合，新集合的名字是newList，新集合放入到Stack Context --&gt; &lt;s:append var=\"dd\"&gt; &lt;s:param value=\"#&#123;'疯狂java讲义':'李刚','轻量级Java EE企业应用实战':'李刚','疯狂IOS讲义':'李刚'&#125;\"&gt;&lt;/s:param&gt; &lt;s:param value=\"#&#123;'http://www.baidu.com','cpws.github.io','qqqqyy.github.io'&#125;\"&gt;&lt;/s:param&gt; &lt;/s:append&gt; &lt;!-- 使用迭代器进行迭代 --&gt; &lt;table border=\"1\" width=\"400\"&gt; &lt;s:iterator value=\"#dd\" var=\"name\" status=\"st\"&gt; &lt;tr &lt;s:if test=\"#st.even\"&gt;style=\"background-color:#4dffff\"&lt;/s:if&gt;&gt; &lt;td&gt;&lt;s:property value=\"key\"/&gt;&lt;/td&gt; &lt;td&gt;&lt;s:property value=\"value\"/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/s:iterator&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt; generator标签 generator：它是一个字符串解析器，用于讲一个字符串解析成一个集合. 案例实现： 1234567891011121314151617181920212223242526272829303132333435363738&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib prefix=\"s\" uri=\"/struts-tags\" %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;generator标签&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;table border=\"1\" width=\"300\"&gt; &lt;!-- 使用generator标签将指定字符串解析成iterator集合 --&gt; &lt;!-- 在generator标签内，得到的List集合位于valuestack顶端 --&gt; &lt;s:generator separator=\",\" val=\" '疯狂Java讲义,疯狂Java EE企业应用实战,疯狂IOS讲义' \"&gt; &lt;!-- 没有指定迭代哪个集合，直接迭代栈顶的集合 --&gt; &lt;s:iterator status=\"st\"&gt; &lt;tr &lt;s:if test=\"#st.odd\"&gt;style=\"background-color:#bbbbbb\" &lt;/s:if&gt;&gt; &lt;td&gt;&lt;s:property/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/s:iterator&gt; &lt;/s:generator&gt; &lt;/table&gt; &lt;table border=\"1\" width=\"300\"&gt; &lt;!-- 使用generator标签将指定字符串解析成iterator集合 指定了count和var --&gt; &lt;!-- 在generator标签内，得到的List集合位于valuestack顶端 --&gt; &lt;s:generator separator=\",\" val=\" '疯狂Java讲义,疯狂Java EE企业应用实战,疯狂IOS讲义' \" count=\"2\" var=\"books\"&gt; &lt;!-- 没有指定迭代哪个集合，直接迭代栈顶的集合 --&gt; &lt;!-- 并且把值存入到 stack context中的books集合 --&gt; &lt;s:iterator status=\"st\"&gt; &lt;tr &lt;s:if test=\"#st.odd\"&gt;style=\"background-color:#bbbbbb\" &lt;/s:if&gt;&gt; &lt;td&gt;&lt;s:property/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/s:iterator&gt; &lt;/s:generator&gt; &lt;/table&gt; $&#123;requestScope.books&#125;&lt;/body&gt;&lt;/html&gt; 注意：如果在标签定义了var属性，则该集合将会被存入到Stack Context中，在该标签外部可以访问该标签，否则，该集合会创建一个临时文件存放在Value Stack，可以直接被访问，但是只能在标签中被使用。 merge标签 merge：用于将多个集合合拼成一个新的集合。但与append的拼接方法有所不同。 案例实现: 123456789101112131415161718192021222324&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib prefix=\"s\" uri=\"/struts-tags\" %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;merge标签&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;s:merge var=\"newList\"&gt; &lt;s:param value=\"&#123;'疯狂Java讲义','轻量级Java EE企业应用实战','疯狂IOS讲义'&#125;\"&gt;&lt;/s:param&gt; &lt;s:param value=\"&#123;'hhtp://www.baidu.com','cpws.github.io'&#125;\"&gt;&lt;/s:param&gt; &lt;/s:merge&gt; &lt;table border=\"1\" width=\"400\"&gt; &lt;s:iterator value=\"newList\" status=\"st\"&gt; &lt;tr &lt;s:if test=\"#st.odd\"&gt;style=\"background-color:#bbbbbb\"&lt;/s:if&gt;&gt; &lt;td&gt;&lt;s:property/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/s:iterator&gt; &lt;/table&gt; &lt;/body&gt;&lt;/html&gt; merge标签的效果与append标签一样，只是拼接成新的集合后，两者新集合中的元素顺序不一样而已。 subset标签：这个标签用于截取集合的部分元素，形成新的子集合。 案例实现 12345678910111213141516171819package org.crazyit.app.util;import org.apache.struts2.util.SubsetIteratorFilter;/*** * 用户自定义Decider类，实现了SubsetIteratorFilter.Decider接口 * @author 1huangzewei * */public class MyDecider implements SubsetIteratorFilter.Decider&#123; //实现Decider接口必须实现decide()方法 //该方法决定集合中的元素是否被选入自己 @Override public boolean decide(Object element) throws Exception &#123; String str=(String) element; //如果集合元素中包含JavaEE子串，即可被选入子集 return str.indexOf(\"Java EE\") &gt; 0; &#125;&#125; 12345678910111213141516171819202122232425262728&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib prefix=\"s\" uri=\"/struts-tags\" %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;subset标签&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 定义一个Decider Bean --&gt; &lt;s:bean name=\"org.crazyit.app.util.MyDecider\" var=\"mydecider\"&gt;&lt;/s:bean&gt; &lt;!-- 使用自定义的decider实例来截取目标集合，生成子集 --&gt; &lt;!-- 指定var属性，将生成的集合放入到page范围中 --&gt; &lt;s:subset source=\"&#123;'疯狂Java讲义','轻量级Java EE企业应用实战','经典Java EE企业应用实战','疯狂前端开发讲义','疯狂IOS讲义'&#125;\" decider=\"#mydecider\" var=\"newList\"/&gt; &lt;!--直接输出 page范围的newList属性 --&gt; 直接输出 page范围的newList属性:&lt;br&gt;$&#123;pageScope.newList&#125; &lt;table border=\"1\" width=\"400\"&gt; &lt;!-- 使用迭代器来迭代目标集合，因为没有指定value属性值，所有迭代ValueStack栈顶的值 --&gt; &lt;s:iterator value=\"#attr.newList\" status=\"st\"&gt; &lt;tr &lt;s:if test=\"#st.odd\"&gt;style=\"background-color:#bbbbbb\"&lt;/s:if&gt;&gt; &lt;td&gt;&lt;s:property/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/s:iterator&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt; sort标签 用于对指定集合元素进行排序 案例实现 12345678910111213141516package org.crazyit.app.util;import java.util.Comparator;public class MyComparator implements Comparator&#123; /*** * 决定两个元素大小的方法 */ @Override public int compare(Object o1, Object o2) &#123; //根据元素字符串长度来决定大小 return o1.toString().length() - o2.toString().length(); &#125;&#125; 123456789101112131415161718192021222324252627&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib prefix=\"s\" uri=\"/struts-tags\" %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;sort标签&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 定义一个Comparator实例 --&gt; &lt;s:bean name=\"org.crazyit.app.util.MyComparator\" var=\"myComparator\"/&gt; &lt;!-- 使用自定义的排序规则进行排序 --&gt; &lt;s:sort comparator=\"#myComparator\" source=\"&#123;'疯狂Java讲义','轻量级Java EE企业应用实战','经典Java EE企业应用实战','疯狂前端开发讲义','疯狂IOS讲义'&#125;\" var=\"sortedList\"/&gt; 输出page范围的sortedList属性：&lt;br&gt;$&#123;pageScope.sortedList&#125; &lt;table border=\"1\" width=\"400\"&gt; &lt;!-- 使用迭代器来迭代目标集合，因为没有指定value属性值，所有迭代ValueStack栈顶的值 --&gt; &lt;s:iterator value=\"#attr.sortedList\" status=\"st\"&gt; &lt;tr &lt;s:if test=\"#st.odd\"&gt;style=\"background-color:#bbbbbb\"&lt;/s:if&gt;&gt; &lt;td&gt;&lt;s:property/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/s:iterator&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 数据标签 数据标签主要用于提供各种数据访问的功能，包含显示一个Action里的属性，以及生成国际化输出等功能。数据标签主要包含如下几个： action：该标签用于在JSP页面直接调用一个action，通过指定executeResult参数，还可将该action的处理结果包含到本页面中来。 bean：该标签用于创建一个JavaBean实例。如果指定了var属性，则可以将创建的实例放入到Stack Context中. date：用于格式化输出一个日期。 debug：用于在页面上生成一个调试链接，当点击该链接时，可以看到Stack Context和ValueStack中的内容。 i18n：用于指定国际化资源文件的baseName。 include：用于在JSP页面中包含其他的JSP或Servlet资源。 param：用于设置一个参数，通常是用作bean标签、URL标签的字标签。 push：用于将某个值放入到ValueStack的栈顶。 set：用于设置一个新变量，并可以将新变量放入到指定的范围内。 text：用于输出国际化信息。 url：用于生成一个URL地址。 property：用于输出某个值，包括输出valueStack,Stack Context和Action Context中的值。 action标签：该标签用于在JSP页面直接调用一个action 案例实现 123456789101112131415161718192021&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib prefix=\"s\" uri=\"/struts-tags\" %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;action标签&lt;/title&gt;&lt;/head&gt;&lt;body&gt; 下面调用第一个Action，并将结果包含到本页面&lt;br&gt; &lt;s:action name=\"tag1\" executeResult=\"true\"/&gt;&lt;hr&gt; 下面调用第二个Action，并将结果包含到本页面&lt;br&gt; 但阻止本页面请求参数传入Action。&lt;br&gt; &lt;s:action name=\"tag2\" executeResult=\"true\" ignoreContextParams=\"true\"/&gt;&lt;hr&gt; 下面调用第三个Action，并不将结果包含到本页面&lt;br&gt; &lt;s:action name=\"tag2\" executeResult=\"true\" ignoreContextParams=\"false\"/&gt; 本页面是否可访问：&lt;s:property value=\"author\"/&gt; &lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920212223242526package org.crazyit.app.action;import com.opensymphony.xwork2.ActionContext;import com.opensymphony.xwork2.ActionSupport;public class TagAction extends ActionSupport &#123; private static final long serialVersionUID = 1L; //封装用户请求参数的author成员变量 private String author; public String getAuthor() &#123; return author; &#125; public void setAuthor(String author) &#123; this.author = author; &#125; //定义第一个处理逻辑 public String execute() throws Exception&#123; return \"done\"; &#125; //定义第二个处理逻辑 public String login() throws Exception&#123; ActionContext.getContext().put(\"author\", getAuthor()); return \"done\"; &#125;&#125; 12345678910111213141516171819202122&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE struts PUBLIC \"-//Apache Software Foundation//DTD Struts Configuration 2.5//EN\" \"http://struts.apache.org/dtds/struts-2.5.dtd\"&gt;&lt;struts&gt; &lt;constant name=\"struts.devMode\" value=\"true\"&gt;&lt;/constant&gt; &lt;constant name=\"struts.enable.DynamicMethodInvocation\" value=\"true\"/&gt; &lt;package name=\"default\" namespace=\"/\" extends=\"struts-default\" &gt; &lt;!-- 定义第一个Action，使用TagAction的execute方法作为控制处理逻辑 --&gt; &lt;action name=\"tag1\" class=\"org.crazyit.app.action.TagAction\"&gt; &lt;result name=\"done\"&gt;/WEB-INF/content/succ.jsp&lt;/result&gt; &lt;/action&gt; &lt;!-- 定义第二个Action，使用TagAction的login方法作为控制处理逻辑 --&gt; &lt;action name=\"tag2\" class=\"org.crazyit.app.action.TagAction\" method=\"login\"&gt; &lt;result name=\"done\"&gt;/WEB-INF/content/loginSucc.jsp&lt;/result&gt; &lt;/action&gt; &lt;action name=\"*\"&gt; &lt;result&gt;/WEB-INF/content/&#123;1&#125;.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; bean：该标签用于创建一个JavaBean实例 案例实现 1234567891011121314151617181920212223242526272829303132333435&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib prefix=\"s\" uri=\"/struts-tags\" %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;bean标签&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 使用bean标签创建一个Person实例 --&gt; &lt;s:bean name=\"org.crazyit.app.dto.Person\" &gt; &lt;!-- 使用param标签为Person类的实例传入参数 --&gt; &lt;s:param name=\"name\" value=\"'yeeku'\"/&gt; &lt;s:param name=\"age\" value=\"23\"/&gt; &lt;s:param name=\"aaa\" value=\"10\"/&gt; &lt;!-- 因为在bean标签体内，Person实例位于ValueStack栈顶，故可以直接访问Person实例 --&gt; &lt;!-- Person实例的name为：&lt;s:property value=\"name\"/&gt;&lt;br/&gt; Person实例的age为：&lt;s:property value=\"age\"/&gt;&lt;br/&gt; Person实例的aaa为：&lt;s:property value=\"aaa\"/&gt;&lt;br/&gt; --&gt; &lt;/s:bean&gt; &lt;s:bean name=\"org.crazyit.app.dto.Person\" var=\"p\"&gt; &lt;s:param name=\"name\" value=\"'yeeku'\"/&gt; &lt;s:param name=\"age\" value=\"23\"/&gt; &lt;s:param name=\"aaa\" value=\"10\"/&gt; &lt;/s:bean&gt; &lt;!-- 根据JavaBean实例的var属性来获取JavaBean实例 --&gt; Person实例的name为：&lt;s:property value=\"#p.name\"/&gt;&lt;br/&gt; Person实例的age为：&lt;s:property value=\"#p.age\"/&gt;&lt;br/&gt; Person实例的aaa为：&lt;s:property value=\"#p.aaa\"/&gt;&lt;br/&gt; $&#123;requestScope.p&#125;&lt;/body&gt;&lt;/html&gt; 123456789101112131415package org.crazyit.app.dto;public class Person &#123; private String name; private int age; private int aaa; public Person() &#123;&#125; public Person(String name, int age, int aaa) &#123; super(); this.name = name; this.age = age; this.aaa = aaa; &#125; //省略getter和setter方法&#125; date：用于格式化输出一个日期 案例实现： 123456789101112131415161718192021222324&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib prefix=\"s\" uri=\"/struts-tags\" %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;s:bean var=\"now\" name=\"java.util.Date\"/&gt; nice=false，且指定format=\"dd/MM/YYYY\"&lt;br/&gt; &lt;s:date name=\"#now\" format=\"dd/MM/YYYY\" nice=\"false\"/&gt;&lt;hr/&gt; nice=true，且指定format=\"dd/MM/YYYY\"&lt;br/&gt; &lt;s:date name=\"#now\" format=\"dd/MM/YYYY\" nice=\"true\"/&gt;&lt;hr/&gt; 指定nice=\"true\"&lt;br/&gt; &lt;s:date name=\"#now\" nice=\"true\"/&gt;&lt;hr/&gt; 指定nice=\"false\"，且没有指定formate属性&lt;br/&gt; &lt;s:date name=\"#now\" nice=\"false\"/&gt;&lt;hr/&gt; 指定nice=\"false\"，且没有指定formate属性，但指定var属性&lt;br/&gt; &lt;s:date name=\"#now\" nice=\"false\" var=\"abc\"/&gt;&lt;hr/&gt; $&#123;requestScope.abc&#125; &lt;s:property value=\"#abc\"/&gt;&lt;/body&gt;&lt;/html&gt; debug：用于在页面上生成一个调试链接. 案例实现： 1&lt;s:debug/&gt; include：用于在JSP页面中包含其他的JSP或Servlet资源。 案例实现： 1234567891011121314151617181920&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib prefix=\"s\" uri=\"/struts-tags\" %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;include标签&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;使用s:include标签来包含目标页面&lt;/h2&gt;&lt;!-- 使用include标签来包含其他页面 --&gt;&lt;s:include value=\"include-file.jsp\"/&gt;&lt;!-- 使用include标签来包含其他页面，并且传入参数 --&gt;&lt;s:include value=\"include-file.jsp\"&gt; &lt;s:param name=\"author\" value=\"'yeeku'\"/&gt;&lt;/s:include&gt; &lt;/body&gt;&lt;/html&gt; 12345678910111213&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h3&gt;被包含的页面&lt;/h3&gt; author的参数值：$&#123;param.author&#125;&lt;/body&gt;&lt;/html&gt; param标签：主要用于为其他标签提供参数。 push标签：push标签用于将某个值放到ValueStack的栈顶。 案例实现: 12345678910111213141516171819202122232425&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib prefix=\"s\" uri=\"/struts-tags\" %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;使用s:push标签将某个值放入到Value Stack&lt;/h2&gt; &lt;!-- 使用bean标签来创建一个JavaBean实例，指定var属性，并且将其值放到var属性中 --&gt; &lt;s:bean name=\"org.crazyit.app.dto.Person\" var=\"p\"&gt; &lt;s:param name=\"name\" value=\"'ok'\"&gt;&lt;/s:param&gt; &lt;s:param name=\"age\" value=\"18\"&gt;&lt;/s:param&gt; &lt;s:param name=\"aaa\" value=\"12\"&gt;&lt;/s:param&gt; &lt;/s:bean&gt; &lt;!-- 将Stack Context中的p对象放入到ValueStack --&gt; &lt;s:push value=\"#p\"&gt; ValueStack栈顶对象的name属性：&lt;s:property value=\"name\"/&gt;&lt;br/&gt; ValueStack栈顶对象的age属性：&lt;s:property value=\"age\"/&gt;&lt;br/&gt; ValueStack栈顶对象的aaa属性：&lt;s:property value=\"aaa\"/&gt;&lt;br/&gt; &lt;/s:push&gt;&lt;/body&gt;&lt;/html&gt; set标签：用于将某个值放入到指定的范围中。 案例实现 12345678910111213141516171819202122232425262728293031323334353637&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib prefix=\"s\" uri=\"/struts-tags\" %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;set标签&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;使用s:set设置一个新变量&lt;/h2&gt; &lt;!-- 使用s:bean标签定义一个JavaBean实例 --&gt; &lt;s:bean name=\"org.crazyit.app.dto.Person\" var=\"p\"&gt; &lt;s:param name=\"name\" value=\"'ok'\"&gt;&lt;/s:param&gt; &lt;s:param name=\"age\" value=\"18\"&gt;&lt;/s:param&gt; &lt;s:param name=\"aaa\" value=\"12\"&gt;&lt;/s:param&gt; &lt;/s:bean&gt; 将Stack Context中的p值放入到默认范围（action）内。&lt;br/&gt; &lt;s:set value=\"#p\" var=\"xxx\" /&gt; Stack Context内xxx对象的name属性：&lt;s:property value=\"#xxx.name\"/&gt;&lt;br/&gt; Stack Context内xxx对象的age属性：&lt;s:property value=\"#xxx.age\"/&gt;&lt;br/&gt; Stack Context内xxx对象的aaa属性：&lt;s:property value=\"#xxx.aaa\"/&gt;&lt;br/&gt; request范围的xxx对象的name属性：$&#123;requestScope.xxx.name&#125;&lt;br/&gt; request范围的xxx对象的age属性：$&#123;requestScope.xxx.age&#125;&lt;br/&gt; request范围的xxx对象的aaa属性：$&#123;requestScope.xxx.aaa&#125;&lt;hr/&gt; 将Stack Context中的p值放入application范围内。&lt;br/&gt; &lt;s:set value=\"#p\" var=\"yyy\" scope=\"application\"/&gt; application范围的yyy对象的name属性：$&#123;applicationScope.yyy.name&#125;&lt;br/&gt; application范围的yyy对象的age属性：$&#123;applicationScope.yyy.age&#125;&lt;br/&gt; application范围的yyy对象的aaa属性：$&#123;applicationScope.yyy.aaa&#125;&lt;hr/&gt; 将Stack Context中的p值放入session范围内。&lt;br/&gt; &lt;s:set value=\"#p\" var=\"zzz\" scope=\"session\"/&gt; session范围的zzz对象的name属性：$&#123;sessionScope.zzz.name&#125;&lt;br/&gt; session范围的zzz对象的age属性：$&#123;sessionScope.zzz.age&#125;&lt;br/&gt; session范围的zzz对象的aaa属性：$&#123;sessionScope.zzz.aaa&#125;&lt;hr/&gt;&lt;/body&gt;&lt;/html&gt; url标签：用于生成一个url地址。\\ 案例实现： 12345678910111213141516171819&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib prefix=\"s\" uri=\"/struts-tags\" %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;url标签&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;s：url来生成一个URL地址&lt;/h2&gt; 只指定value属性的形式&lt;br/&gt; &lt;s:url value=\"editGadget.action\"/&gt;&lt;hr/&gt; 指定action属性，且使用param传入参数的形式&lt;br/&gt; &lt;s:url action=\"showBooks\"&gt; &lt;s:param name=\"author\" value=\"'yeeku'\"/&gt; &lt;/s:url&gt;&lt;hr/&gt;&lt;/body&gt;&lt;/html&gt; property标签：输出指定值。 主题和模板自定义主题表单标签 所有表单标签处理类都继承了UIBean类，UIBean包含了一些通用属性，这些通用属性分成三种： 模板相关属性。 JavaScript相关属性。 通用属性。 表单标签的name和value属性。 checkboxlist标签:可以一次创建多个复选框。 案例实现： 1234567891011121314151617181920212223242526272829&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib prefix=\"s\" uri=\"/struts-tags\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;checkboxlist标签&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;s:form&gt; &lt;!-- 使用简单的集合来生成多个复选框 --&gt; &lt;s:checkboxlist name=\"a\" label=\"请选择您喜欢的图书\" labelposition=\"top\" list=\"&#123;'疯狂java讲义','轻量级Java EE企业应用实战','疯狂IOS讲义'&#125;\"&gt;&lt;/s:checkboxlist&gt; &lt;!-- 使用简单Map来生成多个复选框 使用Map的key值作为复选框的value 使用Map的value值作为复选框的标签 --&gt; &lt;s:checkboxlist name=\"b\" label=\"请选择您想出版的日期：\" labelposition=\"top\" list=\"#&#123;'疯狂java讲义':'2008年9月','轻量级Java EE企业应用实战':'2008年12月','疯狂IOS讲义':'2014年1月'&#125;\" listKey=\"key\" listValueKey=\"value\"&gt;&lt;/s:checkboxlist&gt; &lt;!-- 创建一个JavaBean对象，并将其放入Stack Context中--&gt; &lt;s:bean name=\"org.crazyit.app.service.BookService\" var=\"bs\"&gt;&lt;/s:bean&gt; &lt;!-- 使用集合里放多个JavaBean实例来生成多个复选框 集合name作为标签，集合author作为复选框value --&gt; &lt;s:checkboxlist name=\"c\" label=\"请选择您喜欢的图书：\" labelposition=\"top\" list=\"#bs.books\" listKey=\"author\" listValue=\"name\"&gt;&lt;/s:checkboxlist&gt; &lt;/s:form&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314package org.crazyit.app.service;import org.crazyit.app.dto.Book;public class BookService &#123; public Book[] getBooks() &#123; return new Book[] &#123; new Book(\"疯狂Java讲义\",\"李刚\"), new Book(\"疯狂Java EE企业应用实战\",\"李刚\"), new Book(\"疯狂ios讲义\",\"李刚\"), new Book(\"疯狂前端开发讲义\",\"李刚\") &#125;; &#125;&#125; 123456789101112131415161718192021222324252627package org.crazyit.app.dto;public class Book &#123; private String name; private String author; public Book() &#123; // TODO Auto-generated constructor stub &#125; public Book(String name, String author) &#123; super(); this.name = name; this.author = author; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getAuthor() &#123; return author; &#125; public void setAuthor(String author) &#123; this.author = author; &#125; &#125; radio标签：与checkboxlist的用法和属性完全一样，只是该标签生成的是单选按钮。 案例实现 1234567891011121314151617181920212223242526272829&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib prefix=\"s\" uri=\"/struts-tags\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;radio标签&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;s:form&gt; &lt;!-- 使用简单的集合来生成单选按钮--&gt; &lt;s:radio name=\"a\" label=\"请选择您喜欢的图书\" labelposition=\"top\" list=\"&#123;'疯狂java讲义','轻量级Java EE企业应用实战','疯狂IOS讲义'&#125;\"&gt;&lt;/s:radio&gt; &lt;!-- 使用简单Map来生成多个单选按钮 使用Map的key值作为单选按钮的value 使用Map的value值作为单选按钮的标签 --&gt; &lt;s:radio name=\"b\" label=\"请选择您想出版的日期：\" labelposition=\"top\" list=\"#&#123;'疯狂java讲义':'2008年9月','轻量级Java EE企业应用实战':'2008年12月','疯狂IOS讲义':'2014年1月'&#125;\" listKey=\"key\" listValueKey=\"value\"&gt;&lt;/s:radio&gt; &lt;!-- 创建一个JavaBean对象，并将其放入Stack Context中--&gt; &lt;s:bean name=\"org.crazyit.app.service.BookService\" var=\"bs\"&gt;&lt;/s:bean&gt; &lt;!-- 使用集合里放多个JavaBean实例来生成多个单选按钮 集合name作为标签，集合author作为单选按钮value --&gt; &lt;s:radio name=\"c\" label=\"请选择您喜欢的图书：\" labelposition=\"top\" list=\"#bs.books\" listKey=\"author\" listValue=\"name\"&gt;&lt;/s:radio&gt; &lt;/s:form&gt;&lt;/body&gt;&lt;/html&gt; select标签：用于生成一个下拉列表框。 案例实现 123456789101112131415161718192021222324252627&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib prefix=\"s\" uri=\"/struts-tags\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;select标签&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;s:form&gt; &lt;!-- 使用简单的集合来生成下拉选择框 --&gt; &lt;s:select name=\"a\" label=\"请选择您喜欢的图书\" labelposition=\"top\" multiple=\"true\" list=\"&#123;'疯狂java讲义','轻量级Java EE企业应用实战','JavaScript:The Definitive Guide'&#125;\"&gt;&lt;/s:select&gt; &lt;!-- 使用简单Map来生成下拉选择框 --&gt; &lt;s:select name=\"b\" label=\"请选择您想出版的日期：\" labelposition=\"top\" list=\"#&#123;'疯狂java讲义':'2008年9月','轻量级Java EE企业应用实战':'2008年12月','疯狂IOS讲义':'2014年1月'&#125;\" listKey=\"key\" listValueKey=\"value\"&gt;&lt;/s:select&gt; &lt;!-- 创建一个JavaBean对象，并将其放入Stack Context中--&gt; &lt;s:bean name=\"org.crazyit.app.service.BookService\" var=\"bs\"&gt;&lt;/s:bean&gt; &lt;!-- 使用集合里放多个JavaBean实例来生成下拉选择框 --&gt; &lt;s:select name=\"c\" label=\"请选择您喜欢的图书：\" labelposition=\"top\" multiple=\"true\" list=\"#bs.books\" listKey=\"author\" listValue=\"name\"&gt;&lt;/s:select&gt; &lt;/s:form&gt;&lt;/body&gt;&lt;/html&gt; optgroup标签：用于生成一个下拉列表框的选项组，因此该标签需要在&lt;s:select&gt;中使用。 案例实现 12345678910111213141516171819202122&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib prefix=\"s\" uri=\"/struts-tags\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;optgroup标签&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;s:form&gt; &lt;!-- 使用简单Map为列表框生成选项 --&gt; &lt;s:select name=\"b\" label=\"请选择你喜欢的书：\" size=\"7\" labelposition=\"top\" list=\"#&#123;'疯狂java讲义':'李刚','轻量级Java EE企业应用实战':'李刚','疯狂IOS讲义':'李刚'&#125;\" listKey=\"key\" listValueKey=\"value\"&gt; &lt;!-- 使用Map对象生成选项组 --&gt; &lt;s:optgroup label=\"Rod Johnson\" list=\"#&#123;'Expert One-on-one J2EE Design and Development':'Johnson'&#125;\"&gt;&lt;/s:optgroup&gt; &lt;s:optgroup label=\"David Flanagan\" list=\"#&#123;'JavaScript :The Definitive Guide':'David'&#125;\"&gt;&lt;/s:optgroup&gt; &lt;/s:select&gt; &lt;/s:form&gt;&lt;/body&gt;&lt;/html&gt; head标签：该标签主要用于生成HTML的&lt;head ../&gt;部分。 updownselect标签：该标签的用法非常相思雨select标签的使用，区别在于该标签生成的列表框可以上下移动。 案例实现 12345678910111213141516171819202122232425&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib prefix=\"s\" uri=\"/struts-tags\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;updownselect标签&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;s:form&gt; &lt;!-- 使用简单集合来生成上下移动选项的下拉列表框 --&gt; &lt;s:updownselect name=\"a\" label=\"请选择您喜欢的书：\" labelposition=\"top\" list=\"&#123;'疯狂java讲义','轻量级Java EE企业应用实战','疯狂IOS讲义'&#125;\" moveUpLabel=\"向上移动\"&gt;&lt;/s:updownselect&gt; &lt;!-- 使用简单Map为列表框生成选项 emptyOption=\"true\"增加空白选项--&gt; &lt;s:updownselect name=\"b\" label=\"请选择您想出版的日期：\" labelposition=\"top\" moveDownLabel=\"向下移动\" list=\"#&#123;'疯狂java讲义':'2008年9月','轻量级Java EE企业应用实战':'2008年12月','疯狂IOS讲义':'2014年1月'&#125;\" listKey=\"key\" listValueKey=\"value\" emptyOption=\"true\"&gt;&lt;/s:updownselect&gt; &lt;s:bean name=\"org.crazyit.app.service.BookService\" var=\"bs\"&gt;&lt;/s:bean&gt; &lt;s:updownselect name=\"c\" label=\"请选择您喜欢的图书：\" labelposition=\"top\" selectAllLabel=\"全选\" multiple=\"true\" list=\"#bs.books\" listKey=\"author\" listValue=\"name\"&gt;&lt;/s:updownselect&gt; &lt;/s:form&gt;&lt;/body&gt;&lt;/html&gt; doubleselect标签：会生成一个级联列表框。 案例实现1: 1234567891011121314151617&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib prefix=\"s\" uri=\"/struts-tags\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;doubleselect标签&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;s:form action=\"x\"&gt; &lt;s:doubleselect label=\"请选择您喜欢的书\" labelposition=\"top\" name=\"author\" list=\"&#123;'李刚','David'&#125;\" doubleList=\"top=='李刚'?&#123;'轻量级Java EE企业级应用实战','疯狂IOS讲义','疯狂Java讲义'&#125;:&#123;'JavaScript:the definitive guide'&#125;\" doubleName=\"book\"/&gt; &lt;/s:form&gt;&lt;/body&gt;&lt;/html&gt; 案例实现2: 1234567&lt;h3&gt;使用s:doubleselect生成级联列表框&lt;/h3&gt;&lt;s:set var=\"bs\" value=\"#&#123;'李刚':&#123;'疯狂java讲义','轻量级Java EE企业应用实战','疯狂IOS讲义'&#125;,'Johnson':&#123;'Expert One-on-one J2EE Design and Development'&#125;,'David':&#123;'JavaScript :The Definitive Guide'&#125;&#125;\"/&gt;&lt;s:form action=\"x\"&gt; &lt;s:doubleselect label=\"请选择您喜欢的书\" name=\"author\" list=\"#bs.keySet()\" size=\"3\" doubleList=\"#bs[top]\" doubleSize=\"3\" doubleName=\"book\"/&gt;&lt;/s:form&gt; optiontransferselect标签：会生成两个列表选择框，并生成系列按钮控制各选框之间的移动、升降等。 12345678910111213141516171819202122232425262728293031323334353637&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib prefix=\"s\" uri=\"/struts-tags\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;s:form&gt; &lt;!-- 使用简单的集合对象生成可移动的下拉框 --&gt; &lt;s:optiontransferselect label=\"请选择你喜欢的书\" name=\"cnbook\" leftTitle=\"中文图书\" rightTitle=\"外文图书\" list=\"&#123;'疯狂java讲义','轻量级Java EE企业应用实战','疯狂IOS讲义'&#125;\" multiple=\"true\" addToLeftLabel=\"向左移动\" addToRightLabel=\"向右移动\" selectAllLabel=\"全部选择\" addAllToRightLabel=\"全部右移\" addAllToLeftLabel=\"全部左移\" headerKey=\"cnKey\" headerValue=\"--- 选择中文图书 ---\" emptyOption=\"true\" doubleList=\"&#123;'Expert One-on-one J2EE Design and Development','JavaScript :The Definitive Guide'&#125;\" doubleName=\"enBook\" doubleHeaderKey=\"enKey\" doubleHeaderValue=\"--- 选择外文图书 ---\" doubleEmptyOption=\"true\" doubleMultiple=\"true\" /&gt; &lt;/s:form&gt;&lt;/body&gt;&lt;/html&gt; token标签：防止重复提交表单的标签。 案例实现： 1234567891011121314151617181920&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib prefix=\"s\" uri=\"/struts-tags\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;token标签&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h3&gt;使用s:token防止重复提交&lt;/h3&gt; &lt;s:form action=\"pro\"&gt; &lt;!-- 普通表单域 --&gt; &lt;s:textfield name=\"book\" label=\"书名\" /&gt; &lt;!-- 用于防刷新的token标签 --&gt; &lt;s:token/&gt; &lt;s:submit value=\"提交\"&gt;&lt;/s:submit&gt; &lt;/s:form&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920212223package org.crazyit.app.action;import com.opensymphony.xwork2.ActionSupport;public class ProAction extends ActionSupport&#123; private static final long serialVersionUID = 1L; private String book; public String getBook() &#123; return book; &#125; public void setBook(String book) &#123; this.book = book; &#125; //处理用户的业务逻辑 public String execute() &#123; System.out.println(getBook()); return NONE; &#125; &#125; 12345678910111213141516171819202122&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE struts PUBLIC \"-//Apache Software Foundation//DTD Struts Configuration 2.5//EN\" \"http://struts.apache.org/dtds/struts-2.5.dtd\"&gt;&lt;struts&gt; &lt;constant name=\"struts.devMode\" value=\"true\"&gt;&lt;/constant&gt; &lt;constant name=\"struts.enable.DynamicMethodInvocation\" value=\"true\"/&gt; &lt;package name=\"default\" namespace=\"/\" extends=\"struts-default\" &gt; &lt;action name=\"pro\" class=\"org.crazyit.app.action.ProAction\"&gt; &lt;!-- 使用系统默认的拦截器 --&gt; &lt;interceptor-ref name=\"basicStack\"&gt;&lt;/interceptor-ref&gt; &lt;!-- 使用防止刷新的拦截器 --&gt; &lt;interceptor-ref name=\"token\"/&gt; &lt;!-- 定义重复提交的转向视图，该逻辑视图名必须是：invalid.token --&gt; &lt;result name=\"invalid.token\"&gt;/WEB-INF/content/refresh.jsp&lt;/result&gt; &lt;/action&gt; &lt;action name=\"*\"&gt; &lt;result&gt;/WEB-INF/content/&#123;1&#125;.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; 使用token标签需要注意两点: 在页面中添加&lt;s:token/&gt;标签。 在配置文件中添加拦截器并且配置invalid.token结果集 非表单标签 非表单标签主要用于显示action里封装的信息。非表单标签主要有如下几个: actionerror：如果Action实例的getActionErrors()方法不返回null，则该标签负责输出该方法返回的系列错误。 actionmessage：如果Action实例的getActionMessages()方法不返回null，则该标签负责输出该方法返回的系列错误。 component：使用此标签可以生成一个自定义组件。 fielderror：如果Action实例存在表单域的类型转换错误、校验错误，则该标签负责输出错误信息。 actionerror和actionmessage标签 component标签：用于创建自定义组件 案例实现： 123456789101112131415161718192021222324&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib prefix=\"s\" uri=\"/struts-tags\" %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;使用s:component标签&lt;/h2&gt; 使用默认主题(xHTML)，默认主题目录(template)&lt;br&gt; 使用mytemplate作为视图组件 &lt;s:component template=\"mytemplate.jsp\"&gt; &lt;s:param name=\"list\" value=\"&#123;'疯狂Java讲义','疯狂IOS讲义','轻量级 Java EE企业应用实战'&#125;\"&gt;&lt;/s:param&gt; &lt;/s:component&gt;&lt;hr&gt; 使用自定义主题，自定义主题目录&lt;br&gt; 使用myAnotherTemplate.jsp作为视图组件 &lt;s:component template=\"myAnotherTemplate.jsp\" templateDir=\"myTemplateDir\" theme=\"myTheme\"&gt; &lt;s:param name=\"list\" value=\"&#123;'疯狂Java讲义','疯狂IOS讲义','轻量级 Java EE企业应用实战'&#125;\"&gt;&lt;/s:param&gt; &lt;/s:component&gt; &lt;/body&gt;&lt;/html&gt;","categories":[],"tags":[]},{"title":"Struts2","slug":"Struts2","date":"2019-09-10T03:05:26.000Z","updated":"2019-09-17T08:13:41.259Z","comments":true,"path":"2019/09/10/Struts2/","link":"","permalink":"https://CPWS.github.io/2019/09/10/Struts2/","excerpt":"","text":"Struts2框架学习第一讲：回顾 Web开发的进程有两种模式，model1开发模式和model2开发模式。 Model1模式 优点：执行效率高，开发效率高，适合中小型项目。 缺点：逻辑比较混乱，页面混乱，维护困难，扩展不容易。 Model2 优点：解耦，将试图层和业务层分离。结构清晰，分工明确，维护方便，适合中大型项目。 缺点：执行效率相对Model1低,代码量大，重复代码比较多。 Model2又称为MVC设计模式。 M:model模型 V:view试图 C：controller控制 使用Servlet的MVC存在一些问题，有重复的代码—通过MVC框架来解决。 Servlet解决了什么问题 将url映射到一个java类的处理方法上。 接收请求的数据。 如何将处理结果显示到页面。 如何进行页面的跳转。第二讲：框架 Java学习路线 基础语法—-&gt;方法（目的：减少代码，代码重复利用）—-&gt;类（目的：代码复用，OOP：面向对象）—-&gt; jar包（多个类封装为jar包。目的：代码复用）—-&gt; 框架（一个或多个jar包。目的：代码重用） 从中体现最多的思想是：封装 什么是框架？ framework 框架是模板，模型，模子。 专业语言描述：框架是一个可重用的半成品。 为什么要学框架？ 提高开发效率，降低学习难度。 如何学习框架？ 框架是别人提供的，那么使用框架时，要遵守框架提供的规。 学习框架就是学习框架的规则。 框架有两个部分组成：可变的部分和不可变的部分。 常见的框架有哪些 struts2,strut1,spring,hibernate,Mybatis,Shiro,nutz等待。第三讲：Struts入门 什么是struts？ Apache Struts is a free, open-source, MVC framework for creating elegant, modern Java web applications. It favors convention over configuration, is extensible using a plugin architecture, and ships with plugins to support REST, AJAX and JSON. Struts2是一个开源、免费、轻量级的mvc框架 轻量级：如果一个框架没有侵入性，就说该框架是轻量级的。 侵入性：如果使用一个框架必须实现框架提供的接口，或者继承框架提供的类。 在Struts2之前是Struts1。Struts1出现很早，市场占有率比较高，所以不支持一些新的试图层展示技术，逐渐被淘汰。Struts2=Struts1+webwork Struts2是基于请求的mvc框架。 Struts2的目录结构 apps：应用案例。 docs：文档。 lib：使用的库包。 src：源码。 Struts2的Hello World案例 新建web项目 导入jar包 编写web.xml文件–配置struts2的前端控制器（分发器） 123456789&lt;!-- 配置struts2的前端控制器 --&gt;&lt;filter&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;url-pattern&gt;*.action&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 编写业务处理类 123456789101112131415161718package demo;/**** struts2的第一个案例* @author 朱楚利**/public class HelloWorld &#123; /*** * 在Struts2中，所有的业务方法都是public * 返回值都为String类，所有的业务方法都没有参数 * 方法名可以自定义，默认是execute() * @return */ public String execute() &#123; System.out.println(\"Hello struts2\"); return \"success\"; &#125;&#125; 在src下，添加strut2的配置文件，名称为为struts.xml，该配置文件名不能更改，并进行配置。 123456789101112131415&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE struts PUBLIC \"-//Apache Software Foundation//DTD Struts Configuration 2.3//EN\" \"http://struts.apache.org/dtds/struts-2.3.dtd\"&gt;&lt;struts&gt; &lt;package name=\"default\" namespace=\"/\" extends=\"struts-default\"&gt; &lt;!-- 配置action 配置url和处理类的方法进行映射 --&gt; &lt;action name=\"hello\" class=\"demo.HelloWorld\"&gt; &lt;result&gt;/hello.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; 编写hello.jsp页面 123456789101112&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt; &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Insert title here&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;hello world struts2&lt;/h1&gt; &lt;/body&gt; &lt;/html&gt; 发布项目并进行测试。 第四讲 配置讲解 web.xml 123456789101112131415 &lt;!-- 配置struts2的前端控制器 struts2框架开始工作的入口 接管请求 --&gt;&lt;filter&gt; &lt;!-- 名称自定义 --&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;!-- Struts2提供的控制器类 --&gt; &lt;filter-class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;url-pattern&gt;*.action&lt;/url-pattern&gt;&lt;/filter-mapping&gt; struts2.xml 该配置文件的文件名固定，并且只能放在src目录下。 1234567891011121314151617181920212223242526272829303132333435363738 &lt;struts&gt;&lt;!-- package 分模块管理 name属性属性值自定义但是不能重复，在一个项目中是唯一的 namespace属性命名空间与url请求路径直接相关 如：“/” 请求为 /hello.action; 如：\"/user\"，则请求路径为/user/hello.action extends 继承 必须直接或间接继承struts-default result的请求路径是相对namespace的属性值 --&gt;&lt;package name=\"default\" namespace=\"/\" extends=\"struts-default\"&gt; &lt;!-- 配置action 配置url和处理类的方法进行映射 name为请求名称 不加后缀 class 处理类的完全限定名称 包名+类名，如果不配置，由默认类来处理 com.opensymphony.xwork2.ActionSupport method指定处理请求的方法，默认是execute()方法 --&gt; &lt;action name=\"hello\" class=\"demo.HelloWorld\" method=\"hello\"&gt; &lt;!-- result结果集配置 name 结果集名称，和处理方法的返回之匹配 默认为success，可以自定义。 Struts2提供了5个返回结果： Action.SUCCESS： 执行成功，跳转到下一个试图 Action.NONE：执行成功，不需要试图展示 Action.ERRPR:执行失败，显示失败页面 Action.INPUT：要执行该Action需要更多的输入条件 Action.LOGIN：需要登陆后才能执行 type指定响应结果类型 dispatcher 请求转发，默认使用 redirect 请求重定向 redirectAction 重定向到另一个action result的值为跳转页面 不加\"/\"为相对namespace路径，建议使用绝对路径 --&gt; &lt;result name=\"\" type=\"\"&gt;/hello.jsp&lt;/result&gt; &lt;/action&gt;&lt;/package&gt; 第五讲 Struts2的执行流程 浏览器发起请求 –&gt; 服务器接收请求并交给Struts2的前端控制器 —–&gt; 根据请求的url查看struts.xml中的namespace+actionName是否存在 –&gt; 执行action所对应的类的对应方法 —&gt; 根据方法的执行结果到action的结果集进行匹配 –&gt; 响应结果。 Struts2 第六讲 Struts2的数据处理一 在struts2中，对表单数据的处理有三种：属性驱动，对象驱动，模型驱动 使用Strut2获取表达数据：只需要表单域数据名称和Action处理类的属性名称一致，并且提供属性的set方法，那么在Action处理类中即可获取表单数据。这种获取数据的方式称为属性驱动。 处理类： 1234567891011121314151617181920212223242526272829package demo;import com.opensymphony.xwork2.Action;/*** * Struts2数据处理案列 * @author 1huangzewei * */public class LoginAction &#123; private String username; private String password; //登陆处理业务 public String login() &#123; System.out.println(\"username=\"+username+\";password=\"+password); return Action.SUCCESS; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public void setPassword(String password) &#123; this.password = password; &#125; &#125; 12345678910111213141516&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Struts2的数据处理&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=\"login.action\" method=\"post\"&gt; username:&lt;input type=\"text\" name=\"username\"/&gt;&lt;br&gt; password:&lt;input type=\"password\" name=\"password\"/&gt;&lt;br&gt; &lt;input type=\"button\" value=\"登录\"/&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 123456789&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE struts PUBLIC \"-//Apache Software Foundation//DTD Struts Configuration 2.3//EN\" \"http://struts.apache.org/dtds/struts-2.3.dtd\"&gt;&lt;struts&gt; &lt;package name=\"login\" namespace=\"/\" extends=\"struts-default\"&gt; &lt;action name=\"login\" class=\"demo.LoginAction\" method=\"login\"&gt; &lt;result&gt;/success.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; 如果数据需要显示在页面上，那么该数据可以作为处理类的数据，处理方法后该属性有值，并且有该属性的get方法，那么在页面上可以直接通过el表达式获取。 1234567891011121314151617181920212223242526272829303132333435package demo;import com.opensymphony.xwork2.Action;/*** * Struts2数据处理案列 * @author 1huangzewei * */public class LoginAction &#123; private String username; private String password; //登陆处理业务 public String login() &#123; System.out.println(\"username=\"+username+\";password=\"+password); return Action.SUCCESS; &#125; public String getUsername() &#123; return username; &#125; public String getPassword() &#123; return password; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public void setPassword(String password) &#123; this.password = password; &#125; &#125; 12345678910111213&lt;%@ page language=\"java\" contentType=\"text/html; charset=utf-8\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"utf-8\"&gt;&lt;title&gt;成功页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;My First Struts Demo&lt;/h1&gt; &lt;h3&gt;恭喜$&#123;username&#125;登录成功&lt;h3&gt; &lt;h2&gt;$&#123;password&#125;&lt;h2&gt;&lt;/body&gt;&lt;/html&gt; 第七讲 数据处理二 IOC：控制反转 对象驱动方式获取属性：（重点） 在action的处理类中，属性以对象的形式存在，该属性对象只需声明并为其提供get方法和set方法即可，需要保证该属性对象有无参构造方法。 在表单域中的表单域名称以属性对象.属性对象的属性来命名。 这种方式比较重要 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//User类package entity;public class User &#123; //如果要提供构造函数，要提供一个无参构造方法 private String username; private String password; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; &#125;//处理类package demo;import com.opensymphony.xwork2.Action;import entity.User;/*** * Struts2数据处理案列 * @author 1huangzewei` * */public class LoginAction02 &#123; //保证对象要有无参的构造方法 private User user; //IOC方式 //登陆处理业务 public String login() &#123; System.out.println(\"username=\"+user.getUsername()+\"\\tpassword=\"+user.getPassword()); return Action.SUCCESS; &#125; public User getUser() &#123; return user; &#125; public void setUser(User user) &#123; this.user = user; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435&lt;!--显示成功页面--&gt;&lt;%@ page language=\"java\" contentType=\"text/html; charset=utf-8\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"utf-8\"&gt;&lt;title&gt;成功页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;My First Struts Demo&lt;/h1&gt; &lt;!-- 属性驱动 --&gt; &lt;!--&lt;h3&gt;恭喜$&#123;username&#125;登录成功&lt;h3&gt; &lt;h2&gt;$&#123;password&#125;&lt;h2&gt;--&gt; &lt;!-- 对象驱动 --&gt; &lt;h3&gt;恭喜$&#123;user.username&#125;登录成功&lt;h3&gt; &lt;h2&gt;$&#123;user.password&#125;&lt;h2&gt;&lt;/body&gt;&lt;/html&gt;&lt;!--登录页面--&gt;&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Struts2的数据处理&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=\"login02.action\" method=\"post\"&gt; username:&lt;input type=\"text\" name=\"user.username\"/&gt;&lt;br&gt; password:&lt;input type=\"password\" name=\"user.password\"/&gt;&lt;br&gt; &lt;input type=\"button\" value=\"登录\"/&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 模式驱动：在对象驱动中，页面的表单域名称比较复杂，如果对象属性比较多的情况下，代码量比较大。通过模式驱动可以解决这个问题。 模式驱动需要实现ModelDriver接口，并且主动将对象创建好。 12345678910111213141516171819202122232425262728293031323334//处理类package demo;import com.opensymphony.xwork2.Action;import com.opensymphony.xwork2.ModelDriven;import entity.User;/*** * Struts2数据处理案列：模型驱动 * @author 1huangzewei * */public class LoginAction03 implements ModelDriven&lt;User&gt;&#123; //保证对象要有无参的构造方法 private User user=new User(); //IOC方式 //登陆处理业务 public String login() &#123; System.out.println(\"username=\"+user.getUsername()+\"\\tpassword=\"+user.getPassword()); return Action.SUCCESS; &#125; public User getUser() &#123; return user; &#125; public void setUser(User user) &#123; this.user = user; &#125; @Override public User getModel() &#123; // TODO Auto-generated method stub return user; &#125;&#125; 12345678910111213141516171819202122232425262728293031&lt;!--登录页面--&gt;&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Struts2的数据处理&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=\"login02.action\" method=\"post\"&gt; username:&lt;input type=\"text\" name=\"username\"/&gt;&lt;br&gt; password:&lt;input type=\"password\" name=\"password\"/&gt;&lt;br&gt; &lt;input type=\"button\" value=\"登录\"/&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;&lt;!--显示页面--&gt;&lt;%@ page language=\"java\" contentType=\"text/html; charset=utf-8\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"utf-8\"&gt;&lt;title&gt;成功页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;My First Struts Demo&lt;/h1&gt; &lt;h3&gt;恭喜$&#123;username&#125;登录成功&lt;h3&gt; &lt;h2&gt;$&#123;password&#125;&lt;h2&gt;&lt;/body&gt;&lt;/html&gt; 第七讲 数据处理二 IOC：控制反转 对象驱动方式获取属性：（重点） 在action的处理类中，属性以对象的形式存在，该属性对象只需声明并为其提供get方法和set方法即可，需要保证该属性对象有无参构造方法。 在表单域中的表单域名称以属性对象.属性对象的属性来命名。 这种方式比较重要 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//User类package entity;public class User &#123; //如果要提供构造函数，要提供一个无参构造方法 private String username; private String password; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; &#125;//处理类package demo;import com.opensymphony.xwork2.Action;import entity.User;/*** * Struts2数据处理案列 * @author 1huangzewei * */public class LoginAction02 &#123; //保证对象要有无参的构造方法 private User user; //IOC方式 //登陆处理业务 public String login() &#123; System.out.println(\"username=\"+user.getUsername()+\"\\tpassword=\"+user.getPassword()); return Action.SUCCESS; &#125; public User getUser() &#123; return user; &#125; public void setUser(User user) &#123; this.user = user; &#125;&#125; 123456789101112131415161718&lt;!--显示成功页面--&gt;&lt;%@ page language=\"java\" contentType=\"text/html; charset=utf-8\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"utf-8\"&gt;&lt;title&gt;成功页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;My First Struts Demo&lt;/h1&gt; &lt;!-- 属性驱动 --&gt; &lt;!--&lt;h3&gt;恭喜$&#123;username&#125;登录成功&lt;h3&gt; &lt;h2&gt;$&#123;password&#125;&lt;h2&gt;--&gt; &lt;!-- 对象驱动 --&gt; &lt;h3&gt;恭喜$&#123;user.username&#125;登录成功&lt;h3&gt; &lt;h2&gt;$&#123;user.password&#125;&lt;h2&gt;&lt;/body&gt;&lt;/html&gt; 第八讲 action的几种创建方式 在Struts2中有三种方式来创建action处理类 实现action接口的方式来创建处理类,好处: 可以直接使用Action类提供的常量 必须重写默认的处理方法。 这种方法使用比较少。 123456789101112131415161718192021package com.zhuchuli.action;import com.opensymphony.xwork2.Action;/*** * 通过实现Action接口来创建处理类：好处 *实现action接口的方式可以使用Action提供的常量 *必须重写默认处理方法 *这种方式使用的比较少 * @author 1huangzewei * */public class HelloAction implements Action&#123; @Override public String execute() throws Exception &#123; System.out.println(\"action execute\"); return SUCCESS; &#125;&#125; 通过继承ActionSupport类来创建Action的处理类，Strut2推荐使用这种方式。 1234567891011121314151617package com.zhuchuli.action;import com.opensymphony.xwork2.ActionSupport;/*** * 通过继承ActionSupport创建Action处理类：好处 * 并且ActionSupport类提供了很多其他Struts2的功能。 * 比如：数据校验，国际化 * 内部已经提供了默认实现方法 * * @author 1huangzewei * */public class HelloAction02 extends ActionSupport&#123;&#125; 无侵入性的实现方式 12345678910111213141516package com.zhuchuli.action;import com.opensymphony.xwork2.Action;/*** * 无侵入性的实现方式 * @author 1huangzewei * */public class Hello02Action &#123; public String execute() &#123; System.out.println(\"无侵入性的实现方式\"); return Action.SUCCESS; &#125;&#125; 第九讲 Struts2配置讲解2 constant标签 1234567 &lt;!-- strut2的常量配置 --&gt;&lt;!-- 扩展名的配置 --&gt;&lt;constant name=\"struts.action.extension\" value=\"do,zhangsan,,action\"&gt;&lt;/constant&gt;&lt;!-- 设置页面字符集，页面解决 --&gt;&lt;constant name=\"struts.i18n.encoding\" value=\"utf-8\"&gt;&lt;/constant&gt;&lt;!-- 开发模式 --&gt;&lt;constant name=\"struts.devMode\" value=\"true\"&gt;&lt;/constant&gt; include标签：引入其他的配置文件，在团队开发中使用 1234567&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE struts PUBLIC \"-//Apache Software Foundation//DTD Struts Configuration 2.3//EN\" \"http://struts.apache.org/dtds/struts-2.3.dtd\"&gt;&lt;struts&gt; &lt;include file=\"struts2/conguration/system.xml\"&gt;&lt;/include&gt; &lt;/struts&gt; 第十讲 action的优化配置 在Struts2中，随着业务的增加，action的配置文件会急剧增加，导致了配置文件膨胀的问题。struts2中提供了三种方式来解决这个问题。 通过动态方法调用来解决。 通过通配符来解决。 通过注解来解决。 传统的action方式，配置文件会变得很庞大 1234567891011121314151617181920&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE struts PUBLIC \"-//Apache Software Foundation//DTD Struts Configuration 2.3//EN\" \"http://struts.apache.org/dtds/struts-2.3.dtd\"&gt;&lt;struts&gt; &lt;package name=\"default\" namespace=\"/\" extends=\"struts-default\"&gt; &lt;action name=\"save\" class=\"com.zhuchuli.action.UserAction\" method=\"save\"&gt; &lt;result type=\"redirectAction\"&gt;find&lt;/result&gt; &lt;/action&gt; &lt;action name=\"delete\" class=\"com.zhuchuli.action.UserAction\" method=\"delete\"&gt; &lt;result type=\"redirectAction\"&gt;find&lt;/result&gt; &lt;/action&gt; &lt;action name=\"update\" class=\"com.zhuchuli.action.UserAction\" method=\"update\"&gt; &lt;result type=\"redirectAction\"&gt;find&lt;/result&gt; &lt;/action&gt; &lt;action name=\"query\" class=\"com.zhuchuli.action.UserAction\" method=\"query\"&gt; &lt;result&gt;/list.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt; &lt;/struts&gt; 12345678910111213141516171819202122package com.zhuchuli.action;import com.opensymphony.xwork2.Action;public class UserAction &#123; //增加 public String save() &#123; return Action.SUCCESS; &#125; //删除 public String delete() &#123; return Action.SUCCESS; &#125; //修改 public String update() &#123; return Action.SUCCESS; &#125; //查询 public String query() &#123; return Action.SUCCESS; &#125;&#125; 通过动态方法解决该问题 在常量中开启动态方法调用。&lt;constant name=&quot;struts.enable.DynamicMethodInvocation&quot; value=&quot;true&quot;&gt;&lt;/constant&gt; 配置action,一个Action处理类，只需配置一次。不需要配置处理方法。 123456&lt;action name=\"userAction\" class=\"com.zhuchuli.action.UserAction\"&gt; &lt;result type=\"redirect\"&gt;userAction!query.action&lt;/result&gt; &lt;result type=\"redirect\"&gt;userAction!delete.action&lt;/result&gt; &lt;result name=\"list\"&gt;/list.jsp&lt;/result&gt; &lt;result name=\"delete\"&gt;/delete.jsp&lt;/result&gt;&lt;/action&gt; 调用处理方法，ActionName!method.action，例如:http://localhost:8080/Struts_study02/userAction!delete.action 注意：使用动态方法调用需要不同处理方法的返回值是否一致问题。会配置多个结果集。这种方式不推荐使用，不安全。 12345678&lt;!-- *表示一个或多个字符 --&gt;&lt;!-- 占位符&#123;1&#125;表示匹配第一个“*”的内容 --&gt;&lt;!-- 使用通配符配置时，需要注意如果有不是通配符的action，先匹配action再匹配通配符--&gt;&lt;!-- 在实际应用开发中，使用通配符比较常见 --&gt;&lt;action name=\"*\" class=\"com.zhuchuli.action.UserAction\" method=\"&#123;1&#125;\"&gt; &lt;result type=\"redirect\"&gt;query&lt;/result&gt; &lt;result&gt;/list.jsp&lt;/result&gt;&lt;/action&gt; 注意如果使用通配符配置，那么需要注意不同处理方法的返回值的问题。 使用注解来解决。 使用注解需要导入struts2-convention-plugin-2.3.37.jar、asm-3.3.jar、asm-commons-3.3.jar、asm-tree-3.3.jar 在处理类上填写相关注解 123456789101112131415161718192021222324252627282930313233343536373839package com.zhuchuli.action;import org.apache.struts2.convention.annotation.Action;import org.apache.struts2.convention.annotation.Namespace;import org.apache.struts2.convention.annotation.ParentPackage;import org.apache.struts2.convention.annotation.Result;@ParentPackage(value=\"struts-default\")@Namespace(value=\"/\")public class UserAction &#123; //增加 @Action(value=\"save\",results= &#123; @Result(location=\"/list.jsp\") &#125;) public String save() &#123; System.out.println(\"save\"); return \"success\"; &#125; //删除 public String delete() &#123; System.out.println(\"delete\"); return \"success\"; &#125; //修改 public String update() &#123; System.out.println(\"update\"); return \"success\"; &#125; // //查询 @Action(value=\"query\",results= &#123; @Result(name=\"list\",location=\"/list.jsp\") &#125;) public String query() &#123; System.out.println(\"query\"); return \"list\"; &#125;&#125; 第十一讲 ThreadLocal和ActionContext ThreadLocal是一个容器，存放在容器中的数据是线程安全的。 123456789101112131415161718package threadlocal;public class ThreadLocalDemo &#123; public static void main(String[] args) &#123; final ThreadLocal&lt;Integer&gt; th=new ThreadLocal&lt;Integer&gt;(); //向ThreadLocal中存放数据 th.set(23); new Thread(() -&gt; &#123; th.set(12); System.out.println(\"====================\"); //获取存放在容器中的数据 System.out.println(\"thread--&gt;\"+th.get());//12 &#125;) .start(); System.out.println(\"main --&gt;\"+th.get()); //23 &#125;&#125; ActionContext：是Struts2的上下文对象，它的本质是一个容器，也是一个Map结构的对象。ActionContext贯穿于整个Action生命周期，每次接受请求后都会新建一个ActionContext对象，将ServletAPI中的数据存入到ActionContext中，实现了struts2和Servlet的解耦，使得测试可以不依赖容器。而且ActionContext是线程安全的。由于每次请求都会重新创建ActionContext，导致执行效率比Servlet低。 ActionContext有六个对象： request：存放的是HttpServletRequest域中的数据。 session：存放的是HttpSession域中的数据。 application：存放的是ServletContext域中的数据。 parameters：存放的是请求参数 attr：存放的是request、session、application中的数据。 ValueStacke：业务处理类的相关数据。 12345678// helpers to get access to request/session/application scopeextraContext.put(\"request\", requestMap);extraContext.put(\"session\", sessionMap);extraContext.put(\"application\", applicationMap);extraContext.put(\"parameters\", parameterMap);AttributeMap attrMap = new AttributeMap(extraContext);extraContext.put(\"attr\", attrMap); ServletContext:是一个容器，是一个对象，相当于map。 第十二讲 ognl ognl：Object graph navigation language，对象导航图语言。 在Struts2中，ognl完成数据设置和类型转换两个功能。 在struts2中是通过ognl来设值和取值的。ActionContext作为ognl的上下文，ValueStack作为ognl的root对象 在struts2中使用ognl表达式获取数据需要使用struts2的标签库，使用struts2的标签库，需要注意一定是通过过滤器后才能解析struts2的标签 123456789101112131415161718192021222324252627282930313233343536373839package demo;import com.opensymphony.xwork2.Action;import com.opensymphony.xwork2.ActionContext;/*** * Struts2数据处理案列：属性驱动 * @author 1huangzewei * */public class LoginAction &#123; private String username; private String password; //登陆处理业务 public String login() &#123; System.out.println(\"username=\"+username+\";password=\"+password); ActionContext.getContext().getApplication().put(\"address\", \"北京尚学堂\"); return Action.SUCCESS; &#125; public String getUsername() &#123; return username; &#125; public String getPassword() &#123; return password; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public void setPassword(String password) &#123; this.password = password; &#125; &#125; 12345678910111213141516&lt;%@ page language=\"java\" contentType=\"text/html; charset=utf-8\"%&gt;&lt;%@ taglib prefix=\"s\" uri=\"/struts-tags\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"utf-8\"&gt;&lt;title&gt;成功页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;My First Struts Demo&lt;/h1&gt; 登录成功，欢迎&lt;s:property value=\"username\"/&gt;&lt;br&gt; &lt;h2&gt;$&#123;password&#125;&lt;h2&gt; &lt;h3&gt;&lt;s:property value=\"#application.address\"/&gt;&lt;/h3&gt; &lt;h3&gt;&lt;s:property value=\"#parameters.username\"/&gt;&lt;/h3&gt;&lt;/body&gt;&lt;/html&gt; ognl获取各种域中的数据如下： application：#application.username、#application[&#39;username&#39;]； session：#session.username、#session[&#39;username&#39;]； request：#request.username、#request[&#39;username&#39;]； parameters：#parameters.username、#parameter[&#39;username&#39;]； attr：#attr.username、#attr[&#39;username&#39;]，按pageContext、request、session、application顺序查找。 第十三讲 ServletAPI 在Struts2的开发中，依然需要使用到ServletAPI，比如用户登录之后，需要将用户信息保存到session中.在Struts2中有两种方式可以获取ServletAPI,一种解耦方式，一种是耦合方式。 解耦的实现方式 12345678910111213141516171819202122232425262728293031package com.zhuchuli.action;import com.opensymphony.xwork2.Action;import com.opensymphony.xwork2.ActionContext;import cn.zhuchuli.vo.User;public class LoginAction &#123; //保证对象要有无参的构造方法 private User user; public User getUser() &#123; return user; &#125; public void setUser(User user) &#123; this.user = user; &#125; public String login() &#123; System.out.println(\"username=\"+user.getUsername()+\"\\tpassword=\"+user.getPassword()); if(\"possible\".equals(user.getUsername()) &amp;&amp; \"123456\".equals(user.getPassword())) &#123; //用户登录成功，将用户信息写入到session ActionContext.getContext().getSession().put(\"currentUser\", user); //获取request Map&lt;String,Object&gt; req=(Map&lt;String,Object&gt;)ActionContext.getContext().get(\"request\"); return Action.SUCCESS; &#125; return Action.LOGIN; &#125;&#125; 耦合的方式 直接通过ServletContext获取 12345678910public String login() &#123; System.out.println(\"username=\"+user.getUsername()+\"\\tpassword=\"+user.getPassword()); if(\"possible\".equals(user.getUsername()) &amp;&amp; \"123456\".equals(user.getPassword())) &#123; //直接获取ServletAPI,所以是耦合的方式 HttpServletRequest req=ServletActionContext.getRequest(); req.getSession().setAttribute(\"currentUser\", user); return Action.SUCCESS; &#125; return Action.LOGIN;&#125; 通过ActionContext获取 1234567891011public String login() &#123; System.out.println(\"username=\"+user.getUsername()+\"\\tpassword=\"+user.getPassword()); if(\"possible\".equals(user.getUsername()) &amp;&amp; \"123456\".equals(user.getPassword())) &#123; //通过ActionContext方式获取ServletAPI System.out.println(\"通过ActionContext方式获取ServletAPI\"); HttpServletRequest req=(HttpServletRequest) ActionContext.getContext().get(StrutsStatics.HTTP_REQUEST); req.getSession().setAttribute(\"currentUser\", user); return Action.SUCCESS; &#125; return Action.LOGIN; &#125; 通过IOC方式直接获取到ServletAPI 12345678910111213141516171819202122232425262728public class LoginAction03 implements ServletRequestAware&#123; //保证对象要有无参的构造方法 private User user; private HttpServletRequest req; public User getUser() &#123; return user; &#125; public void setUser(User user) &#123; this.user = user; &#125; public String login() &#123; System.out.println(\"username=\"+user.getUsername()+\"\\tpassword=\"+user.getPassword()); if(\"possible\".equals(user.getUsername()) &amp;&amp; \"123456\".equals(user.getPassword())) ; //通过IOC方法获取ServletAPI对象 System.out.println(\"通过IOC方法获取ServletAPI对象\"); req.getSession().setAttribute(\"currentUser\", user); return Action.SUCCESS; &#125; return Action.LOGIN; &#125; @Override public void setServletRequest(HttpServletRequest request) &#123; this.req=request; &#125;&#125; 第十四讲 类型转换 在Struts2中，对常用的数据类型已经自动进行了类型装换工作。但是对于自定义类型，Struts2没法去做类型转换工作。需要自定义类型转换器来实现类型的转换。 类型转换的实现步骤： 新建一个类型转换并继承StrutsTypeConverter 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package cn.zhuchuli.pointconverter;import java.util.Map;import org.apache.struts2.util.StrutsTypeConverter;import cn.zhuchuli.vo.Point;/*** * 自定义类型转换器 * @author 1huangzewei * */public class PointConverter extends StrutsTypeConverter &#123; /** * 将表单提交的数据在这个方法中被转换。 * 返回值是目标点对象 * Converts one or more String values to the specified class. * * @param context the action context * @param values the String values to be converted, such as those submitted from an HTML form * @param toClass the class to convert to * @return the converted object */ @Override public Object convertFromString(Map context, String[] values, Class toClass) &#123; System.out.println(\"将String转化为指定类型\"); String value=values[0]; Point point=new Point(); point.setX(Integer.parseInt(value.substring(1,value.indexOf(\",\")))); point.setY(Integer.parseInt(value.substring(value.indexOf(\",\")+1,value.indexOf(\")\")))); return point; &#125; /** * Converts the specified object to a String. * * @param context the action context * @param o the object to be converted * @return the converted String * 使用ognl表达式获取值会调用该方法 */ @Override public String convertToString(Map context, Object o) &#123; // TODO Auto-generated method stub System.out.println(\"将指定的类型转化为String\"); Point p=(Point) o; return \"(\"+p.getX()+\",\"+p.getY()+\")\"; &#125;&#125; 在src下添加xwork-conversion.properties配置文件 # be converted type=converter cn.zhuchuli.vo.Point = cn.zhuchuli.pointconverter.PointConverter 第十五讲 数据校验一 （硬编码实现） 数据校验分为2类，一类是前端的数据校验，一般通过js实现，一类是后端的数据验证。在对一些安全级别较高项目都需要对其进行后台验证。Struts2提供了两种后台校验方法，一种是硬编码实现，一种是校验框架实现。 如果要使用struts2的数据校验功能，action需要继承ActionSupport类。在该类中提供了validate方法，可以将验证规则写在该方法中，只有方法执行通过之后，才会执行业务方法。 实现步骤 业务处理类 123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.zhuchuli.action;import java.util.regex.Matcher;import java.util.regex.Pattern;import com.opensymphony.xwork2.ActionSupport;import cn.zhuchuli.vo.User;/*** * 数据校验 * @author 1huangzewei * */public class UserAction extends ActionSupport&#123; private User user; //限制validate方法，方法通过执行后执行execute发明方法。 //默认该方法是通过的。 //在validate方法中，添加了FieldError或者ActionError那么该方法将执行不能通过，并且返回结果集为INPUT // @Override public void validate() &#123; System.out.println(\"-------validate-------\"); Pattern p=Pattern.compile(\"[\\\\w]+[A-Za-z0-9]&#123;6,16&#125;\"); Matcher m=p.matcher(user.getName()); if(!m.find()) &#123; //用户名不合法，添加错误信息 this.addFieldError(\"user.name\", \"用户名不合法\"); &#125; super.validate(); &#125; public String execute() &#123; System.out.println(\"------execute---------\"); System.out.println(user); return SUCCESS; &#125; public User getUser() &#123; return user; &#125; public void setUser(User user) &#123; this.user = user; &#125; &#125; 在配置文件中配置input结果集 1234&lt;action name=\"user\" class=\"com.zhuchuli.action.UserAction\"&gt; &lt;result&gt;/success.jsp&lt;/result&gt; &lt;result name=\"input\"&gt;/save.jsp&lt;/result&gt;&lt;/action&gt; 在页面中添加struts2的标签库，并且添加错误标签 123456789101112131415161718&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib prefix=\"s\" uri=\"/struts-tags\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=\"user.action\" method=\"post\"&gt; name:&lt;input type=\"text\" name=\"user.name\"/&gt;&lt;s:fielderror fieldName=\"user.name\"&gt;&lt;/s:fielderror&gt;&lt;br&gt; sex:&lt;input type=\"text\" name=\"user.sex\"/&gt;&lt;br&gt; age:&lt;input type=\"text\" name=\"user.age\"/&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"登录\"/&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 通过上述方法来实现数据校验会有一个问题。一个业务类中有多个业务方法，并且每个业务方法的验证规则可能不一致，但是所有的业务方法都会通过validate。导致功能不能实现。在struts2中，如果一个业务类中有多个业务方法，那么需要为每个业务方法添加自己的验证方法。验证方法的命名规则为validate+业务方法名(首字母大写)。这样执行业务方法时，执行顺序为validateXxxx ---&gt; validate ---&gt; xxxx。这样的话，validate方法中填写的公共的验证方法。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package com.zhuchuli.action;import java.util.regex.Matcher;import java.util.regex.Pattern;import com.opensymphony.xwork2.ActionSupport;import cn.zhuchuli.vo.User;/*** * 数据校验 * @author 1huangzewei * */public class UserAction extends ActionSupport&#123; private User user; //限制validate方法，方法通过执行后执行execute发明方法。 //默认该方法是通过的。 //在validate方法中，添加了FieldError或者ActionError那么该方法将执行不能通过，并且返回结果集为INPUT // @Override public void validate() &#123; System.out.println(\"-------validate-------\"); Pattern p=Pattern.compile(\"[\\\\w]+[A-Za-z0-9]&#123;6,16&#125;\"); Matcher m=p.matcher(user.getName()); if(!m.find()) &#123; //用户名不合法，添加错误信息 this.addFieldError(\"user.name\", \"用户名不合法\"); &#125; super.validate(); &#125; public void validateExecute() &#123; System.out.println(\"-------validateExecute-------\"); Pattern p=Pattern.compile(\"[\\\\w]+[A-Za-z0-9]&#123;6,16&#125;\"); Matcher m=p.matcher(user.getName()); if(!m.find()) &#123; //用户名不合法，添加错误信息 this.addFieldError(\"user.name\", \"用户名不合法\"); &#125; super.validate(); &#125; public String execute() &#123; System.out.println(\"------execute---------\"); System.out.println(user); return SUCCESS; &#125; public User getUser() &#123; return user; &#125; public void setUser(User user) &#123; this.user = user; &#125; &#125; 第十五讲 数据校验二（使用Struts2提供的校验框架实现数据校验） 实现步骤 创建jsp页面 123456789101112131415161718&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib prefix=\"s\" uri=\"/struts-tags\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=\"user.action\" method=\"post\"&gt; name:&lt;input type=\"text\" name=\"user.name\"/&gt;&lt;s:fielderror fieldName=\"user.name\"&gt;&lt;/s:fielderror&gt;&lt;br&gt; sex:&lt;input type=\"text\" name=\"user.sex\"/&gt;&lt;br&gt; age:&lt;input type=\"text\" name=\"user.age\"/&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"登录\"/&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 创建Action类 12345678910111213141516171819202122232425package com.zhuchuli.action;import com.opensymphony.xwork2.ActionSupport;import cn.zhuchuli.vo.User;public class UserFormAction extends ActionSupport&#123; private User user; public String execute() &#123; System.out.println(\"------execute---------\"); System.out.println(user); return SUCCESS; &#125; public User getUser() &#123; return user; &#125; public void setUser(User user) &#123; this.user = user; &#125;&#125; 在Action类所在包下，添加校验规则文件以ActionClassName-validation.xml命名 123456789101112131415161718&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;!DOCTYPE validators PUBLIC \"-//Apache Struts//XWork Validator 1.0//EN\" \"http://struts.apache.org/dtds/xwork-validator-1.0.dtd\"&gt; &lt;validators&gt; &lt;!--field表示对哪个表单域进行验证 --&gt; &lt;field name=\"user.name\"&gt; &lt;!-- 字段验证器 Struts2默认提供了很多验证器 --&gt; &lt;field-validator type=\"requiredstring\"&gt; &lt;message&gt;你必须输入姓名。&lt;/message&gt; &lt;/field-validator&gt; &lt;field-validator type=\"stringlength\"&gt; &lt;param name=\"maxLength\"&gt;10&lt;/param&gt; &lt;param name=\"minLength\"&gt;4&lt;/param&gt; &lt;message&gt;你必须输入姓名在$&#123;maxLength&#125;和$&#123;minLength&#125;之间&lt;/message&gt; &lt;/field-validator&gt; &lt;/field&gt; &lt;/validators&gt; 配置Struts.xml文件 12345678910111213141516171819&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE struts PUBLIC \"-//Apache Software Foundation//DTD Struts Configuration 2.3//EN\" \"http://struts.apache.org/dtds/struts-2.3.dtd\"&gt;&lt;struts&gt; &lt;package name=\"default\" namespace=\"/\" extends=\"struts-default\"&gt; &lt;!-- &lt;action name=\"point\" class=\"com.zhuchuli.action.PointAction\"&gt; &lt;result&gt;/success.jsp&lt;/result&gt; &lt;/action&gt; &lt;action name=\"user\" class=\"com.zhuchuli.action.UserAction\"&gt; &lt;result&gt;/success.jsp&lt;/result&gt; &lt;result name=\"input\"&gt;/save.jsp&lt;/result&gt; &lt;/action&gt; --&gt; &lt;action name=\"user\" class=\"com.zhuchuli.action.UserFormAction\"&gt; &lt;result&gt;/success.jsp&lt;/result&gt; &lt;result name=\"input\"&gt;/save.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt; &lt;/struts&gt; 第十七讲 Struts2拦截器 struts2中的所有功能都是由拦截器来实现的。拦截器是Struts2的核心。拦截器和过滤器非常相似，过滤器过滤的是所有的请求，拦截器纸过滤action，并且在struts2中所有的功能都是可插拔的。在struts2中还可以自定义拦截器来实现一些struts2没有提供的功能。在struts2中拦截器的实现是通过代理来实现的。（AOP）在Struts2中拦截器都是单列的，所有的action共享相同的拦截器，所以在拦截器定义常量时要注意线程安全问题。 Struts2中提供很多拦截器来实现各种功能，在开发中可以根据不同的应用选择不同的拦截器来实现功能。Struts2提供了一系列默认的拦截器（拦截器栈）来实现功能。 默认拦截器说明 alias：对于HTTP请求包含的参数设置别名 autowiring：将某些JavaBean实例自动绑定到其他Bean对应的属性中。有点类似Spring的自动绑定，在Spring部分会详细说明。 Chain：在Web项目开发中，以前使用Struts开发时候经常碰到两个Action互相传递参数或属性的情况。该拦截器就是让前一Action的参数可以在现有Action中使用。 conversionError：从ActionContext中将转化类型时候发生的错误添加到Action的值域错误中，在校验时候经常被使用到来显示类型转化错误的信息。 cookie：从Struts&lt; xmlnamespace prefix=&quot;ST1&quot; &gt;2.0.7版本开始，可以把cookie注入Action中可设置的名字或值中。 createSession：自动创建一个HTTP的Session，尤其是对需要HTTP的Session的拦截器特别有用。比如下面介绍的TokenInterceptor。 debugging：用来对在视图间传递的数据进行调试。 ExecAndWait：不显式执行Action，在视图上显示给用户的是一个正在等待的页面，但是Action其实是在“背后”正在执行着。该拦截器尤其在对进度条进行开发的时候特别有用。 exception：将异常和Action返回的result相映射。 fileUpload：支持文件上传功能的拦截器。 i18n：支持国际化的拦截器。 logger：拥有日志功能的拦截器。 modelDriven：Action执行该拦截器时候，可以将getModel方法得到的result值放入值栈中 scopedModelDriven：执行该拦截器时候，它可以从一个scope范围检索和存储model值，通过调用setModel方法去设置model值。 params：将HTTP请求中包含的参数值设置到Action中。 prepare：假如Action继承了Preparable接口，则会调用prepare方法。 staticParams：对于在struts.xml文件中Action中设置的参数设置到对应的Action中。 scope：在session或者application范围中设置Action的状态 servletConfig：该拦截器提供访问包含HttpServletResquest和HttpServletResponse对象的Map的方法。 timer：输出Action的执行时间。 token：避免重复提交的校验拦截器 tokenSession：和token拦截器类似，但它还能存储提交的数据到session里。 validation：运行在action-validation.xml(校验章节将介绍)文件中定义的校验规则。 workflow：在Action中调用validate校验方法。如果Action有错误则返回到input视图。 store：执行校验功能时候，该拦截器提供存储和检索Action的所有错误和正确信息的功能。 checkbox：视图中如果有checkbox存在的情况，该拦截器自动将unchecked的checkbox当作一个参数（通常值为“false”）记录下来。这样可以用一个隐藏的表单值来记录所有未提交的checkbox，而且缺省unchecked的checkbox值是布尔类型的，如果视图中checkbox的值设置的不是布尔类型，它就会被覆盖成布尔类型的值。 profiling：通过参数来激活或不激活分析检测功能，前提是Web项目是在开发模式下。（涉及到调试和性能检验时使用） roles：进行权限配置的拦截器，如果登录用户拥有相应权限才去执行某一特定Action。 Struts2中的默认拦截器是定义在struts-default.xml中。这些拦截器都是定义在struts-default包下的。所以在使用struts2时定义的package要直接或间接继承struts-default 常见内置拦截器的使用，使用内置拦截器是需要引用拦截器。 Timer拦截器的使用 创建action类 12345678package com.zhuchuli.interceptor;public class TimerAction &#123; public String execute() &#123; System.out.println(\"Hello action\"); return \"none\"; &#125;&#125; 在配置文件中进行配置 1234567891011&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE struts PUBLIC \"-//Apache Software Foundation//DTD Struts Configuration 2.3//EN\" \"http://struts.apache.org/dtds/struts-2.3.dtd\"&gt;&lt;struts&gt; &lt;package name=\"default\" namespace=\"/\" extends=\"struts-default\"&gt; &lt;action name=\"interceptor\" class=\"com.zhuchuli.interceptor.TimerAction\"&gt; &lt;result&gt;&lt;/result&gt; &lt;!-- 使用拦截器时，需要在指定的action中引用拦截器 --&gt; &lt;interceptor-ref name=\"timer\"&gt;&lt;/interceptor-ref&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; token拦截器的使用 创建Action类 12345678910111213141516171819202122232425package com.zhuchuli.interceptor;import com.opensymphony.xwork2.Action;import com.opensymphony.xwork2.ActionSupport;import com.zhuchuuli.vo.User;public class UserAction extends ActionSupport&#123; private User user; public String toSave() &#123; return Action.SUCCESS; &#125; public String save() &#123; System.out.println(\"add user to database\"); System.out.println(user); return Action.SUCCESS; &#125; public User getUser() &#123; return user; &#125; public void setUser(User user) &#123; this.user = user; &#125; &#125; 在页面中添加token标签 123456789101112131415161718&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib prefix=\"s\" uri=\"/struts-tags\" %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;提交页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=\"interceptor.action\" method=\"post\"&gt; &lt;s:token&gt;&lt;/s:token&gt; name:&lt;input type=\"text\" name=\"user.name\"/&gt;&lt;br&gt; age:&lt;input type=\"text\" name=\"user.age\"/&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"save\" /&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 在action中引用token 1234567891011121314&lt;action name=\"save\" class=\"com.zhuchuli.interceptor.UserAction\" method=\"save\"&gt; &lt;interceptor-ref name=\"token\"&gt;&lt;/interceptor-ref&gt; &lt;interceptor-ref name=\"basicStack\"/&gt; &lt;result&gt;/success.jsp&lt;/result&gt; &lt;result name=\"invalid.token\"&gt;/invalid.jsp&lt;/result&gt; &lt;!-- 使用拦截器时，需要在指定的action中引用拦截器 --&gt; &lt;!-- &lt;interceptor-ref name=\"timer\"&gt;&lt;/interceptor-ref&gt; --&gt; &lt;!-- 当用户重复提交时，会返回invalid.token结果集 --&gt; &lt;/action&gt; &lt;action name=\"toSave\" class=\"com.zhuchuli.interceptor.UserAction\" method=\"toSave\"&gt; &lt;result&gt;/save.jsp&lt;/result&gt; &lt;/action&gt; 编写失效页面。 123456789101112&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;表单不能重复提交&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 第十八讲 自定义拦截器 在开发中，经常会使用到struts2中没有提供的一些功能，这时需要我们自定义拦截器来实现。当引用自定义拦截器后，struts2提供的默认拦截器将不起作用，需要重新引入。 自定义拦截器的实现步骤： 定义拦截器 123456789101112131415161718192021222324252627282930313233343536373839package com.zhuchuli.myinterceptor;import com.opensymphony.xwork2.ActionInvocation;import com.opensymphony.xwork2.interceptor.Interceptor;/*** * 自定义拦截器 * 有两种实现方式 * 实现Interceptor接口 * 继承AbstractInterceptor类 * @author 1huangzewei * */public class MyInterceptor implements Interceptor&#123; @Override public void destroy() &#123; // TODO Auto-generated method stub &#125; @Override public void init() &#123; // TODO Auto-generated method stub &#125; //拦截器的主体实现 /*** * 当拦截器的方法被调用执行后，需要调用 invocation.invoke调用下一个拦截器。 * 如果没有拦截器，那么执行action中的业务方法。 */ @Override public String intercept(ActionInvocation invocation) throws Exception &#123; System.out.println(\"-------------------自定义拦截器被执行了o-------------------\"); //返回值为结果集 return invocation.invoke(); &#125;&#125; 在package中配置拦截器 1234&lt;!-- 拦截器的配置 --&gt;&lt;interceptors&gt; &lt;interceptor name=\"MyIntercept\" class=\"com.zhuchuli.myinterceptor.MyInterceptor\"&gt;&lt;/interceptor&gt;&lt;/interceptors&gt; 在使用action中引用拦截器 123456&lt;action name=\"timer\" class=\"com.zhuchuli.interceptor.TimerAction\"&gt; &lt;interceptor-ref name=\"timer\"&gt;&lt;/interceptor-ref&gt; &lt;!-- 使用自定义拦截器 --&gt; &lt;interceptor-ref name=\"MyIntercept\"&gt;&lt;/interceptor-ref&gt; &lt;result&gt;/success.jsp&lt;/result&gt;&lt;/action&gt; 登录拦截器的实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.zhuchuli.myinterceptor;import com.opensymphony.xwork2.Action;import com.opensymphony.xwork2.ActionInvocation;import com.opensymphony.xwork2.interceptor.Interceptor;/*** * 登录拦截器的实现 * @author 1huangzewei * */public class LoginInterceptor implements Interceptor&#123; @Override public void destroy() &#123; // TODO Auto-generated method stub &#125; @Override public void init() &#123; // TODO Auto-generated method stub &#125; /** * 判断是否是登录的action，如果是，继续执行 * 如果不是 判断session中是否存在用户， * 如果没有，跳转到登录界面 * 如果有继续执行 */ @Override public String intercept(ActionInvocation invocation) throws Exception &#123; String actionName= invocation.getProxy().getActionName(); if(\"login\".equals(actionName)) &#123; return invocation.invoke(); &#125; Object currentUser=invocation.getInvocationContext().getSession().get(\"currentUser\"); if(currentUser!=null) &#123; return invocation.invoke(); &#125; return Action.LOGIN; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839&lt;package name=\"default\" namespace=\"/\" extends=\"struts-default\"&gt; &lt;!-- 拦截器的配置 --&gt; &lt;interceptors&gt; &lt;interceptor name=\"MyIntercept\" class=\"com.zhuchuli.myinterceptor.MyInterceptor\"&gt;&lt;/interceptor&gt; &lt;interceptor name=\"loginIntercept\" class=\"com.zhuchuli.myinterceptor.LoginInterceptor\"&gt;&lt;/interceptor&gt; &lt;/interceptors&gt; &lt;!-- 配置全局结果集 --&gt; &lt;!-- 当前action结果集找不到，就去找全局结果集，如果再找不到，返回404 --&gt; &lt;global-results&gt; &lt;result name=\"login\"&gt;/login.jsp&lt;/result&gt; &lt;result name=\"input\"&gt;/login.jsp&lt;/result&gt; &lt;/global-results&gt; &lt;action name=\"timer\" class=\"com.zhuchuli.interceptor.TimerAction\"&gt; &lt;interceptor-ref name=\"timer\"&gt;&lt;/interceptor-ref&gt; &lt;!-- 使用自定义拦截器 --&gt; &lt;interceptor-ref name=\"MyIntercept\"&gt;&lt;/interceptor-ref&gt; &lt;result&gt;/success.jsp&lt;/result&gt; &lt;interceptor-ref name=\"loginIntercept\"/&gt; &lt;/action&gt; &lt;action name=\"save\" class=\"com.zhuchuli.interceptor.UserAction\" method=\"save\"&gt; &lt;!-- 使用拦截器时，需要在指定的action中引用拦截器 --&gt; &lt;!-- &lt;interceptor-ref name=\"timer\"&gt;&lt;/interceptor-ref&gt; --&gt; &lt;!-- 当用户重复提交时，会返回invalid.token结果集 --&gt; &lt;interceptor-ref name=\"token\"&gt;&lt;/interceptor-ref&gt; &lt;interceptor-ref name=\"basicStack\"/&gt; &lt;interceptor-ref name=\"loginIntercept\"/&gt; &lt;result&gt;/success.jsp&lt;/result&gt; &lt;result name=\"invalid.token\"&gt;/invalid.jsp&lt;/result&gt; &lt;/action&gt; &lt;action name=\"toSave\" class=\"com.zhuchuli.interceptor.UserAction\" method=\"toSave\"&gt; &lt;result&gt;/save.jsp&lt;/result&gt; &lt;interceptor-ref name=\"loginIntercept\"/&gt; &lt;/action&gt; &lt;action name=\"login\" class=\"com.zhuchuli.interceptor.UserAction02\" method=\"login\"&gt; &lt;result&gt;/success.jsp&lt;/result&gt; &lt;interceptor-ref name=\"loginIntercept\"/&gt; &lt;interceptor-ref name=\"basicStack\"/&gt; &lt;/action&gt; &lt;/package&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.zhuchuli.interceptor;import java.util.regex.Matcher;import java.util.regex.Pattern;import org.apache.struts2.ServletActionContext;import com.opensymphony.xwork2.Action;import com.opensymphony.xwork2.ActionSupport;import com.zhuchuuli.vo.User02;public class UserAction02 extends ActionSupport&#123; private User02 user; //进行数据校验 public void validate() &#123; Pattern p=Pattern.compile(\"[\\\\w]+[A-Za-z0-9]&#123;6,16&#125;\"); Matcher m=p.matcher(user.getPwd()); if(!((user.getName().length()&gt;=4||user.getName().length()&lt;=10)&amp;&amp; m.find())) &#123; //用户名不合法，添加错误信息 this.addFieldError(\"user.name\", \"用户名或密码不合法\"); &#125; &#125; public String toSave() &#123; return Action.SUCCESS; &#125; public String login() &#123; System.out.println(\"------login---------\"); //ServletActionContext.getRequest().getSession().setAttribute(\"currentUser\", user); //采用解耦的方式进行SevletAPI操作 if(\"possible\".equals(user.getName())&amp;&amp;\"123456\".equals(user.getPwd())) &#123; ServletActionContext.getContext().getSession().put(\"currentUser\", user); System.out.println(ServletActionContext.getContext().getSession().get(\"currentUser\")); return Action.SUCCESS; &#125;else &#123; return Action.LOGIN; &#125; &#125; public User02 getUser() &#123; return user; &#125; public void setUser(User02 user) &#123; this.user = user; &#125; &#125; 12345678910111213141516171819package com.zhuchuuli.vo;public class User02 &#123; private String name; private String pwd; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getPwd() &#123; return pwd; &#125; public void setPwd(String pwd) &#123; this.pwd = pwd; &#125; &#125; 12345678910111213141516171819&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib prefix=\"s\" uri=\"/struts-tags\" %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=\"login.action\" method=\"post\"&gt; 用户名：&lt;input type=\"text\" name=\"user.name\"/&gt;&lt;br&gt; 密码：&lt;input type=\"password\" name=\"user.pwd\"/&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"登录\"/&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 第十九讲 拦截器栈和方法拦截器 拦截器栈：就是一组拦截器，放在一个配置中，在拦截器栈中可以引用多个拦截器，在真正需要调用时只需要一个栈即可,方便引用,拦截器中可以引用另外一个拦截器栈, 1234567891011&lt;!-- 拦截器的配置 --&gt;&lt;interceptors&gt; &lt;interceptor name=\"MyIntercept\" class=\"com.zhuchuli.myinterceptor.MyInterceptor\"&gt;&lt;/interceptor&gt; &lt;interceptor name=\"loginIntercept\" class=\"com.zhuchuli.myinterceptor.LoginInterceptor\"&gt;&lt;/interceptor&gt; &lt;!-- 拦截器栈 --&gt; &lt;interceptor-stack name=\"myStack\"&gt; &lt;interceptor-ref name=\"basicStack\"/&gt; &lt;interceptor-ref name=\"loginIntercept\"/&gt; &lt;interceptor-ref name=\"basicStack\"/&gt; &lt;/interceptor-stack&gt;&lt;/interceptors&gt; 拦截器栈的引用，与拦截器引用一致，可以将拦截器栈当做拦截器来使用 1&lt;interceptor-ref name=\"myStack\"&gt;&lt;/interceptor-ref&gt; 设置默认拦截器栈 12&lt;!-- 设置默认拦截器--&gt;&lt;!-- &lt;default-action-ref name=\"myStack\"&gt;&lt;/default-action-ref&gt;--&gt; Struts2定义了默认的拦截器栈是defaultStack，里面有默认的18个拦截器。 拦截器拦截的是整个action，action中的所有业务方法都会被拦截。比较粗粒度。有时只需拦截action中某个方法或某几个方法就能实现功能，那么拦截器就会造成效率降低。这时可以通过方法拦截器来解决这个问题。 方法拦截器的实现 123456789101112131415161718192021222324package com.zhuchuli.myinterceptor;import com.opensymphony.xwork2.ActionInvocation;import com.opensymphony.xwork2.interceptor.MethodFilterInterceptor;/*** * 方法拦截器的实现 继承 MethodFilterInterceptor * @author 1huangzewei * */public class MethodInterceptor extends MethodFilterInterceptor&#123; /** * */ private static final long serialVersionUID = 1L; @Override protected String doIntercept(ActionInvocation invocation) throws Exception &#123; System.out.println(\"方法拦截器被执行\"); return invocation.invoke(); &#125;&#125; 12345678910111213141516&lt;interceptors&gt; &lt;interceptor name=\"MyIntercept\" class=\"com.zhuchuli.myinterceptor.MyInterceptor\"&gt;&lt;/interceptor&gt; &lt;interceptor name=\"loginIntercept\" class=\"com.zhuchuli.myinterceptor.LoginInterceptor\"&gt;&lt;/interceptor&gt; &lt;interceptor name=\"methodInterceptor\" class=\"com.zhuchuli.myinterceptor.MethodInterceptor\"&gt;&lt;/interceptor&gt; &lt;!-- 拦截器栈 --&gt; &lt;interceptor-stack name=\"myStack\"&gt; &lt;interceptor-ref name=\"basicStack\"/&gt; &lt;interceptor-ref name=\"loginIntercept\"/&gt; &lt;interceptor-ref name=\"basicStack\"/&gt; &lt;interceptor-ref name=\"methodInterceptor\"&gt; &lt;!-- 配置哪些方法被拦截 --&gt; &lt;param name=\"includeMethods\"&gt;timer,toSave&lt;/param&gt; &lt;!-- 配置哪些方法不被拦截 --&gt; &lt;param name=\"excludeMethods\"&gt;timer,toSave&lt;/param&gt; &lt;/interceptor-ref&gt; &lt;/interceptor-stack&gt;&lt;/interceptors&gt; 第二十讲 内置拦截器的使用情况。第二十一讲 struts 文件上传（使用默认的内置拦截器） 在大部分应用中都有文件上传的功能。servlet中可以使用第三方插件来实现文件上传：smartfileupload、commons-fileuoload 文件上传步骤 添加jsp页面，注意表单提交必须是post提交，并且设置`enctype=”multipart/form-data” 1234567891011121314&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;文件上传&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=\"upload.action\" method=\"post\" enctype=\"multipart/form-data\"&gt; 文件:&lt;input type=\"file\" name=\"file\"/&gt;&lt;input type=\"submit\" value=\"上传\"&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 添加文件上传处理类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package com.zhuchuli.action;import java.io.File;import java.io.IOException;import org.apache.commons.io.FileUtils;import org.apache.struts2.ServletActionContext;import com.opensymphony.xwork2.Action;/*** * 文件上传处理类 * @author 1huangzewei * */public class UploadAction &#123; //File属性名与表单域相同 类型为File private File file; //上传文件的名称，也是由struts2设置好 //属性名=表单域名+FileName private String fileFileName; //文件类型 = 表单域名+ContentType private String fileContentType; //上传文件的业务方法 public String upload() &#123; //获取上传文件目录 String path=ServletActionContext.getServletContext().getRealPath(\"/upload\"); try &#123; FileUtils.copyFile(file, new File(path,fileFileName)); return Action.SUCCESS; &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; return Action.ERROR; &#125; public File getFile() &#123; return file; &#125; public void setFile(File file) &#123; this.file = file; &#125; public String getFileFileName() &#123; return fileFileName; &#125; public void setFileFileName(String fileFileName) &#123; this.fileFileName = fileFileName; &#125; public String getFileContentType() &#123; return fileContentType; &#125; public void setFileContentType(String fileContentType) &#123; this.fileContentType = fileContentType; &#125; &#125; 添加配置文件 12345678910111213141516171819&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE struts PUBLIC \"-//Apache Software Foundation//DTD Struts Configuration 2.3//EN\" \"http://struts.apache.org/dtds/struts-2.3.dtd\"&gt;&lt;struts&gt; &lt;!-- 设置文件上传的临时目录 --&gt; &lt;constant name=\"struts.multipart.saveDir\" value=\"d:/\"&gt;&lt;/constant&gt; &lt;!-- 常量设置 --&gt;&lt;!-- 设置上传文件总大小 --&gt; &lt;constant name=\"struts.multipart.maxSize\" value=\"67388135\"&gt;&lt;/constant&gt; &lt;package name=\"default\" namespace=\"/\" extends=\"struts-default\"&gt; &lt;action name=\"upload\" class=\"com.zhuchuli.action.UploadAction\" method=\"upload\"&gt; &lt;result&gt;/success.jsp&lt;/result&gt; &lt;result name=\"error\"&gt;/error.jsp&lt;/result&gt; &lt;interceptor-ref name=\"fileupload\"&gt; &lt;!-- 设置上传单个文件的大小 --&gt; &lt;param name=\"maximumSize\"&gt;67388135&lt;/param&gt; &lt;/interceptor-ref&gt; &lt;interceptor-ref name=\"basicStack\"&gt;&lt;/interceptor-ref&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; 第二十二讲 批量文件上传 批量文件下载 Jsp页面 123456789101112131415&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;文件上传&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=\"batch.action\" method=\"post\" enctype=\"multipart/form-data\"&gt; 文件1:&lt;input type=\"file\" name=\"file\"/&gt;&lt;br&gt;文件2:&lt;input type=\"file\" name=\"file\"/&gt;&lt;br&gt;&lt;input type=\"submit\" value=\"上传\"&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;&gt;&gt;* 批量下载业务处理方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package com.zhuchuli.action;import java.io.File;import java.io.IOException;import org.apache.commons.io.FileUtils;import org.apache.struts2.ServletActionContext;import com.opensymphony.xwork2.Action;import com.opensymphony.xwork2.ActionSupport;/*** * 文件上传处理类 * @author 1huangzewei * */public class BatchUploadAction extends ActionSupport&#123; /** * */ private static final long serialVersionUID = 1L; //File属性名与表单域相同 类型为File private File file[]; //上传文件的名称，也是由struts2设置好 //属性名=表单域名+FileName private String fileFileName[]; //文件类型 = 表单域名+ContentType private String fileContentType[]; //上传文件的业务方法 public String upload() &#123; //System.out.println(file+\";\"+fileFileName); //获取上传文件目录 String path=ServletActionContext.getServletContext().getRealPath(\"/upload\"); try &#123; for(var i=0;i&lt;file.length;i++) &#123; FileUtils.copyFile(file[i], new File(path,fileFileName[i])); &#125; return Action.SUCCESS; &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; return Action.ERROR; &#125; public File[] getFile() &#123; return file; &#125; public void setFile(File[] file) &#123; this.file = file; &#125; public String[] getFileFileName() &#123; return fileFileName; &#125; public void setFileFileName(String[] fileFileName) &#123; this.fileFileName = fileFileName; &#125; public String[] getFileContentType() &#123; return fileContentType; &#125; public void setFileContentType(String[] fileContentType) &#123; this.fileContentType = fileContentType; &#125; &#125; struts.xml配置文件 12345678&lt;action name=\"batch\" class=\"com.zhuchuli.action.BatchUploadAction\" method=\"upload\"&gt; &lt;result&gt;/success.jsp&lt;/result&gt; &lt;result name=\"error\"&gt;/error.jsp&lt;/result&gt; &lt;interceptor-ref name=\"fileUpload\"&gt; &lt;param name=\"maximumSize\"&gt;67388135&lt;/param&gt; &lt;/interceptor-ref&gt; &lt;interceptor-ref name=\"basicStack\"&gt;&lt;/interceptor-ref&gt;&lt;/action&gt; 第二十三讲 文件下载 文件下载可以通过超链接直接实现，但是通过超链接直接下载的文件不安全。任何用户得到超链接都可以下载，没法权限的控制。浏览器如果能打开文件，那么浏览会直接将文件打开。 通过流的方式来实现文件下载 业务处理方法 1234567891011121314151617181920212223242526272829303132333435363738394041package com.zhuchuli.action;import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.InputStream;import org.apache.struts2.ServletActionContext;import com.opensymphony.xwork2.Action;/*** * 实现文件下载 * @author 1huangzewei *高等数学 水以v立方厘米/秒的输的灌入圆锥形水箱.水箱尖点朝下 */public class DownloadAction &#123; private String fileName; public String execute() &#123; System.out.println(\"Download\"); return Action.SUCCESS; &#125; public InputStream getInputStream() &#123; String path=ServletActionContext.getServletContext().getRealPath(\"/download\"); try &#123; return new FileInputStream(new File(path,fileName)); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); return null; &#125; &#125; public String getFileName() &#123; return fileName; &#125; public void setFileName(String fileName) &#123; this.fileName = fileName; &#125; &#125; 配置文件 12345&lt;action name=\"download\" class=\"com.zhuchuli.action.DownloadAction\"&gt; &lt;result type=\"stream\"&gt; &lt;param name=\"contentDisposition\"&gt;attachment;filename=$&#123;fileName&#125;&lt;/param&gt; &lt;/result&gt;&lt;/action&gt; jsp页面 123456789101112&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Struts2文件下载&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;a href=\"download.action?fileName=jiaoben5614.rar\"&gt;文件下载&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 第二十四讲 ajax 在Struts2中依然可以使用Servlet中的ajax 12345678910111213141516171819202122232425262728293031package com.zhuchuli.ajax;import java.io.IOException;import javax.servlet.http.HttpServletResponse;import org.apache.struts2.ServletActionContext;public class AjaxAction &#123; private String username; //ajax public String checkName() throws IOException &#123; HttpServletResponse resp=ServletActionContext.getResponse(); System.out.println(\"checkName ---&gt;\" + username); if(\"possible\".equals(username)) &#123; resp.getWriter().print(\"true\"); &#125;else &#123; resp.getWriter().print(\"false\"); &#125; return \"none\"; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; &#125; Struts2对ajax也提供了异步支持，使用步骤 导入相关jar包 编写jsp页面 12345678910111213141516171819202122232425262728293031323334353637383940&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;ajax&lt;/title&gt; &lt;script type=\"text/javascript\" src=\"js/jquery-3.2.1.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; $(function()&#123; $(\"#btn\").click(function()&#123; $.post(\"list.action\",function(data)&#123; console.log(data); var html=\"\"; for(var i=0;i&lt;data.length;i++)&#123; html+=\"&lt;tr&gt;&lt;td&gt;\"+data[i].id+\"&lt;/td&gt;&lt;td&gt;\"+data[i].name+\"&lt;/td&gt;&lt;td&gt;\"+data[i].age+\"&lt;/td&gt;&lt;/tr&gt;\"; &#125; $(\"#content\").html(html); &#125;,'json') &#125;) &#125;) &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;button id=\"btn\"&gt;获取数据&lt;/button&gt; &lt;table width=\"80%\" align=\"center\"&gt; &lt;thead&gt; &lt;tr&gt; &lt;td&gt;编号&lt;/td&gt; &lt;td&gt;姓名&lt;/td&gt; &lt;td&gt;年龄&lt;/td&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody id=\"content\"&gt; &lt;/tbody&gt; &lt;tfoot&gt;&lt;/tfoot&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 编写业务处理方法 123456789101112131415161718192021222324252627282930package com.zhuchuli.ajax;import java.util.ArrayList;import java.util.List;import com.opensymphony.xwork2.Action;import com.zhuchuli.vo.User;public class JsonAction &#123; private List&lt;User&gt; list; //获取数据 public String list() &#123; list=new ArrayList&lt;User&gt;(); list.add(new User(1,\"张三\",19)); list.add(new User(2,\"李四\",20)); list.add(new User(3,\"possible\",16)); for(User u:list) &#123; System.out.println(u.getId()+\"--&gt;\"+u.getName()+\"--&gt;\"+u.getAge()); &#125; return Action.SUCCESS; &#125; public List&lt;User&gt; getList() &#123; return list; &#125; public void setList(List&lt;User&gt; list) &#123; this.list = list; &#125; &#125; 配置文件 12345678910111213&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE struts PUBLIC \"-//Apache Software Foundation//DTD Struts Configuration 2.3//EN\" \"http://struts.apache.org/dtds/struts-2.3.dtd\"&gt;&lt;struts&gt; &lt;package name=\"default\" namespace=\"/\" extends=\"json-default\"&gt; &lt;action name=\"checkName\" class=\"com.zhuchuli.ajax.AjaxAction\" method=\"checkName\"&gt;&lt;/action&gt; &lt;action name=\"hello\" class=\"com.zhuchuli.ajax.HelloAction\"&gt;&lt;/action&gt; &lt;action name=\"list\" class=\"com.zhuchuli.ajax.JsonAction\" method=\"list\"&gt; &lt;result type=\"json\"&gt; &lt;param name=\"root\"&gt;list&lt;/param&gt; &lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; 第二十五讲 异常处理 异常处理在实际的应用开发中必不可少。比如：开发中不能直接将错误信息展示给用户看，需要对其进行处理，给用户一个更友好的提示。 异常处理类 123456789101112131415package com.zhuchuli.action;import com.opensymphony.xwork2.Action;import com.zhuchuli.exception.UserException;import com.zhuchuli.service.UserServiceImpl;import com.zhuchuli.service.Userserivce;public class UserAction &#123; private Userserivce userService=new UserServiceImpl(); //try-catch 需要通过异步进行处理ss public String delete() throws UserException &#123; userService.delete(0); return Action.SUCCESS; &#125;&#125; 配置文件 12345&lt;action name=\"delete\" class=\"com.zhuchuli.action.UserAction\" method=\"delete\"&gt; &lt;result&gt;/success.jsp&lt;/result&gt; &lt;result name=\"userexp\"&gt;/exp.jsp&lt;/result&gt; &lt;exception-mapping result=\"userexp\" exception=\"com.zhuchuli.exception.UserException\"&gt;&lt;/exception-mapping&gt; &lt;/action&gt; 第二十六讲 Struts最新版","categories":[],"tags":[]},{"title":"Log4j与Junit测试","slug":"Log4j与Junit测试","date":"2019-09-09T08:28:00.000Z","updated":"2019-09-10T02:46:25.461Z","comments":true,"path":"2019/09/09/Log4j与Junit测试/","link":"","permalink":"https://CPWS.github.io/2019/09/09/Log4j与Junit测试/","excerpt":"","text":"Log4j的作用和级别 什么是日志 日志是系统运行过程中的后台输出信息，方便程序员进行系统运行的管控以及Bug查找 什么是Log4j Log4j是一个日志输出插件，专门用来进行日志的管理的。 传统方式获取日志 使用System.out.println(); 问题： 日志信息无法保存。 无法显示完整日志信息。 日志的显示没有级别所有日志混杂在一起显示（无法进行日志信息筛选）。 日志显示格式不友好。 解决：使用Log4j 使用Log4j进行日志管理特点: 日志可以单独保存在文件。 可以获取完整的日志信息。 可以进行日志显示的筛选。 格式友好。 Log4j的使用流程 导入log4j的jar包 配置Log4j的配置文件 log4j的日志级别 FATAL 致命的错误 Error 错误级 WARM 警告级 INFO 信息级 DEBUG 调试级 日志记录器（Logger）org.apache.log4j.Logger类实例的作用是用来取代System.ou或者System.err的日志写出器，主要用来输出日志信息。 可以通过如下几个方式来获取Logger类的实例 根据指定名称来获取一个日志记录器的实例：Logger logger=Logger.getLogger(String name); 根据指定的类信息中的类名来获取一个日志记录器的实例：Logger logger=Logger.getLogger(Class clazz); 获取(Logger)日志实例之后，就可以使用它提供的以下方法来记录日志了： public void debug(Object msg) public void debug(Object msg,Throwable t) public void info(Object msg) public void info(Object msg,Throwable t) public void warn(Object msg) public void warn(Object msg,Throwable t) public void error(Object msg) public void error(Object msg,Throwable t) log4j的日志级别 FATAL 致命的错误 对应的level为0 使用方法logger.fatal() Error 错误级 对应的level为3 使用方法logger.error() WARM 警告级 对应的level为4 使用方法logger.warn() INFO 信息级 对应的level为6 使用方法logger.info() DEBUG 调试级 对应的level为7 使用方法logger.debug() 日志级别的设置是通过在Log4j的配置文件中指定的。 日志输出目的地（Appender）Appender的功能是把格式好的日志信息输出到指定的目的地。 日志目的地通过Log4j配置文件来指定的。 对于不同的日志目的地，Log4j提供不同的Appender实现类，常用的Appender实现类包括： 用于控制台的org.apache.log4j.ConsoleAppender。 用于文件的org.apache.log4j.FileAppender。 org.apache.log4j.RollingFileAppender–文件到达指定大小时产生一个新的文件。 org.apache.log4j.DailyRollingFileAppender – 每天产生一个日志文件。 用于以流格式发送到任意位置的org.apache.log4j.WriterAppender。 用于添加到数据库的org.apache.log4j.jdbc.JDBCAppender。 用于邮件发送的org.apache.log4j.net.SMTPAppender。 通过在配置文件中指定不同的Appender实现类，就可以让日志内容输出到相应的目的地。 日志格式化器（Layout）Layout用来把日志信息按指定的格式格式化字符串。而具体的格式是通过log4j的配置文件来配置的。 Log4j中提供用来格式化输出结果的各种布局实现类，包括： org.apache.log4j.SimpleLayout：简单输出。此布局的输出中仅包含日志消息的层次，紧跟着“-”，然后是日志消息字符串。 org.apache.log4j.PatternLayout：模式布局。可以根据指定的模式字符串来决定消息的输出格式。它是一种最常用的一种格式化字符串。 org.apache.log4j.TTCCLayout：日志的格式包含产生的日期，线程，类别等信息。 org.apache.log4j.HTMLLayout：以HTML表格形式布局。 org.apache.xml.XMLLayout：以XML形式布局。 Log4j的使用 Log4j的配置文件：“XMl格式的文件”，“Java属性文件:log4j.properties(键=值)” Log4j.properties log4j.xml 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE log4j:configuration SYSTEM \"log4j.dtd\"&gt;&lt;!--日志级别以及优先级排序: OFF &gt; FATAL &gt; ERROR &gt; WARN &gt; INFO &gt; DEBUG &gt; TRACE &gt; ALL --&gt;&lt;!--Configuration后面的status，这个用于设置log4j2自身内部的信息输出，可以不设置，当设置成trace时，你会看到log4j2内部各种详细输出--&gt;&lt;!--monitorInterval：Log4j能够自动检测修改配置 文件和重新配置本身，设置间隔秒数--&gt;&lt;configuration status=\"WARN\" monitorInterval=\"30\"&gt; &lt;!--先定义所有的appender--&gt; &lt;!--设置日志目的地类型和日志格式化器--&gt; &lt;appenders&gt; &lt;!--这个输出控制台的配置--&gt; &lt;console name=\"Console\" target=\"SYSTEM_OUT\"&gt; &lt;!--输出日志的格式--&gt; &lt;PatternLayout pattern=\"[%d&#123;HH:mm:ss:SSS&#125;] [%p] - %l - %m%n\"/&gt; &lt;/console&gt; &lt;!--文件会打印出所有信息，这个log每次运行程序会自动清空，由append属性决定，这个也挺有用的，适合临时测试用--&gt; &lt;File name=\"log\" fileName=\"log/test.log\" append=\"false\"&gt; &lt;PatternLayout pattern=\"%d&#123;HH:mm:ss.SSS&#125; %-5level %class&#123;36&#125; %L %M - %msg%xEx%n\"/&gt; &lt;/File&gt; &lt;!-- 这个会打印出所有的info及以下级别的信息，每次大小超过size，则这size大小的日志会自动存入按年份-月份建立的文件夹下面并进行压缩，作为存档--&gt; &lt;RollingFile name=\"RollingFileInfo\" fileName=\"$&#123;sys:user.home&#125;/logs/info.log\" filePattern=\"$&#123;sys:user.home&#125;/logs/$$&#123;date:yyyy-MM&#125;/info-%d&#123;yyyy-MM-dd&#125;-%i.log\"&gt; &lt;!--控制台只输出level及以上级别的信息（onMatch），其他的直接拒绝（onMismatch）--&gt; &lt;ThresholdFilter level=\"info\" onMatch=\"ACCEPT\" onMismatch=\"DENY\"/&gt; &lt;PatternLayout pattern=\"[%d&#123;HH:mm:ss:SSS&#125;] [%p] - %l - %m%n\"/&gt; &lt;Policies&gt; &lt;TimeBasedTriggeringPolicy/&gt; &lt;SizeBasedTriggeringPolicy size=\"100 MB\"/&gt; &lt;/Policies&gt; &lt;/RollingFile&gt; &lt;RollingFile name=\"RollingFileWarn\" fileName=\"$&#123;sys:user.home&#125;/logs/warn.log\" filePattern=\"$&#123;sys:user.home&#125;/logs/$$&#123;date:yyyy-MM&#125;/warn-%d&#123;yyyy-MM-dd&#125;-%i.log\"&gt; &lt;ThresholdFilter level=\"warn\" onMatch=\"ACCEPT\" onMismatch=\"DENY\"/&gt; &lt;PatternLayout pattern=\"[%d&#123;HH:mm:ss:SSS&#125;] [%p] - %l - %m%n\"/&gt; &lt;Policies&gt; &lt;TimeBasedTriggeringPolicy/&gt; &lt;SizeBasedTriggeringPolicy size=\"100 MB\"/&gt; &lt;/Policies&gt; &lt;!-- DefaultRolloverStrategy属性如不设置，则默认为最多同一文件夹下7个文件，这里设置了20 --&gt; &lt;DefaultRolloverStrategy max=\"20\"/&gt; &lt;/RollingFile&gt; &lt;RollingFile name=\"RollingFileError\" fileName=\"$&#123;sys:user.home&#125;/logs/error.log\" filePattern=\"$&#123;sys:user.home&#125;/logs/$$&#123;date:yyyy-MM&#125;/error-%d&#123;yyyy-MM-dd&#125;-%i.log\"&gt; &lt;ThresholdFilter level=\"error\" onMatch=\"ACCEPT\" onMismatch=\"DENY\"/&gt; &lt;PatternLayout pattern=\"[%d&#123;HH:mm:ss:SSS&#125;] [%p] - %l - %m%n\"/&gt; &lt;Policies&gt; &lt;TimeBasedTriggeringPolicy/&gt; &lt;SizeBasedTriggeringPolicy size=\"100 MB\"/&gt; &lt;/Policies&gt; &lt;/RollingFile&gt; &lt;/appenders&gt; &lt;!--设置根记录器--&gt; &lt;root&gt; &lt;!--设置级别--&gt; &lt;level value=\"DEBUG\" /&gt; &lt;!--设置目的地--&gt; &lt;appender-ref ref=\"STDOUT\"/&gt; &lt;appender-ref ref=\"File\"&gt; &lt;/root&gt; &lt;!--然后定义logger，只有定义了logger并引入的appender，appender才会生效--&gt; &lt;loggers&gt; &lt;!--过滤掉spring和mybatis的一些无用的DEBUG信息--&gt; &lt;logger name=\"org.springframework\" level=\"INFO\"&gt;&lt;/logger&gt; &lt;logger name=\"org.mybatis\" level=\"INFO\"&gt;&lt;/logger&gt; &lt;root level=\"all\"&gt; &lt;appender-ref ref=\"Console\"/&gt; &lt;appender-ref ref=\"RollingFileInfo\"/&gt; &lt;appender-ref ref=\"RollingFileWarn\"/&gt; &lt;appender-ref ref=\"RollingFileError\"/&gt; &lt;/root&gt; &lt;/loggers&gt; &lt;/configuration&gt; Log4j在默认的情况下，会首先查找使用log4j.xml的配置，然后再去查找log4j.properties。 log4j的配置文件必须放置于项目的类路径（ClassPath）下。 在Java中使用Log4j打印日志信息的步骤如下： 得到记录器。 public static Logger logger=Logger.getLogger(String name); static Logger logger=Logger.getLogger(Test.class.getName()); 读取配置文件。 BasicConfigurator.configure(); //自动快速的使用默认的log4j环境 PropertyConfigurator.configure(String configFileName);//读取使用Java的特性文件编写的配置文件。 插入记录信息。 Logger.debug(Object message);Junit单元测试Junit-概述Junit-环境设置Junit-基本用法Junit-APIJunit-编写测试Junit-使用断言Junit-执行过程Junit-执行测试Junit-囊括测试Junit-忽略测试","categories":[],"tags":[]},{"title":"正则表达式","slug":"正则表达式","date":"2019-09-08T01:36:32.000Z","updated":"2019-09-09T09:39:24.456Z","comments":true,"path":"2019/09/08/正则表达式/","link":"","permalink":"https://CPWS.github.io/2019/09/08/正则表达式/","excerpt":"","text":"正则表达式基本知识 基本语法 高级语法 练习 editplus,notpad++,ultraedit,eclipse中使用正则表达式 正则表达式（Regular Expression）简介 为什么需要使用正则表达式？ 文本的复杂处理。 正则表达式的优势和用途 一种强大而灵活的文本处理工具。 大部分编程语言、数据库、文本编辑器、开发环境都支持正则表达式。 正则表达式定义 正如他的名字一样是描述一种规则，通过这个规则可以匹配一类字符串。 学习正则表达式很大程度上就是学习正则表达式的语法规则。 开发中使用正则表示的流程 分析所要匹配的数据，写出测试用的典型数据。 在工具软件中进行匹配测试。 在程序中调用通过测试的正则表达式。 正则表达式基本语法 普通字符 字母、数字、汉字、下划线、以及没有特殊定义的标点符号，都是“普通字符”。表达式中的普通字符，在匹配一个字符串的时候，匹配与之相同的一个字符。 简单转义字符 \\n 代表换行符 \\t 制表符 \\ 代表\\本身 ^,$,.,{,},?,+,*,|,[,] 匹配这些字符创本身 标准字符集合： 能够与“多种字符”匹配的表达式 主义区分大小写，大写是相反的意思。 \\d 任意一个数字，0-9中的任意一个。 \\w 任意一个字母或数字或下划线，也就是A-Z,a-z,0-9,_中任意一个。 \\s 包括空格、制表符、换行符等空白字符的其中任意一个。 . 小数点可以匹配任意一个字符（除了换行符）如果要匹配在”\\n”在内的所有字符，一般用[\\s\\S]。 [\\s\\S] 匹配包含“\\n”在内所有字符串 自定义字符集合 []方括号匹配方式，能够匹配方括号中任意一个字符. [ab5@]：匹配”a”或”b”或”5”或”@” [^abc]：匹配”a”，”b”，”c”之外的任意一个字符 [f-k]：匹配日”f”-“k”之间的任意一个字符 [^A-f0-3]：匹配”A”-“F”，”0”-“3’之外的任意一个字符 正则表达式的特殊符号，被包含到中括号中，则失去特殊意义，除了^,-之外。 标准字符集合，处理小数点之外，如果被包含于中括号，自定义字符集合将包含该集合。 [\\d.-+]讲匹配数组，小数点 + - 量词（Quantifier） 修饰匹配次数的特殊符号 {n} 表达重复n次 {m，n} 表达至少重复m次，最多重复n次 {m,} 表达至少重复m次 ? 匹配表达式0次或1次，相当于{0,1} + 表达式至少出现1线，相当{1,} * 表达式不会出现或出现任意次，{0，} 匹配次数中的贪婪模式（匹配字符越多越好，默认！）。 匹配次数中的非贪婪模式（匹配字符越少越好，修饰匹配次数的特殊符号后再加上一个”?”号）。 字符边界 （本组编辑匹配的不是字符而是位置，符合某种条件的位置）() ^ 与字符串开始的位置匹配 $ 与字符串结束的地方配置 \\b 匹配一个当前的边界 \\b匹配这样一个位置，前面的字符和后面的字符不全是\\w 选择符和分组 表达式 作用 ` `分支结构 ()捕获组 (1)在被修饰匹配次数的时候，括号中的表达式可以作为整体被修饰(2)取得匹配结果的时候，括号中的表达式匹配到的内容可以被单独得到(3)每个括号会分配一个编号，使用（）的捕获根据左括号的顺序从1开始自动编号。捕获元素编号为0的第一个捕获是由整个正则表达式模式匹配的文本 非捕获组（?:Exception）（?:([a-z]{2})） 一些表达式中，不得不使用()，但又不需要保存()中子表达式匹配的内容，这时候可以使用非捕获组来抵消使用()带来的副作用。 反向引用（\\nnn）： 每一个()都会分配一个编号，使用（）的捕获根据左括号的顺序从1开始自动编导。 通过反向作用，可以对分组已捕获的字符串进行引用。 正则表达式的匹配模式 INGORECASE 忽略大小写模式 匹配时忽略大小写。 默认情况下，正则表达式是要区分大小写的。 SIGNLELINE 单行模式 整个文本看做是一个字符串，只有一个开头，一个结尾。 使小数点“.”可以匹配包含“\\n”在内的任意字符。 MULTILINE 多行模式 每行都是一个字符串，都有开头和结尾。 在指定了MULTILINE之后，如果需要仅匹配字符串开始和结束位置，可以使用\\A和\\Z 预搜索（零宽断言）（环视） 占有字符还是零宽度，是针对匹配的内容是否保存到最终的匹配结果中而言的。 零宽断言的几种方式 (?=exp)：断言自身出现的位置的后面能匹配表达式exp。 (?&lt;=exp&gt;):断言自身出现的位置的前面能匹配表达式exp。 (?!exp):断言此位置的后面不能匹配exp。 (?&lt;!exp&gt;):断言此位置的前面不能匹配表达式exp。 正则表达式的应用 电话号码的应用 电话号码有数字和”-“构成。 电话号码为7到8位。 如果电话号码中包含有取号，那么区号为三位或四位，首位为0。 区号用”-“和其它部分隔开。 移动电话号码为11位 11位一定电话号码的第一位和第二位为”13“、”15“、”18“ 结果：(0\\d{2,3}-\\d{7,9})|(1[35789]\\d{9}) 电子邮件的地址验证 用户名：字母，数字，下划线，中划线组成 @ 网址：字母、数字组成 小数点 . 组织域名：2-4字母组成 不区分大小写 结果 [\\w-]+@[a-z0-9A-Z]+(.[A-Za-z]{2,3}){1,2} Java程序中使用正则表达式 相关类位于：java.util.regex包下面 类pattern： 正则表达式的编译表示形式。 Pattern p=Pattern.compile(r,int);//建立正则表达式，并启动响应模式 类matcher： 通过解释Pattern对character sequence执行匹配操作的引擎。 Matcher m=p.matcher(str);//匹配str字符串 Java模拟编程的原理123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package regular;import java.io.BufferedReader;import java.io.InputStreamReader;import java.net.URL;import java.util.ArrayList;import java.util.List;import java.util.regex.Matcher;import java.util.regex.Pattern;/*** * 网络爬虫取连接 * @author 1huangzewei * */public class webSpiderTest &#123; //获得urlStr网页的源代码 public static String getURLContent(String urlStr) &#123; StringBuilder sb=new StringBuilder(); try &#123; URL url=new URL(urlStr); BufferedReader reader=new BufferedReader(new InputStreamReader(url.openStream())); String temp=\"\"; while((temp=reader.readLine())!=null) &#123; sb.append(temp); &#125; &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; return sb.toString(); &#125; public static List&lt;String&gt; getMatcher(String destStr,String regex) &#123; List&lt;String&gt; result=new ArrayList&lt;String&gt;(); //Pattern p=Pattern.compile(\"&lt;a[\\\\s\\\\S]+?&lt;/a&gt;\");//找到超链接 Pattern p = Pattern.compile(regex);//找到a href; Matcher m = p.matcher(destStr); while (m.find()) &#123; result.add(m.group(1)); &#125; return result; &#125; public static void main(String[] args) &#123; String destStr=getURLContent(\"http://163.com\"); //List&lt;String&gt; list=getMatcher(destStr,\"href=\\\"([\\\\s\\\\S]+?)\\\"\"); //List&lt;String&gt; list=getMatcher(destStr,\"(&lt;img+[\\\\S\\\\s]+?)&gt;\"); List&lt;String&gt; list=getMatcher(destStr,\"data-original=\\\"([\\\\s\\\\S]+?)\\\"\"); for(String temp:list) &#123; System.out.println(temp); &#125; &#125;&#125;","categories":[],"tags":[]},{"title":"注解与反射","slug":"注解与反射","date":"2019-09-02T08:08:40.000Z","updated":"2019-09-05T11:28:08.710Z","comments":true,"path":"2019/09/02/注解与反射/","link":"","permalink":"https://CPWS.github.io/2019/09/02/注解与反射/","excerpt":"","text":"注解入门 Annotation是JDK5.0开始引入的新技术 Annotation的作用 不是程序本身，可以对程序作出解释。 可以被其他程序（比如：编译器等）读取。（注解信息处理流程，是注解和注释的重大区别。如果没有注解信息处理流程，则注解毫无意义）。 Annotation格式 注解是以“@注释名”在代码中存在的，可以添加一些参数值，例如：@SeppressWarnings(value=”unchecked”)。 Annotation在哪里使用？ 可以附加在package，class，method，field等上面，相当于它它们添加了额外的辅助信息，我们可以通过反射机制编程实现对这些数据的访问。 内置注解 @Override：定义在java.lang.Override中，此注释只适用修饰方法，表示一个方法声明打算重写超类中的另一个方法声明。 @Deprecated：定义在java.lang.Deprecated中，此注释可以用于修饰方法、属性、类，表示不鼓励程序员使用这样的元素，通常是因为它很危险吗或存在更好的选择。（一般不建议使用） @SuppressWarnings：用来抑制编译器运行时的警告信息。 @SuppressWarnings(&quot;unchecked&quot;)告诉编译器忽略 unchecked 警告信息，如使用List，ArrayList等未进行参数化产生的警告信息。 @SuppressWarnings(&quot;serial&quot;)如果编译器出现这样的警告信息：The serializable class WmailCalendar does not declare a static final serialVersionUID field of type long 使用这个注释将警告信息去掉。 @SuppressWarnings(&quot;deprecation&quot;)如果使用了使用@Deprecated注释的方法，编译器将出现警告信息。 使用这个注释将警告信息去掉。 @SuppressWarnings(&quot;unchecked&quot;, &quot;deprecation&quot;)告诉编译器同时忽略unchecked和deprecation的警告信息。 @SuppressWarnings(value={&quot;unchecked&quot;, &quot;deprecation&quot;})等同于@SuppressWarnings(“unchecked”, “deprecation”) 自定义注解、元注解元注解 @Target 作用：用于描述注解的使用范围 |所修饰的范围|取值ElemnetType||-|-|-||package包|PACKAGE||类、接口、枚举、Annotation类型|TYPE||类型成员（方法、构造器、成员变量、枚举值）|CONSTRUCTOR：用于描述构造器。FIELD：用于描述域METHOD：用于描述方法||方法参数和本地变量|LOCAL_VALUE：用于描述局部变量PARANETER：用于描述参数| @Target(value=ElementType.Type) @Retention 作用：表示需要在什么级别保存该注解，用于描述注解的生命周期。 取值 RetentionPolicy 作用 SOURCE 在源文件中有效（即源文件保存） CLASS 在class文件中有效（即class保留） RUNTIME 在运行时有效（即运行时保留）为Runtime可以被反射机制读取 注意： 注解元素的参数的默认值一般设置为0或空字符窜； 也可能是-1，表示什么也没有 @Documented 作用：用于描述其它类型的annotation应该被作为被标注的程序成员的公共API，因此可以被例如javadoc此类的工具文档化。它是一个标记注解，没有成员。 @Inherited 作用：用于表示某个被标注的类型是被继承的。如果一个使用了@Inherited修饰的annotation类型被用于一个class，则这个annotation将被用于该class的子类 反射机制读取注解 什么是ORM（Object Relationship Mapping） 类和表结构对应 属性和字段对应 对象和记录对应 使用注解完成类和表结构的映射关系 学了反射机制后，我们可以定义注解的执行流程读取这些注解，实现更复杂的功能 123456789101112package annotation;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target; @Target(value = ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)public @interface Table &#123; String value();&#125; 1234567891011121314package annotation;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Target(value = ElementType.FIELD)@Retention(RetentionPolicy.RUNTIME)public @interface Field &#123; String columnName(); String type(); int length();&#125; 123456789101112131415161718192021222324252627282930package annotation;@Table(\"tb_student\")public class Student &#123; @Field(columnName=\"id\",type=\"int\",length=3) private int id; @Field(columnName=\"sname\",type=\"varchar\",length=10) private String studentName; @Field(columnName=\"age\",type=\"int\",length=10) private int age; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getStudentName() &#123; return studentName; &#125; public void setStudentName(String studentName) &#123; this.studentName = studentName; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; &#125; 1234567891011121314151617181920212223242526272829303132package annotation;import java.lang.annotation.Annotation;/** * 使用反射处理注解信息，模拟处理注解信息的流程 * @author 1huangzewei * */public class Demo3 &#123; public static void main(String[] args) &#123; try &#123; Class clazz=Class.forName(\"annotation.Student\"); //获取类所有有效的注解 Annotation[] annotations=clazz.getAnnotations(); for(Annotation a:annotations) &#123; System.out.println(a); &#125; //获取指定的注解 Table table=(Table) clazz.getAnnotation(Table.class); System.out.println(table.value()); //获取类的属性的注解 Field f=clazz.getDeclaredField(\"studentName\").getAnnotation(Field.class); System.out.println(f.columnName() + \"---&gt;\" + f.type() + \"---&gt;\" + f.length()); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125; Java的动态性 动态语言：程序运行时，可以改变程序结果或变量类。 Java可以称为准动态语言。 反射机制 reflection 指的是可以于运行时加载、探知、使用编译期间完全未知的类。 程序在运行状态中，可以动态加载一个只有名称的类，对于任意一个已加载的类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性。 1Class c=Class.forName(\"包名.类名\"); 加载完类之后，在堆内存中，就产生了一个Class类型的对象（一个类只有一个Class对象），这个对象就包含了完整的类的结构信息。我们可以通过这个对象看到类的结构。这个对象就像一面镜子，通过这个镜子可以看到类的结构，所以我们形象的称之为：反射。 Class类的对象如何获取 运用getClass() 运用Class.forName()（最常被使用） 运用类.class 123456789101112131415161718192021222324252627282930313233343536package com.zhuchuli.reflection;import com.zhuchuli.testBean.User;/*** * 测试java.lang.Class对象的获取方式。 * 测试各种数据类型java.lang.Class对象的获取方式。 * 1.利用类.class * 2.利用类.getClass() * 3.利用Class.forName() * @author 1huangzewei * */@SuppressWarnings(\"all\")public class Demo01 &#123; public static void main(String[] args) &#123; String path= \"com.zhuchuli.testBean.User\"; try &#123; Class clazz = Class.forName(path); //对象是表示或封装一些数据。一个类被加载之后，Jvm会创建一个对应该类的Class对象，类的整个结构信息会放到对象的Class对象中。 //这个Class对象就像一面镜子一样，通过这个镜子，我们可以看到类的全部信息。 System.out.println(clazz.hashCode()); //获取Class对象的三种方式 Class strClazz=String.class; Class strClazz2=path.getClass(); System.out.println(strClazz==strClazz2); //基本数据类型 Class intClaszz=int.class; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 反射机制的常见作用 动态加载类、动态获取类的信息（属性、方法、构造器） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package com.zhuchuli.reflection;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.Method;/*** * 应用反射API，获取类的信息（类的名字、属性、方法、构造器等） * @author 1huangzewei * */public class Demo02 &#123; public static void main(String[] args) &#123; String path= \"com.zhuchuli.testBean.User\"; try &#123; Class clazz = Class.forName(path); //获取类的名字 System.out.println(\"---------------------------------通过反射获取类名---------------------------------\"); System.out.println(clazz.getName());//获得包名+类名 com.zhuchuli.testBean.User System.out.println(clazz.getSimpleName());//获得类名 User System.out.println(\"------------------------------------------------------------------------------\"); //获取属性信息 System.out.println(\"---------------------------------通过反射获取属性---------------------------------\"); //Field[] fields=clazz.getFields();//只能获取public的属性 Field[] fields=clazz.getDeclaredFields();//获得所有的field Field f=clazz.getDeclaredField(\"uname\"); System.out.println(f); for(Field field:fields) &#123; System.out.println(\"属性：\"+field); &#125; System.out.println(\"------------------------------------------------------------------------------\"); //获取方法信息 System.out.println(\"---------------------------------通过反射获取方法---------------------------------\"); Method[] methods=clazz.getMethods();//只能获取public修饰的方法 Method[] methodss=clazz.getDeclaredMethods();//获取所有的方法 Method m01=clazz.getDeclaredMethod(\"getUname\", null); System.out.println(m01); Method m02=clazz.getDeclaredMethod(\"setUname\", String.class);//如果方法有参数，则必须指明参数的类型，即参数类型.class System.out.println(m02); for(Method method:methodss) &#123; System.out.println(\"方法：\"+method); &#125; System.out.println(\"------------------------------------------------------------------------------\"); //获取构造器信息 System.out.println(\"---------------------------------通过反射获取构造器---------------------------------\"); Constructor[] constructors=clazz.getConstructors();//获取public修饰的构造器 Constructor[] constructorss=clazz.getDeclaredConstructors(); for(Constructor constructor:constructorss) &#123; System.out.println(\"构造器：\"+constructor); &#125; System.out.println(\"根据参数类型获取构造器\"); Constructor c=clazz.getDeclaredConstructor(null); System.out.println(\"构造器：\"+c); Constructor cc=clazz.getConstructor(int.class,String.class,int.class); System.out.println(\"构造器：\"+cc); System.out.println(\"------------------------------------------------------------------------------\"); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 动态构造对象 动态调用类和对象的任意方法、构造器 动态调用和处理属性 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.zhuchuli.reflection;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.Method;import com.zhuchuli.testBean.User;/*** * 通过反射API动态的操作：构造器，方法和属性 * @author 1huangzewei * */public class Demo03 &#123; public static void main(String[] args) &#123; //动态操作构造器 String path= \"com.zhuchuli.testBean.User\"; try &#123; Class clazz = Class.forName(path); //通过反射API调用构造方法，构造对象 User u=(User) clazz.getConstructor().newInstance();//其实调用JavaBean的无参数构造器 System.out.println(u); Constructor&lt;User&gt; c=clazz.getConstructor(int.class,String.class,int.class); User u2=c.newInstance(1001,\"lee\",18); System.out.println(u2.getId()+\"--\"+u2.getUname()+\"--\"+u2.getAge()); //通过反射API调用普通方法 User u3=(User) clazz.getConstructor().newInstance(); Method method=clazz.getDeclaredMethod(\"setUname\", String.class); method.invoke(u3, \"lee2\");//类似于u3.setUname=\"lee2\" System.out.println(u3.getUname()); //通过反射API调用属性 User u4=(User) clazz.getConstructor().newInstance(); Field f=clazz.getDeclaredField(\"uname\"); f.setAccessible(true);//这个属性不需要做安全检查，可以直接访问。 f.set(u4, \"lee3\");//通过放射获取属性的值 System.out.println(u4.getUname()); System.out.println(f.get(u4));//通过反射读取对象的值 &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 获取泛型信息（Generic） Java使用泛型擦除机制来引入泛型。Java中的泛型仅仅是给编译器JavaC使用的，确保数据的安全性和免去强制类型转换的麻烦。但是编译一旦完成，所有和泛型有关的类全部被擦除。 为了通过反射操作这些类型以迎合实际开发的需要，Java新增了PatameterType，GenericArrayType，TypeVariable，和WildCardType几种类型来代表不能被归一到Class类中的类型但是又和原始类型齐名的类型。 ParameterizedType:表示一种参数化的类型，比如Collection&lt; String &gt;. GenericArrayType:表示一种元素类型是参数化类型或者类型变量的数组类型. TypeVariable:是各种类型变量的公共父接. WildcardType:代表一种通配符类型表达式，比如？、？ extends Number、？ super Integer。（wildcard是一个单词：就是”通配符“）. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package com.zhuchuli.reflection;import java.lang.reflect.Method;import java.lang.reflect.ParameterizedType;import java.lang.reflect.Type;import java.util.List;import java.util.Map;import com.zhuchuli.testBean.User;/*** * 通过反射获取泛型信息 * @author 1huangzewei * */public class Demo04 &#123; public void test01(Map&lt;String,User&gt; map,List&lt;User&gt; list) &#123; System.out.println(\"Demo04 test01()\"); &#125; public Map&lt;Integer,User&gt; test02()&#123; System.out.println(\"Demo01 test02()\"); return null; &#125; public static void main(String[] args) &#123; try &#123; //获取执行方法参数的泛型信息 Method method = Demo04.class.getDeclaredMethod(\"test01\", Map.class, List.class); Type[] t=method.getGenericParameterTypes(); for(Type paramType:t) &#123; System.out.println(\"#\"+paramType); if(paramType instanceof ParameterizedType) &#123; //获取泛型中的具体信息 Type[] genericTypes = ((ParameterizedType) paramType).getActualTypeArguments(); for(Type genericType:genericTypes) &#123; System.out.println(\"泛型类型：\" + genericType); &#125; &#125; &#125; //获取指定方法返回值泛型信息 Method method2=Demo04.class.getDeclaredMethod(\"test02\",null); Type returnType=method2.getGenericReturnType(); if(returnType instanceof ParameterizedType) &#123; //获取泛型中的具体信息 Type[] genericTypes = ((ParameterizedType) returnType).getActualTypeArguments(); for(Type genericType:genericTypes) &#123; System.out.println(\"泛型类型：\" + genericType); &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 处理注解：功能与案例代码与上面雷同。 反射机制的性能问题 setAccessible 启动和禁用访问安全检查的机关，值为true则指示反射的对象在使用时应该取消Java语言访问检查。值为false则指示表明反射的对象应该实施Java语言访问检查。并不是为true就能访问为false就不能访问。 禁止安全检查，可以提高反射的运行速度。 可以考虑使用：cglib/javaassist字节码操作 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.zhuchuli.reflection;import java.lang.reflect.Method;import com.zhuchuli.testBean.User;public class Demo05 &#123; public static void test01() &#123; User user=new User(); long before=System.currentTimeMillis(); for(var i=0;i&lt;1000000000L;i++) &#123; user.getUname(); &#125; long after=System.currentTimeMillis(); System.out.println(\"没有反射，共消耗：&lt;\"+(after-before)+\"&gt;毫秒\"); &#125; public static void test02() throws Exception &#123; User user=new User(); Method method=Class.forName(\"com.zhuchuli.testBean.User\").getDeclaredMethod(\"getUname\", null); long before=System.currentTimeMillis(); for(var i=0;i&lt;1000000000L;i++) &#123; method.invoke(user, null); &#125; long after=System.currentTimeMillis(); System.out.println(\"加安全检查，共消耗：&lt;\"+(after-before)+\"&gt;毫秒\"); &#125; public static void test03() throws Exception &#123; User user=new User(); Method method=Class.forName(\"com.zhuchuli.testBean.User\").getDeclaredMethod(\"getUname\", null); method.setAccessible(true); long before=System.currentTimeMillis(); for(var i=0;i&lt;1000000000L;i++) &#123; method.invoke(user, null); &#125; long after=System.currentTimeMillis(); System.out.println(\"不加安全检查，共消耗：&lt;\"+(after-before)+\"&gt;毫秒\"); &#125; public static void main(String[] args) throws Exception &#123; test01(); test02(); test03(); &#125;&#125; 动态编译 Java6.0引入了动态编译机制 动态编译的应用场景 可以做一个浏览器端编写java代码，上传服务器编译和运行的在线测评系统。 服务器动态加载某些类文件进行编译。 动态编译的两种方式 通过Runtime调用javac，启动新的进程去操作 Runtime run=Runtime.getRuntime(); Process process=run.exec(javac -cp d:/myjava/ HelloWorld.java); 通过JavaCompiler动态编译 123456789101112131415161718192021222324package com.zhuchuli.test;import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.FileReader;import java.io.FileWriter;import java.io.IOException;import javax.tools.JavaCompiler;import javax.tools.ToolProvider;public class Demo01 &#123; public static void main(String[] args) throws IOException &#123; String str=\"public class Hi&#123;public static void main(String[] args[]) &#123;System.out.println(\\\"Hello Hi haha\\\");&#125;&#125;\"; BufferedWriter br=new BufferedWriter(new FileWriter(\"d:/MyJava/Hi.java\")); br.write(str); br.flush(); //获得系统编译器，如果使用jre（运行环境）则无法获得编译器 JavaCompiler complier=ToolProvider.getSystemJavaCompiler(); int result=complier.run(null, null, null,\"d:/MyJava/Hi.java\"); System.out.println(result==0?\"编译成功\":\"编译失败\"); br.close(); &#125;&#125; 编译结果 1234567891011121314151617181920212223242526272829303132package com.zhuchuli.test;import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.FileReader;import java.io.FileWriter;import java.io.IOException;import java.io.InputStreamReader;import javax.tools.JavaCompiler;import javax.tools.ToolProvider;public class Demo02 &#123; public static void main(String[] args) throws IOException &#123; String str=\"public class Hi&#123;public static void main(String[] args) &#123;System.out.println(\\\"Hello Hi haha\\\");&#125;&#125;\"; BufferedWriter bw=new BufferedWriter(new FileWriter(\"d:/MyJava/Hi.java\")); bw.write(str); bw.flush(); //获得系统编译器，如果使用jre（运行环境）则无法获得编译器 JavaCompiler complier=ToolProvider.getSystemJavaCompiler(); int result=complier.run(null, null, null,\"d:/MyJava/Hi.java\"); System.out.println(result==0?\"编译成功\":\"编译失败\"); Runtime run=Runtime.getRuntime(); Process process=run.exec(\"java -cp d:/MyJava Hi\"); BufferedReader br=new BufferedReader(new InputStreamReader(process.getInputStream())); String info=\"\"; while((info=br.readLine())!=null) &#123; System.out.println(info); &#125; &#125;&#125; 编译结果 通过反射机制，启动新的线程去执行 12345678910111213141516171819202122232425262728293031323334353637383940414243package com.zhuchuli.test;import java.io.BufferedWriter;import java.io.FileWriter;import java.io.IOException;import java.lang.reflect.Method;import java.net.URL;import java.net.URLClassLoader;import javax.tools.JavaCompiler;import javax.tools.ToolProvider;/** * 通过反射机制调用执行类 * @author 1huangzewei * */public class Demo03 &#123; public static void main(String[] args) throws IOException &#123; String str=\"public class Hi&#123;public static void main(String[] args) &#123;System.out.println(\\\"Hello Hi haha\\\");&#125;&#125;\"; BufferedWriter bw=new BufferedWriter(new FileWriter(\"d:/MyJava/Hi.java\")); bw.write(str); bw.flush(); //获得系统编译器，如果使用jre（运行环境）则无法获得编译器 JavaCompiler complier=ToolProvider.getSystemJavaCompiler(); int result=complier.run(null, null, null,\"d:/MyJava/Hi.java\"); System.out.println(result==0?\"编译成功\":\"编译失败\"); try &#123; URL[] urls=new URL[] &#123;new URL(\"file:/\"+\"d:/MyJava/\")&#125;; URLClassLoader loader=new URLClassLoader(urls); Class c=loader.loadClass(\"Hi\"); Method m=c.getMethod(\"main\", String[].class); m.invoke(null, (Object)new String[] &#123;&#125;); //m.invoke(null,new String[] &#123;\"a\",\"b\"&#125;); //由于可变参数是Java5.0之后才有。上面的代码会被运行成;m.invoke(null,\"a\",\"b\")，就发生了参数个数不匹配，从而出现错误,因此要加上(Object)转型，避免出现出错; //public static void mmm(String[] a,String[] b) //public static void main(String[] args); &#125;catch(Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 编译结果 动态执行javascript代码 Java脚本引擎是从JDK6.0之后添加的新功能 脚本引擎介绍 使得Java应用程序可以通过一套固定的接口与各种脚本引擎交互，从而达到在Java平台上调用各种脚本语言的目的。 Java脚本API是连通Java平台和脚本语言的桥梁。 可以把一些复杂异变的业务逻辑交给与脚本语言处理，这又大大提高了开发效率。 获得脚本引擎 ScriptEngineManager sem=new ScriptEngineManager(); ScriptEngine engine=sem.getEngineByName(“javascript”); Java脚本API为开发者提供了如下功能： 获取脚本程序输入，通过脚本引擎运行脚本并返回运行结果，这是最核心的接口。 注意是：接口。Java可以使用各种不同的表现，从而通用的调用js、groovy、python等脚本 js使用了:Rhino，Rhino是一种使用Java语言编写的JavaScript的开源实现，原先是由Mozilla开发，现在被集成进入JDK6.0 通过脚本引擎的运行上下文在脚本和Java平台间交换数据。 通过Java应用程序调用脚本函数。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970package com.zhuchuli.rhino;import java.io.FileNotFoundException;import java.io.FileReader;import java.net.URL;import java.util.List;import javax.script.Invocable;import javax.script.ScriptEngine;import javax.script.ScriptEngineManager;import javax.script.ScriptException;/*** * 测试脚本引擎执行JavaScript代码 * @author 1huangzewei * */public class Demo01 &#123; public static void main(String[] args) throws ScriptException, NoSuchMethodException &#123; //获取脚本引擎对象 ScriptEngineManager sem=new ScriptEngineManager(); ScriptEngine engine=sem.getEngineByName(\"javascript\"); //定义变量，存储到引擎上下文中 engine.put(\"msg\", \"lee is a good student\"); String str=\"var user= &#123;name:'aaa',age:18,schools:['gdaib','dgef']&#125;;\"; str += \"print(user.schools);\"; //执行脚本 engine.eval(str); //修改msg的值 engine.eval(\"msg='very happy today'\"); System.out.println(engine.get(\"msg\")); System.out.println(\"--------------------\"); //定义函数 engine.eval(\"function add(a,b)&#123;var sum=a+b;return sum;&#125;\"); //执行js函数 取得调用接口 Invocable jsInvoke=(Invocable) engine; //执行脚本中定义的方法 Object i=jsInvoke.invokeFunction(\"add\", new Object[] &#123;10,20&#125;); System.out.println(i); //导入其他java包，使用其他包中的java类 String jsCode=\"var list=java.util.Arrays.asList([\\\"北京尚学堂\\\",\\\"北京大学\\\"]);\"; engine.eval(jsCode); List&lt;String&gt; list2=(List&lt;String&gt;) engine.get(\"list\"); for(String temp:list2) &#123; System.out.println(temp); &#125; //执行一个JS文件 URL url=Demo01.class.getClassLoader().getResource(\"a.js\"); try &#123; FileReader fr = new FileReader(url.getPath()); engine.eval(fr); fr.close(); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125; 运行结果 动态字字节码操作：javaassist Java动态性的两种常见实现方式： 字节码操作 反射 运行时操作字节码可以让我们实现如下功能 动态生成新的类。 动态改变某个类的结构（添加、删除、修改 新的属性、方法 ） 优势 比反射开销小，性能高。 Javaassist性能高于反射，低于ASM 常见的字节码操作类库 BCEL 基于底层Jvm的操作和指令 ASM 基于底层Jvm的操作和指令 CGLIB 基于ASM实现 Javaassist Javaassist库的API详解 javaassist的最外层的API和java的反射包中的API颇为类似。 它主要有CtClass,CtMethod，以及CtField几个类组成。用以执行和JDK反射API中java.lang.Class,java.lang.reflection.Method，java.lang.reflection.Field相同的操作。 JAVAassist库的简单使用。 创建一个全新的类 使用XJAD反编译工具，将生成的class文件反编译成Java文件\\ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.zhuchuli.javaassist;import java.io.IOException;import javassist.CannotCompileException;import javassist.ClassPool;import javassist.CtClass;import javassist.CtConstructor;import javassist.CtField;import javassist.CtMethod;import javassist.NotFoundException;/*** * 测试 使用javaassist动态生成一个新类 * @author 1huangzewei * */public class Demo01 &#123; public static void main(String[] args) throws CannotCompileException, NotFoundException, IOException &#123; //创建一个类池 ClassPool pool=ClassPool.getDefault(); CtClass cc=pool.makeClass(\"com.zhuchuli.bean.Emp\"); //创建属性 CtField f1=CtField.make(\"private String ename;\",cc); CtField f2=CtField.make(\"private int empno;\",cc); cc.addField(f1); cc.addField(f2); //创建方法 CtMethod c1=CtMethod.make(\"public String getEname()&#123;return ename;&#125; \", cc); CtMethod c2=CtMethod.make(\"public void setEname(String ename)&#123;this.ename=ename;&#125; \", cc); cc.addMethod(c1); cc.addMethod(c2); CtMethod c3=CtMethod.make(\"public int getEmpno()&#123;return empno;&#125; \", cc); CtMethod c4=CtMethod.make(\"public void setEmpno(int empno)&#123;this.empno=empno;&#125; \", cc); cc.addMethod(c3); cc.addMethod(c4); //创建构造器 CtConstructor constructor=new CtConstructor(new CtClass[] &#123;pool.get(\"java.lang.String\"), CtClass.intType&#125;, cc); constructor.setBody(\"&#123;this.ename=ename;this.empno=empno;&#125;\"); CtConstructor constructor2=new CtConstructor(null,cc); cc.addConstructor(constructor); cc.addConstructor(constructor2); cc.writeFile(\"d:/MyJava/Emp.java\");//将创建的这一类存放到指定位置上 &#125;&#125; Javaassist的AIP使用 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package com.zhuchuli.javaassist;import java.lang.reflect.Method;import java.util.Arrays;import javassist.ClassPool;import javassist.CtClass;import javassist.CtMethod;import javassist.Modifier;/*** * 测试Javaassist的API * @author 1huangzewei * */public class Demo02 &#123; //处理类的基本用法 public static void test01() &#123; ClassPool pool=ClassPool.getDefault(); try &#123; CtClass cc = pool.get(\"com.zhuchuli.javaassist.Emp\"); //将类转换成字节数组 byte[] bytes=cc.toBytecode(); System.out.println(Arrays.toString(bytes)); System.out.println(cc.getName());//获取类名 System.out.println(cc.getSuperclass());//获取父类 System.out.println(cc.getInterfaces());//获取接口 System.out.println(cc.getSimpleName ());//获得简要类名 &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; //处理方法的基本用法 产生新的方法 public static void test02() &#123; ClassPool pool=ClassPool.getDefault(); try &#123; CtClass cc = pool.get(\"com.zhuchuli.javaassist.Emp\"); //CtMethod method=CtMethod.make(\"public int add(int a,int b)&#123;System.out.println(\\\"test02\\\");return a+b;&#125;\", cc); //第一个参数为返回值类型,第二个参数为方法名 第三个参数为方法参数 第四个参数为所要加入的对象 CtMethod m=new CtMethod(CtClass.intType, \"add\", new CtClass[] &#123;CtClass.intType,CtClass.intType&#125;,cc); //设置方法的修饰符 m.setModifiers(Modifier.PUBLIC); //设置方法体 $1代表参数位置 m.setBody(\"&#123;System.out.println(\\\"test02\\\");return $1+$2;&#125;\"); cc.addMethod(m); Class&lt;?&gt; clazz=cc.toClass(); Object obj=clazz.getConstructor().newInstance(); Method method=clazz.getDeclaredMethod(\"add\", int.class,int.class); Object result=method.invoke(obj, 200,300); System.out.println(result); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; //... 还有注解 构造器 和 属性 public static void main(String[] args) &#123; test01(); &#125;&#125; JVM运行和类加载全过程 为什么要研究加载全过程？ 有助于了解JVM运行过程 更深入了解Java动态性（解耦部署，动态加载），提高程序的灵活性。 类加载全过程 （如下图所示） 加载 链接 （验证 准备 解析）:将Java类的二进制代码合并到JVM的运行状态之中的过程。 初始化：静态属性或静态方法或静态块只会被初始化一次。 使用 卸载 类的主动引用（一定会发生类初始化） new一个类的对象。 调用类的静态成员（除了final常量）和静态方法。 使用java.lang.reflect包的方法对类进行反射调用。 当虚拟机启动，java hello则一定会初始化Hello类，说白了就是先启动main方法所在的类。 当初始化一个类，如果其父类没有被初始化，则会先初始化他的父类。 类的被动引用 当访问一个静态域时，只有真正声明这个域的类才会被初始化。 通过子类引用父类的静态变量，不会导致子类初始化。 通过数组定义类引用，不会触发此类的初始化 引用常量不会触发此类的初始化（常量在编译阶段就存入调用类的常量池中了）。 深入类加载器 类加载器原理 类加载器的作用：将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区中的运行时数据结构，在堆中生成一个代表这个类的java.lang.Class对象，作为方法区类数据的访问入口。 类缓存：标准的JavaSE类加载器可以按要求查找类，但一旦某个类被加载到类加载器中，它将维持加载（缓存）一段时间。不过JVM垃圾集成器可以回收这些Class对象。 类加载器树状结构，双亲委托（代理）机制 引导类加载器（bootstrap class loader） 扩展类加载器（extensions class loader） 应用程序类加载器（application clasas loader） 自定义类加载器 双亲委托机制是为了保证Java核心库的类型安全。（请求 —&gt; 交给父类 —&gt; 交给爷爷辈） tomcat则与此相反 自定义类加载器（文件、网络、加密） 注意：同一个类被不同的加载器加载，JVM也会认为他们不是相同的类 线程上下文类加载器 服务器类加载器原理和OSGI介绍(面向Java的动态模块系统) Eclipse是基于OSGI技术来构建的","categories":[],"tags":[]},{"title":"文件上传","slug":"文件上传","date":"2019-06-28T01:51:14.000Z","updated":"2019-07-03T09:17:14.711Z","comments":true,"path":"2019/06/28/文件上传/","link":"","permalink":"https://CPWS.github.io/2019/06/28/文件上传/","excerpt":"","text":"1. 文件上传功能的实现上传和下载是Web应用开发需求中出现频率较高的词汇。在JSP应用开发过程中，编写“文件上传”功能代码主要有三种方式： 采用自编写的JavaBean组件 采用JspSmart公司自己编写的JspSmartUnload组件 采用O’Reilly公司的Cos组件 1.1 采用自编写的JavaBean组件 要编写一个实现文件上传功能的组件，首先需要先了解数据传输的原理，根据数据处理的规律来完成相关的编码。步骤为： 1.获取上传数据的规律。案列如下： 12&lt;!--如果要实现文件上传功能 需要添加 enctype=\"MULTIPART/FORM-DATA\"--&gt;&lt;form enctype=\"MULTIPART/FORM-DATA\"&gt;&lt;/form&gt; 12//js版给form添加属性，实现文件上传form.encding=\"multipart/form-data\" 1234567891011121314151617181920212223242526272829&lt;!--index.jsp--&gt;&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;文件上载&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=\"up.jsp\" enctype=\"multipart/form-data\" method=\"post\"&gt; 作者： &lt;input type=\"text\" name=\"author\"&gt;&lt;br&gt; 公司： &lt;input type=\"text\" name=\"company\"&gt;&lt;br&gt; 选择要上传的文件 &lt;input type=\"file\" name=\"filename\"&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"上载\"&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;&lt;!--up.jsp--&gt;&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;jsp:useBean id=\"TheBean\" scope=\"page\" class=\"org.xmh.demo.UploadBean\" /&gt; &lt;% TheBean.doUpload(request); %&gt;&lt;/body&gt;&lt;/html&gt; 12345678910111213141516171819package org.xmh.demo;import javax.servlet.ServletInputStream;import javax.servlet.http.HttpServletRequest;import java.io.BufferedWriter;import java.io.FileWriter;import java.io.IOException;import java.io.PrintWriter;public class UploadBean &#123; public void doUpload(HttpServletRequest request) throws IOException &#123; PrintWriter pw=new PrintWriter(new BufferedWriter(new FileWriter(\"d:\\\\xmh.txt\"))); ServletInputStream in=request.getInputStream(); int i=in.read(); while(i!=-1)&#123; pw.print((char)i); i=in.read(); &#125; pw.close(); &#125;&#125; 编写上传组件。 根据上文所述，如果想要获取表单提取的数据，需要设计一个功能类来处理相关的数据信息。下面设计了一个FileUploadBean.java的类，他就是自定义处理上传功能的类。 使用自编写的上传组件。 案例2 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;自编写上传组件--文件上传示例&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=\"selfBean.jsp\" enctype=\"multipart/form-data\" method=\"post\"&gt; 作者：&lt;input type=\"text\" name=\"author\"&gt;&lt;br&gt; 公司：&lt;input type=\"text\" name=\"company\"&gt;&lt;br&gt; 说明: &lt;textarea name=\"comment\" &gt;&lt;/textarea&gt;&lt;br&gt; 选择要上载的文件: &lt;input type=file name=\"filename\"&gt;&lt;br&gt; 文件描述: &lt;input type=\"text\" name=\"description\"&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"Upload\"&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;jsp:useBean id=\"TheBean\" class=\"org.xmh.demo.FileUploadBean\" scope=\"page\"&gt; &lt;% TheBean.setSavePath(\"d:/\"); TheBean.doUpload(request); out.println(\"Filename:\"+TheBean.getFilename()); out.println(\"&lt;BR&gt;内容类型:\"+TheBean.getContentType()); out.println(\"&lt;BR&gt;作者:\"+TheBean.getFieldValue(\"author\")); out.println(\"&lt;BR&gt;公司:\"+TheBean.getFieldValue(\"company\")); out.println(\"&lt;BR&gt;说明:\"+TheBean.getFieldValue(\"comment\")); %&gt; &lt;/jsp:useBean&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123package org.xmh.demo;import javax.servlet.ServletInputStream;import javax.servlet.http.HttpServletRequest;import java.io.*;import java.util.Hashtable;public class FileUploadBean &#123; private String savePath; private String filepath; private String filename; private String contentType; private Hashtable&lt;String, String&gt; fields; // 返回filename私有域的值 public String getFilename() &#123; return filename; &#125; // 返回filepath私有域的值 public String getFilepath() &#123; return filepath; &#125; // 返回savePath私有域的值 public void setSavePath(String savePath) &#123; this.savePath = savePath; &#125; // 返回contentType私有域的值 public String getContentType() &#123; return contentType; &#125; // 返回HTML表单中指定输入元素的值，元素的名字通过fieldName参数指定 public String getFieldValue(String fieldName) &#123; if (fields == null || fieldName == null) return null; return (String) fields.get(fieldName); &#125; private void setFilename(String s) &#123; if (s == null) return; int pos = s.indexOf(\"filename=\\\"\"); if (pos != -1) &#123; filepath = s.substring(pos + 10, s.length() - 1);// Windows浏览器发送完整的文件路径和名字// 但Linux/Unix和Mad浏览器只发送文件名字 pos = filepath.lastIndexOf(\"\\\\\"); if (pos != -1) filename = filepath.substring(pos + 1); else filename = filepath; &#125; &#125; private void setContentType(String s) &#123; if (s == null) return; int pos = s.indexOf(\": \"); if (pos != -1) contentType = s.substring(pos + 2, s.length()); &#125; //处理请求数据的方法 public void doUpload(HttpServletRequest request) throws IOException &#123; ServletInputStream in = request.getInputStream(); // 创建字节数组充当缓冲容器的作用 byte[] line = new byte[128]; int i = in.readLine(line, 0, 128); if (i &lt; 3) return; // -2丢弃换行字符 int boundaryLength = i - 2; String boundary = new String(line, 0, boundaryLength); fields = new Hashtable&lt;String, String&gt;(); while(i!=-1)&#123; String newLine=new String(line,0,i); if(newLine.startsWith(\"Content-Disposition: form-data; name=\\\"\"))&#123; //判断文件类型 if(newLine.indexOf(\"filename=\\\"\") != -1)&#123; setFilename(new String(line,0,i-2)); if(filename == null)&#123; return; &#125; i=in.readLine(line,0,128); setContentType(new String(line,0,i-2)); i=in.readLine(line,0,128); newLine=new String(line,0,i); PrintWriter pw=new PrintWriter(new BufferedWriter(new FileWriter((savePath == null ? \"\":savePath)+filename))); while(i!=-1 &amp;&amp; !newLine.startsWith(boundary))&#123; //文件的最后一行包含换行符 //因此必须检查当前行是否是最后一行 i=in.readLine(line,0,128); if( (i == boundaryLength+2 || i==boundaryLength+4) &amp;&amp; (new String(line,0,i).startsWith(boundary)))&#123; pw.print(newLine.substring(0,newLine.length()-2)); &#125;else&#123; pw.print(newLine); &#125; newLine=new String(line,0,i); &#125; pw.close(); &#125;else&#123; //普通表单输入元素 //获取输入元素名字 int pos=newLine.indexOf(\"name=\\\"\"); String fieldName=newLine.substring(pos+6,newLine.length()-3); i=in.readLine(line,0,128); newLine=new String(line,0,i); StringBuffer fieldValue=new StringBuffer(128); while(i!=-1 &amp;&amp; !newLine.startsWith(boundary))&#123; //最后一行包含换行符 //因此必须检查当前行是否是最后一行 i=in.readLine(line,0,128); if( (i==boundaryLength+2 || i==boundaryLength+4) &amp;&amp;(new String(line,0,i).startsWith(boundary)))&#123; fieldValue.append(newLine.substring(0,newLine.length()-2)); &#125;else fieldValue.append(newLine); newLine=new String(line,0,i); &#125; fields.put(fieldName,fieldValue.toString()); &#125; &#125; i=in.readLine(line,0,128); &#125; &#125;&#125; 1.2 JspSmartUpload上传组件JspSmartUpload是由JspSmart公司开发的，它可以免费下载，下载地址:https://pan.baidu.com/s/10OTcN5GOwNly-Ty9oybwQQ，提取码：4fzf因为要反馈给用户上传成功与否，所以需要将上传功能的执行顺序优先于表单的文本数据执行。 12345678910111213141516171819202122232425&lt;!--上传界面--&gt;&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;上传图片&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=\"upload_pic.jsp\" method=\"post\" enctype=\"multipart/form-data\" name=\"form1\"&gt; &lt;table border=\"1\" align=\"center\" cellpadding=\"1\" cellspacing=\"1\"&gt; &lt;tr&gt; &lt;td height=\"45\" align=\"center\" valign=\"middle\"&gt; 请选择上传的图片 &lt;input type=\"file\" name=\"file\" /&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td align=\"center\"&gt; &lt;input type=\"submit\" name=\"submit\" value=\"上传\" /&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109&lt;!--处理图片 ， 获取上传图图片，然后生成缩略图 --&gt;&lt;%@ page language=\"java\" pageEncoding=\"utf-8\" import=\"java.util.*,java.io.*\"%&gt;&lt;%@ page import=\"com.jspsmart.upload.SmartUpload\"%&gt;&lt;%@ page import=\"javax.servlet.jsp.tagext.TryCatchFinally\"%&gt;&lt;%@ page import=\"javax.imageio.ImageIO\"%&gt;&lt;%@ page import=\"java.awt.image.BufferedImage\"%&gt;&lt;%@ page import=\"javax.servlet.*\"%&gt;&lt;%@ page import=\"javax.servlet.http.*\"%&gt;&lt;%@ page import=\"java.awt.*\" %&gt;&lt;% String path = request.getContextPath(); String basePath = request.getScheme() + \"://\" + request.getServerName() + \":\" + request.getServerPort() + path + \"/\";%&gt;&lt;% SmartUpload mySmartUpload = new SmartUpload();//实例SmartUpload对象 long file_size_max = 4000000; String fileName2;//文件名 String ext;//文件扩展名 String url = \"D:/\";//应保证在WebRoot目录下有此目录的存在 //初始化 mySmartUpload.initialize(pageContext); //只允许上载此类文件 try &#123; //支持上载文件的后缀名 //mySmartUpload.setAllowedFilesList(\"jpg,gif\"); //mySmartUpload.setAllowedFilesList(\"jpg,gif,jpeg,png\"); //不支持指定的后缀 mySmartUpload.setDeniedFilesList(\"exe\"); //上载文件 mySmartUpload.upload();//不指定编码的upload()方法 //mySmartUpload.upload(\"utf-8\");//指定编码的upload()方法 &#125; catch (Exception e) &#123; out.print(\"&lt;script type=\\\"text/javascript\\\"&gt;\"); out.print(\"window.alert(\\\"文件格式不符\\\");\"); out.print(\"window.location=\\\"upload.html;\\\"\"); out.print(\"&lt;/script&gt;\"); &#125; try &#123; com.jspsmart.upload.File myFile = mySmartUpload.getFiles().getFile(0); if (myFile.isMissing()) &#123;//如果没有拿到文件，提示 out.print(\"&lt;script type=\\\"text/javascript\\\"&gt;\"); out.print(\"window.alert(\\\"请先选择要上传的文件\\\");\"); out.print(\"window.location=\\\"upload.html;\\\"\"); out.print(\"&lt;/script&gt;\"); &#125; else &#123; String myFileName = myFile.getFileName();//取得上载的文件的文件名 ext = myFile.getFileExt();//取得后缀名 if (!(ext.length() &gt; 0)) &#123; out.println(\"**************myFileName的文件名是：\" + myFileName); &#125; int file_size = myFile.getSize();//取得文件的大小 String saveUrl = \"\";//文件保存路径 if (file_size &lt; file_size_max) &#123; //更改文件名，取得当前上传时间的毫秒数值 Calendar calendar = Calendar.getInstance(); String fileName = String.valueOf(calendar.getTimeInMillis());//设置新的文件名 saveUrl += fileName + \".\" + ext; myFile.saveAs(saveUrl, mySmartUpload.SAVE_PHYSICAL);//保存文件 //上传完成，开始生成缩略图 java.io.File file = new java.io.File(saveUrl);//读入刚才上传的文件 out.println(\"ext = \" + ext); String newUrl = url + fileName + \"_min.\" + ext;//新的缩略图保存地址 System.out.println(newUrl); BufferedImage image=ImageIO.read(file); int imageWidth=image.getWidth(); //取出图片额宽度 int imageHeight=image.getHeight();//取出图片的高度 int n_w=0; //缩略图的宽度 int n_h=0; //缩略图的高度 System.out.println(\"imageWidth=\"+imageWidth + \";\"+\"imageHeight=\"+imageHeight); float tempDouble; if(imageHeight &gt; imageWidth)&#123; tempDouble = imageHeight /200; &#125;else&#123; tempDouble = imageWidth /200; &#125; n_w = (int) (imageWidth/tempDouble); n_h = (int) (imageHeight/tempDouble); FileOutputStream fos=new FileOutputStream(newUrl); BufferedImage bi=new BufferedImage(n_w,n_h,BufferedImage.TYPE_INT_RGB); Graphics g=bi.getGraphics(); g.drawImage(image,0,0,n_w,n_h,Color.LIGHT_GRAY,null); g.dispose(); ImageIO.write(bi,\"jpg\",fos); &#125; else &#123; out.print(\"&lt;script type=\\\"text/javascript\\\"&gt;\"); out.print(\"window.alert(\\\"上传文件大小不能超过\\\"+(file_size_max/1000)+\\\"K\\\");\"); out.print(\"window.location=\\\"upload.html;\\\"\"); out.print(\"&lt;/script&gt;\"); &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;%&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;处理上传的图片&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 1.3 Cos上传组件 （Cloud Object Storage） Cos组件是O&#39;Reilly公司开发的一款免费组件。 Cos包下载地址：http://www.servlets.com/cos/2.3.1 在Cos组件中MultipartRequest类主要负责文件上传的处理 (1) MultipartRequest有8个构造函数，它们分别是： public MulipartRequest(HttpServletRequest request,String saveDirectory) throws IOException public MultipartRequest(HttpServletRequest request,String saveDirectory,int maxPostSize) throws IOException public MiltipartRequest(HttpServletRequest request,String saveDirectory,int maxPostSize,FileRenamePolicy policy) throws IOException public MultipartRequest(HttpServletRequest request,String saveDirectory,int maxPostSize,String encoding) throws IOException public MultipartRequest(HttpServletRequest request,String saveDirectory,int maxPostSize,String encoding,FileRenamePolicy policy) throws IOException public MultipartRequest(HttpServletRequest request,String saveDirectory,String encoding) throws IOException public MulipartRequest(HttpServletRequest request,String saveDirectory) throws IOException public MulipartRequest(HttpServletRequest request,String saveDirectory,int maxPostSize)throws IOException (2) MultipartRequest类工具有8中方法： public Enumeration getParameters(): 取得请求参数的名称 public String getParameter(String name): 此方法返回参数为name的值 public String[] getParameterValues(String name)：当指定参数具有多个值时，此方法会返回String数组 public Enumeration getFileName()：传回所有文件输入类型的名称 public String getFilesystemNames(String name)： 用此方法得到上传文件的真正的文件名称，这里的name指文件输入类型的名称 public String getContentType(String name)： 此方法得到上传文件的文件类型 public File getFile(String name)：此方法得到一个文件对象，代表存储在服务器上的name值 public String getOriginalFileName(String name)：返回文件在修改政策有效之前的文件名称。 注意：Cos组件在上传大容量文件时，效率比起前面介绍的自编写JavaBean组件和JspSmart上传组件高。 案例： 1234567891011121314151617181920&lt;!--upload.html--&gt;&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;style&gt; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!--enctype的值很重要，upload.jsp处理上传的JSP--&gt; &lt;form action=\"upload.jsp\" enctype=\"multipart/form-data\" name=\"form1\" method=\"post\"&gt; &lt;p&gt;&lt;input type=\"file\" name=\"file1\"&gt;&lt;/p&gt; &lt;p&gt;&lt;input type=\"file\" name=\"file2\"&gt;&lt;/p&gt; &lt;p&gt;&lt;input type=\"file\" name=\"file3\"&gt;&lt;/p&gt; &lt;p&gt;&lt;input type=\"submit\" name=\"Submit\" value=\"上传\"&gt;&lt;/p&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324252627282930313233&lt;%@ page import=\"java.io.File\" %&gt;&lt;%@ page import=\"com.oreilly.servlet.MultipartRequest\" %&gt;&lt;%@ page import=\"java.util.Enumeration\" %&gt;&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;% //文件上传后，保存在d:/JavaWebs String saveDirectory=\"d:\"+ File.separator+\"JavaWebs\"; //每个文化最大500M,最多三个文件，所以... int maxPostSize=3*500*1024*1024; //response的编码为gd2312，同时采用缺省的文件名冲突解决策略，实现上传 MultipartRequest multi=new MultipartRequest(request,saveDirectory,maxPostSize,\"UTF-8\"); //输出反馈信息 Enumeration files=multi.getFileNames(); while (files.hasMoreElements())&#123; System.err.println(\"ccc\"); String name= (String) files.nextElement(); File f=multi.getFile(name); if(f!=null)&#123; String fileName=multi.getFilesystemName(name); String lastFileName=saveDirectory+\"\\\\\"+fileName; out.println(\"上传的文件:\"+lastFileName); out.println(\"&lt;hr&gt;\"); &#125; &#125;%&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 以上内容大部分都是参考一本书叫做《软件开发 JSP》，感谢作者!!!!","categories":[],"tags":[]},{"title":"解决中文乱码","slug":"解决中文乱码","date":"2019-06-28T01:47:18.000Z","updated":"2019-06-28T01:50:29.669Z","comments":true,"path":"2019/06/28/解决中文乱码/","link":"","permalink":"https://CPWS.github.io/2019/06/28/解决中文乱码/","excerpt":"","text":"1.1 熟悉Web应用程序中与编码相关的部分 JSP编译 指定文件的存储编码,很明显。该设置应该位于文件的开头：&lt;%@page pageEncoding=&quot;UTF-8&quot; %&gt; 另外对于一般的class文件，可以在编译的时候指定编码。 JSP输出 指定文件输出到Browser时的使用的编码，该设置也应该设置在文件的开头。&lt;%@page contentType=&quot;text/html;charset=UTF8&quot; %&gt; 该设置与response.setCharacterEncoding(&quot;GBK&quot;);等效 META设置 指定网页使用的编码，该设置对静态网页尤其有用，因为静态网页无法使用采用JSP的设置而且也无法执行response.setCharacterEncoding(&quot;UTF-8&quot;) ；例如：&lt;meta http-equiv=&quot;Content-Type&quot; contentType=&quot;text/html;charset=UTF-8&quot;/&gt; 注意：如果同时采用了JSP输出和meta设置两种编码指定方式，那么JSP指定的优先。因为JSP指定的直接体现在Response中。 Form设置 当浏览器提交表单时，可以指定相应的编码，例如:&lt;form accept-charset=&quot;UTF-8&quot;&gt;&lt;/form&gt;一般不需要设置，浏览器会直接使用网页的编码 1.2 熟悉Web应用程序产生中文乱码的原因 JSP页面被编译成class文件时,如果未指定字符集时,默认使用ISO-8859-1的编码格式，这样中文会出现乱码。 提交表单时如果设定提交方式为Post而没有设置提交的编码的格式，则会以ISO-8859-1方式提交，而接收的JSP却以UTF-8的方式接收，这样也会导致中文乱码。 提交表单时如果设定提交方式为Get而没有设置提交的编码的格式，Tomcat会以GET的默认编码格式ISO8859-1对汉字进行编码，编码后追加到URL，导致接收页面得到的参数为乱码。 1.3 解决中文乱码 设置文件本身的编码格式。这可以在Eclipse或MyEclipse中进行设置。 在JSP页面中指定字符集，通常页面字符集的设置如下： 1234567&lt;%@ page contentType=\"text/html;charset=UTF-8\" %&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=\"Content-Type\" contentType=\"text/html;charset=UTF8\"/&gt; &lt;title&gt;字符集设置联系&lt;/title&gt; &lt;/head&gt;&lt;/html&gt; 数据库连接时指定的字符集。 1String url=\"jdbc:msqyl://localhost:3306/test?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=UTF-8\" 在程序中获取页面数据时使用如下代码 12response.setContentType(\"text/html;charset=UTF-8\");request.setCharacterEncoding(\"UTF-8\"); 注意： 如果需要将中文作为参数传递，需要在传递和接受时进行相应的处理、具体方法如下所示： 在传递参数时对参数编码 : &quot;...RearshRes.jsp?keywords=&quot;+java.net.URLEncoder.encode(keywords) 然后在接收参数页面中使用如下语句接收 keywords=new String(request.getParameter(&quot;keywords&quot;).getBytes(&quot;ISO-8859-1&quot;))","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2019-06-27T05:37:31.802Z","updated":"2019-06-27T05:45:09.482Z","comments":true,"path":"2019/06/27/hello-world/","link":"","permalink":"https://CPWS.github.io/2019/06/27/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Hello HexoCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}